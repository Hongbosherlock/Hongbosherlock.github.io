<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HongboSherlock&#39;blog</title>
  <icon>https://www.gravatar.com/avatar/01a6e634aaa732c8a71d6c3caae87072</icon>
  <subtitle>Stay Hungry, Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongbosherlock.github.io/"/>
  <updated>2021-02-26T15:07:02.218Z</updated>
  <id>https://hongbosherlock.github.io/</id>
  
  <author>
    <name>Xu Hongbo</name>
    <email>hongbosherlock@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode——链表 (更新中)</title>
    <link href="https://hongbosherlock.github.io/2021/02/26/linkedlist/"/>
    <id>https://hongbosherlock.github.io/2021/02/26/linkedlist/</id>
    <published>2021-02-26T15:02:11.000Z</published>
    <updated>2021-02-26T15:07:02.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h3><p>定义一个单链表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p> <strong>为了统一删除操作，可以手动给链表加一个空的头结点</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* start = sas;</span><br></pre></td></tr></table></figure></p><p>让我们从一个经典问题开始：</p><blockquote><p>给定一个链表，判断链表中是否有环。</p></blockquote><a id="more"></a><p>可以使用哈希表解决。但是，使用双指针技巧有一个更有效的解决方案。。</p><p>我们在链表中使用两个速度不同的指针时会遇到的情况：</p><ul><li>如果没有环，快指针将停在链表的末尾。</li><li>如果有环，快指针最终将与慢指针相遇。</li></ul><p>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。</p><h3 id="problem-141-环形链表"><a href="#problem-141-环形链表" class="headerlink" title="problem 141 环形链表"></a>problem 141 环形链表</h3><p>双指针</p><p>算法</p><p>通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><ul><li>如果链表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</li><li>如果链表中存在环，则</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-142-环形链表-II"><a href="#problem-142-环形链表-II" class="headerlink" title="problem 142 环形链表 II"></a>problem 142 环形链表 II</h3><p>To understand this solution, you just need to ask yourself these question.</p><p>Assume the distance from head to the start of the loop is x1<br>the distance from the start of the loop to the point fast and slow meet is x2</p><p>the distance from the point fast and slow meet to the start of the loop is x3</p><p>What is the distance fast moved? What is the distance slow moved? And their relationship?</p><ul><li>x1 + x2 + x3 + x2</li><li>x1 + x2</li><li>x1 + x2 + x3 + x2 = 2 (x1 + x2)</li></ul><p>Thus <code>x1 = x3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *detectCycle(struct ListNode *head) &#123;</span><br><span class="line">    if(head==NULL||head-&gt;next==NULL)</span><br><span class="line">return NULL;</span><br><span class="line">// 快慢结点起始点一样</span><br><span class="line">struct ListNode* slow=head;</span><br><span class="line">struct ListNode* fast=head;</span><br><span class="line">int f=0;</span><br><span class="line">while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">if(slow==fast)&#123;</span><br><span class="line">            f=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">if(f)&#123;</span><br><span class="line">slow = head;</span><br><span class="line">while(slow!=fast)&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-707-设计链表"><a href="#problem-707-设计链表" class="headerlink" title="problem 707 设计链表"></a>problem 707 设计链表</h3><p>有一个空的头结点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyLinkedList* <span class="title">myLinkedListCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyLinkedList *head = (MyLinkedList *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">MyLinkedList* p=obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123; </span><br><span class="line"><span class="keyword">if</span>(i==index)</span><br><span class="line"><span class="keyword">return</span> p-&gt;val;</span><br><span class="line"></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line">newnode-&gt;next = obj-&gt;next;</span><br><span class="line">obj-&gt;next = newnode;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(obj-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"></span><br><span class="line">obj-&gt;next = newnode;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>) <span class="keyword">return</span> myLinkedListAddAtHead(obj, val); ;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">MyLinkedList* p;</span><br><span class="line">p=obj; </span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">newnode-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = newnode;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">MyLinkedList *p,*q;</span><br><span class="line">p=obj;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> </span>&#123;</span><br><span class="line">MyLinkedList* p;</span><br><span class="line"><span class="keyword">while</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">p=obj;</span><br><span class="line">obj=obj-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = myLinkedListCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = myLinkedListGet(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtHead(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtTail(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtIndex(obj, index, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListDeleteAtIndex(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="problem-160-相交链表"><a href="#problem-160-相交链表" class="headerlink" title="problem 160 相交链表"></a>problem 160 相交链表</h3><p><strong>注意对相交的理解：</strong><br>相交不是看值相不相等，而是看两个链表是否公用一个地址。就是指向同一块内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(headA == <span class="literal">NULL</span>||headB == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span> = <span class="title">headA</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">b</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(a!= b)&#123;</span><br><span class="line">    a = a == <span class="literal">NULL</span>? headB : a-&gt;next;</span><br><span class="line">        b = b == <span class="literal">NULL</span>? headA : b-&gt;next;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkgy1g4h3qm3ob0j312e0i23zj.jpg" alt=""></p><p>如上图所示，初始时，a 和 b分别指向两个链表 A、B 的头结点，a 比 b 离尾结点快了一个结点，当 a 到达尾结点后指向链表 B 的头结点，当 b 到达尾结点后指向链表 A 的头结点，此时 a 和 b 离尾结点同样距离，两者会在两个链表的相交结点相遇。</p><ul><li>若没有相交节点，当两指针值都为 NULL 时，跳出循环。</li></ul><h3 id="problem-19-删除链表的倒数第-N-个结点"><a href="#problem-19-删除链表的倒数第-N-个结点" class="headerlink" title="problem 19 删除链表的倒数第 N 个结点"></a>problem 19 删除链表的倒数第 N 个结点</h3><p>为了使所有情况的删除操作一致，添加头结点指向原来的第一个结点，头指针指向头结点</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkgy1g4h5zlqoqwj31910f1abi.jpg" alt=""></p><p><strong>方法一：二次遍历</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">start = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode)); </span><br><span class="line">start-&gt;next=head;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">length++;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">length = length-n;</span><br><span class="line">first=start;</span><br><span class="line"><span class="keyword">while</span>(length)&#123;</span><br><span class="line">length--;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>=<span class="title">first</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">first-&gt;next=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> start-&gt;next;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L−n 步，时间复杂度为 O(L)。</li><li>空间复杂度：O(1)，我们只用了常量级的额外空间。</li></ul><p><strong>方法二：一次遍历</strong></p><p>我们可以使用两个指针而不是一个指针。</p><p>第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">if(head==NULL||head-&gt;next==NULL)</span><br><span class="line">return NULL;</span><br><span class="line">struct ListNode* start;</span><br><span class="line">start = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">start-&gt;next=head;  // 添加空的头结点，使得删除操作一致。</span><br><span class="line">struct ListNode* slow = start;</span><br><span class="line">struct ListNode* fast = start;</span><br><span class="line"></span><br><span class="line">n+=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">while(fast!=NULL)&#123;</span><br><span class="line">fast = fast -&gt; next;</span><br><span class="line">slow = slow-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">struct ListNode* p=slow-&gt;next;</span><br><span class="line">slow-&gt;next=p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">return start-&gt;next;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。</li><li>空间复杂度：O(1)，我们只用了常量级的额外空间。</li></ul><h3 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize slow &amp; fast pointers</span></span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Change this condition to fit specific problem.</span></span><br><span class="line"><span class="comment"> * Attention: remember to avoid null-pointer error</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">    slow = slow-&gt;next;          <span class="comment">// move slow pointer one step each time</span></span><br><span class="line">    fast = fast-&gt;next-&gt;next;    <span class="comment">// move fast pointer two steps each time</span></span><br><span class="line">    <span class="keyword">if</span> (slow == fast) &#123;         <span class="comment">// change this condition to fit specific problem</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// change return value to fit specific problem</span></span><br></pre></td></tr></table></figure><ul><li>在调用 next 字段之前，始终检查节点是否为空。</li><li>仔细定义循环的结束条件。</li></ul><h3 id="problem-206-反转链表"><a href="#problem-206-反转链表" class="headerlink" title="problem 206 反转链表"></a>problem 206 反转链表</h3><p><strong>方法一：迭代</strong></p><p>假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。</p><p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。</li><li>空间复杂度：O(1)。</li></ul><p><strong>方法二：递归</strong></p><p>递归版本关键在于反向工作。假设列表的其余部分已经被反转，现在该如何反转它前面的部分？</p><p>假设列表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 → ··· →n_&#123;k-1&#125; →n_k → n_&#123;k+1&#125;→ ...→n_m → \varnothing</span><br></pre></td></tr></table></figure></p><p>若从节点 $n_{k+1}$ 到 $n<em>m$已经被反转，而我们正处于 $n</em>{k}$ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 → ··· →n_&#123;k-1&#125; →n_k → n_&#123;k+1&#125; ← ... ←n_m</span><br></pre></td></tr></table></figure><p>我们希望 $n_{k+1$的下一个节点指向$n_k$。<br>所以，$n_k.next.next=n_k$</p><p>要小心的是 $n_{1}$ 的下一个必须指向$\varnothing$ 。如果忽略了这一点，链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><p><strong>递归方法一</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newhead</span> = <span class="title">reverseList</span>(<span class="title">head</span>-&gt;<span class="title">next</span>);</span></span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。</li><li>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</li></ul><p><strong>递归方法二</strong></p><p>从头结点开始，从左到右，两两反转，同时记录相邻的两个结点，head在前，nextnode在后。直到尾结点终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseListInt(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseListInt</span><span class="params">(ListNode* head, ListNode* newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextNode</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    head-&gt;next = newHead;</span><br><span class="line">    <span class="comment">//尾递归</span></span><br><span class="line">    <span class="keyword">return</span> reverseListInt(nextNode, head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为是尾递归，系统可以重用栈中的固定空间，所以空间复杂度较小。</p><h3 id="problem-203-移除链表元素"><a href="#problem-203-移除链表元素" class="headerlink" title="problem 203 移除链表元素"></a>problem 203 移除链表元素</h3><p><strong>方法一</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        start-&gt;next = head;</span><br><span class="line">        ListNode* first = start;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;next-&gt;val==val)&#123;</span><br><span class="line">    ListNode* p=first-&gt;next;</span><br><span class="line">    first-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    first=first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>方法二：递归</strong></p><p>Using a recursive method needs more space/memory since it need to build much more stacks on frame.</p><p>方法有弊端，没有 free 被删除的结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeElements</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-328-奇偶链表"><a href="#problem-328-奇偶链表" class="headerlink" title="problem 328 奇偶链表"></a>problem 328 奇偶链表</h3><p>维护两个指针 <code>odd</code> 和 <code>even</code> 分别指向奇数节点和偶数节点，初始时 <code>odd = head，even = evenHead。</code>通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p><p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="image"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* odd = head;  <span class="comment">//奇数结点</span></span><br><span class="line">        ListNode* even = head-&gt;next; <span class="comment">//偶数结点</span></span><br><span class="line">        ListNode* tmp = even;</span><br><span class="line">        <span class="keyword">while</span>(even&amp;&amp;even-&gt;next)&#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="problem-234-回文链表"><a href="#problem-234-回文链表" class="headerlink" title="problem 234 回文链表"></a>problem 234 回文链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">curr-&gt;next = pre;</span><br><span class="line">pre=curr;</span><br><span class="line">curr=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (fast != <span class="literal">NULL</span>) &#123; <span class="comment">// odd nodes: let right half smaller</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow=reverseList(slow);</span><br><span class="line">    fast=head;</span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(slow-&gt;val!=fast-&gt;val)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    slow=slow-&gt;next;</span><br><span class="line">    fast=fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们无法追溯单链表中的前一个结点。因此，我们不仅要存储当前结点，还要存储前一个结点。</li></ul><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表在单链表的基础上增加了一个“prev”指针，用来指向前一个结点。<br><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/17/screen-shot-2018-04-17-at-161130.png" alt="image"></p><p>下面是双链表中结点结构的典型定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for doubly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoublyListNode *next, *prev;</span><br><span class="line">    DoublyListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>), prev(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="双链表操作实现"><a href="#双链表操作实现" class="headerlink" title="双链表操作实现"></a>双链表操作实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoublyListNode *next, *prev;</span><br><span class="line">    DoublyListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>), prev(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="keyword">new</span>  DoublyListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--&amp;&amp;p)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(index&amp;&amp;p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        new_node-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            head-&gt;next-&gt;prev = new_node;</span><br><span class="line">        new_node-&gt;prev = head;</span><br><span class="line">        head-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        DoublyListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        p-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        new_node-&gt;prev = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        DoublyListNode* p =head;</span><br><span class="line">        <span class="keyword">while</span>(index&amp;&amp;p)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            new_node-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                p-&gt;next-&gt;prev = new_node;</span><br><span class="line">            p-&gt;next = new_node;</span><br><span class="line">            new_node-&gt;prev = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(index&amp;&amp;p)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span> &amp;&amp; p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            DoublyListNode* tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next)</span><br><span class="line">                tmp-&gt;next-&gt;prev = p;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="problem-21-合并两个有序链表"><a href="#problem-21-合并两个有序链表" class="headerlink" title="problem 21  合并两个有序链表"></a>problem 21  合并两个有序链表</h3><p><strong>方法 1：递归</strong></p><p>我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125; </span><br><span class="line">list1[0]+merge(list1[1:],list2) &amp; \text &#123;list1[0]&lt;list2[0]&#125; </span><br><span class="line">\\list2[0]+merge(list1,list2[1:]) &amp; \text&#123;otherwise&#125;</span><br><span class="line"> \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* headA, struct ListNode* headB)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (headA == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (headB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (headA-&gt;val &lt; headB-&gt;val) &#123;</span><br><span class="line">            headA-&gt;next = mergeTwoLists(headA-&gt;next, headB);</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            headB-&gt;next = mergeTwoLists(headA, headB-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(n + m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。</li><li>空间复杂度：O(n + m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n +m 个栈帧会消耗 O(n + m) 的空间。</li></ul><p><strong>方法2：迭代</strong></p><p>设置一个 prehead 结点（虚节点），帮助我们轻松返回合并后新链表的头结点。</p><p>循环终止后，l1 和 l2 中最多有一个是非空的。 因此（因为输入列表是按有序的），如果其中一个列表是非空的，那么它包含的元素一定大于所有先前合并的元素。 这意味着我们可以直接将非空列表连接到已合并列表并返回它。</p><p>c 版本<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* headA, struct ListNode* headB)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prehead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> = <span class="title">prehead</span>;</span></span><br><span class="line"><span class="keyword">while</span>(headA!=<span class="literal">NULL</span> &amp;&amp; headB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(headA-&gt;val &lt; headB-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;next = headA;</span><br><span class="line">headA = headA-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">prev-&gt;next = headB;</span><br><span class="line">headB = headB-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">// exactly one of l1 and l2 can be non-null at this point, so connect</span></span><br><span class="line">        <span class="comment">// the non-null list to the end of the merged list.</span></span><br><span class="line">        prev-&gt;next = headA == <span class="literal">NULL</span> ? headB : headA;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>c++ 版本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* prehead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* pre = prehead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(n + m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。</li><li>空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。<br>。</li></ul><h3 id="problem-876-链表的中间结点"><a href="#problem-876-链表的中间结点" class="headerlink" title="problem 876. 链表的中间结点"></a>problem 876. 链表的中间结点</h3><p>当用慢指针 slow 遍历列表时，让另一个指针 fast 的速度是它的两倍。</p><p>当 fast 到达列表的末尾时，slow 必然位于中间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(N)，其中 N 是给定列表的结点数目。</li><li>空间复杂度：O(1)，slow 和 fast 用去的空间。</li></ul><h3 id="problem-2-两数相加"><a href="#problem-2-两数相加" class="headerlink" title="problem  2. 两数相加"></a>problem  2. 两数相加</h3><p>两个链表同时从头开始遍历，注意保留进位。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            sum = n1+n2+tmp;</span><br><span class="line">            tmp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sum/<span class="number">10</span>);</span><br><span class="line">            ListNode* new_node = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            head-&gt;next = new_node;</span><br><span class="line">            <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">            ListNode* new_node = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            head-&gt;next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="problem-61-旋转链表"><a href="#problem-61-旋转链表" class="headerlink" title="problem 61 旋转链表"></a>problem 61 旋转链表</h3><p>先找到最后一个结点与头部连成环，然后找到非旋转与旋转部分的分界点，断开环。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="number">1</span>;</span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        k = n-k%n;</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a>146. LRU 缓存机制</h3><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol><ul><li>这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</li><li>引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h2&gt;&lt;h3 id=&quot;链表定义&quot;&gt;&lt;a href=&quot;#链表定义&quot; class=&quot;headerlink&quot; title=&quot;链表定义&quot;&gt;&lt;/a&gt;链表定义&lt;/h3&gt;&lt;p&gt;定义一个单链表:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct ListNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;为了统一删除操作，可以手动给链表加一个空的头结点&lt;/strong&gt;&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ListNode* start = sas;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;让我们从一个经典问题开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="https://hongbosherlock.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer [第 7 章类]</title>
    <link href="https://hongbosherlock.github.io/2021/02/10/c++_class/"/>
    <id>https://hongbosherlock.github.io/2021/02/10/c++_class/</id>
    <published>2021-02-10T12:37:24.000Z</published>
    <updated>2021-02-11T09:16:08.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章主要关注数据抽象的主要性，数据抽象能帮我们将对象的具体实现与对象所能执行的操作分离开来。</p></blockquote><p>Classes 之间的关系</p><ul><li>继承(inheritance)</li><li>复合(composition)</li><li>委托(delegation)</li></ul><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><ul><li><strong>类的基本思想</strong>：<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）。</li><li>数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程技术。</li></ul><h3 id="类成员-（Member）"><a href="#类成员-（Member）" class="headerlink" title="类成员 （Member）"></a>类成员 （Member）</h3><ul><li>必须在类的内部声明，不能在其他地方增加成员。</li><li><p>成员可以是数据，函数，类型别名。</p><a id="more"></a><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3></li><li><p>成员函数的<strong>声明</strong>必须在类的内部。</p></li><li>成员函数的<strong>定义</strong>既可以在类的内部也可以在外部。</li><li>使用点运算符 <code>.</code> 调用成员函数。实际上是在替<code>.</code>前面的对象调用它。</li><li>必须对任何<code>const</code>或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</li><li><code>ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }</code></li><li>默认实参： <code>Sales_item(const std::string &amp;book): isbn(book), units_sold(0), revenue(0.0) { }</code></li><li><code>*this</code>：<ul><li>每个成员函数都有一个额外的，隐含的形参<code>this</code>。</li><li><code>this</code>总是指向当前对象，因此<code>this</code>是一个<strong>常量指针</strong>。</li><li>形参表后面的<code>const</code>，改变了隐含的<code>this</code>形参的类型，如 <code>bool same_isbn(const Sales_item &amp;obj) const</code>，这种函数称为 <strong>常量成员函数</strong>（<code>this</code>指向的当前对象是常量）。</li><li><code>return *this;</code>返回调用该函数的对象。</li><li>普通的非<code>const</code>成员函数：<code>this</code>是指向类类型的<code>const</code>指针（可以改变<code>this</code>所指向的值，不能改变<code>this</code>保存的地址）。</li><li><code>const</code>成员函数：<code>this</code>是指向const类类型的<code>const</code>指针（既不能改变<code>this</code>所指向的值，也不能改变<code>this</code>保存的地址）。</li></ul></li><li>常量对象只能调用常量成员函数(避免普通成员函数修改常量对象成员的值)。<ul><li>常量对象的 this 指针的类型：<code>const Sales_data *const</code>,与普通成员函数接收的 <code>this</code>指针类型不匹配。</li><li>常量成员函数：<code>string isbn() const</code></li></ul></li><li>普通对象既可以调用常量成员函数也可以调用普通成员函数。</li></ul><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><ul><li>和类相关的非成员函数，定义和声明都应该在类的外部。</li><li>声明与类在同一个头文件中。</li></ul><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li>类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</li><li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。</li><li>构造函数是特殊的成员函数。</li><li>构造函数放在类的<code>public</code>部分。</li><li>与类同名的成员函数。</li><li><code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li><li><code>=default</code>要求编译器合成默认的构造函数。(<code>C++11</code>)</li><li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li></ul><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><ul><li><strong>访问说明符</strong>（access specifiers）：<ul><li><code>public</code>：定义在 <code>public</code>后面的成员在整个程序内可以被访问； <code>public</code>成员<strong>定义类的接口。</strong></li><li><code>private</code>：定义在 <code>private</code>后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； <code>private</code><strong>隐藏类的实现细节。</strong></li></ul></li><li>使用 <code>class</code>或者 <code>struct</code>：都可以被用于定义一个类,唯一的区别在于<strong>访问权限</strong>。<ul><li>使用 <code>class</code>：在第一个访问说明符之前的成员是 <code>priavte</code>的。</li><li>使用 <code>struct</code>：在第一个访问说明符之前的成员是 <code>public</code>的。</li></ul></li></ul><h3 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元(friend)"></a>友元(friend)</h3><ul><li>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>.</li><li>友元的声明以关键字 <code>friend</code>开始。 <code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</li><li>通常将友元声明放在<strong>类定义的开始或者结尾</strong>。<ul><li>在类外也要为友元函数提供独立的声明。 </li></ul></li><li>类之间的友元：<ul><li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</li><li>如果仅指定其它类的成员函数为友元函数，须指明成员函数属于哪个类。</li></ul></li><li>友元函数能定义在类的内部，这样的函数是隐式内联的。</li><li>相同 class 的各个 objects 互为 friends（友元）。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是实现与接口的分离。它隐藏了类型的实现细节。 （在C ++中，通过将实现放在类的私有部分中来实现封装）</p><ul><li>确保用户的代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ul><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><ul><li>成员函数作为内联函数 <code>inline</code>：<ul><li>在类的内部，常有一些规模较小的函数适合于被声明成内联函数。</li><li><strong>定义</strong>在类内部的函数是<strong>自动内联</strong>的。</li><li>在类外部定义的成员函数，也可以在声明时显式地加上 <code>inline</code>。</li><li>inline 成员函数应该与相应的类定义在同一个头文件中。</li></ul></li><li><strong>可变数据成员</strong> （mutable data member）：<ul><li><code>mutable int count;</code></li><li>永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。</li></ul></li><li><strong>类类型</strong>：<ul><li>每个类定义了唯一的类型。</li></ul></li><li>一个 const 成员函数如果以引用的形式返回 *this ，那么它的返回类型将是常量引用。</li><li><code>class Screen</code> 仅声明类，而暂时不定义它。 </li></ul><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul><li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li><li>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</li><li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li><li>类中的<strong>类型名定义</strong>都要放在一开始。</li></ul><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><blockquote><p>单例模式中构造函数在 private 区域。</p></blockquote><ul><li>构造函数初始值列表：<ul><li>如<code>const</code>或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）</li><li>如果成员是<code>const</code> 、引用，或者是某种未提供默认构造函数的类类型，我们必须同感<strong>构造函数初始值列表</strong>为这些成员提供初值。<ul><li>初始化列表是初始化。</li><li>{ } 内是赋值操作。</li></ul></li><li>最好让构造函数初始值的顺序和成员声明的顺序保持一致。</li><li>如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认的构造函数。<ul><li>不能有多个提供了所有实参的构造函数，会导致默认构造函数不明确。 </li></ul></li></ul></li><li>如果定义了其它构造函数，那么最好也提供一个默认构造函数。</li></ul><h3 id="委托构造函数-（delegating-constructor-C-11）"><a href="#委托构造函数-（delegating-constructor-C-11）" class="headerlink" title="委托构造函数 （delegating constructor, C++11）"></a>委托构造函数 （delegating constructor, <code>C++11</code>）</h3><ul><li>委托构造函数将自己的职责委托给了类内想其他构造函数。</li><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</li><li><code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) {}</code></li></ul><h3 id="隐式的类型转换"><a href="#隐式的类型转换" class="headerlink" title="隐式的类型转换"></a>隐式的类型转换</h3><ul><li>如果构造函数<strong>只接受一个实参</strong>，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>。这种构造函数又叫<strong>转换构造函数</strong>（converting constructor）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">// constructs a temporary Sales_data object</span></span><br><span class="line"><span class="comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span></span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure><ul><li>编译器只会自动地执行 <strong>仅一步</strong> 类型转换。</li><li>抑制构造函数定义的隐式转换：<ul><li>将构造函数声明为<code>explicit</code>加以阻止。</li><li>只能在类内声明构造函数时使用 <code>explicit</code> 关键字。</li><li><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化。</li></ul></li></ul><h3 id="聚合类-（aggregate-class）"><a href="#聚合类-（aggregate-class）" class="headerlink" title="聚合类 （aggregate class）"></a>聚合类 （aggregate class）</h3><ul><li>满足以下所有条件：<ul><li>所有成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有<code>virtual</code>函数。</li></ul></li><li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li></ul><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul><li><code>constexpr</code>函数的参数和返回值必须是字面值。</li><li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li><li>数据成员都是字面值类型的聚合类是字面值常量类。</li><li>如果不是聚合类，则必须满足下面所有条件：<ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个<code>constexpr</code>构造函数。</li><li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul></li><li>构造函数不能是<code>const</code>的，但是字面值常量类的构造函数可以是<code>constexpr</code>。</li></ul><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ul><li>非<code>static</code>数据成员存在于类类型的每个对象中。</li><li><code>static</code>数据成员独立于该类的任意对象而存在。</li><li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li><li>声明：<ul><li>声明之前加上关键词<code>static</code>，只出现在类内。</li></ul></li><li>使用：<ul><li>使用<strong>作用域运算符</strong><code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li><li>也可以使用对象访问：<code>r = ac.rate();</code></li></ul></li><li>定义：<ul><li>在类外部定义时不用加<code>static</code>。也可在类内定义。</li></ul></li><li>初始化：<ul><li>通常不在类的内部初始化，而是在类外定义和初始化<ul><li><code>double Account::interestRate = initRate();</code></li></ul></li><li>如果一定要在类内部定义，则要求静态成员必须是字面值常量类型的<code>constexpr</code>。<ul><li><code>static constexptr int period = 30</code></li></ul></li></ul></li><li>静态成员函数不包含 this 指针，也不能声明为 const 的。</li><li>静态数据成员可以作为默认实参。</li><li>静态数据成员的类型可以就是它所属的类类型：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1; <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2; <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3; <span class="comment">// error: data members must have complete type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章主要关注数据抽象的主要性，数据抽象能帮我们将对象的具体实现与对象所能执行的操作分离开来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Classes 之间的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承(inheritance)&lt;/li&gt;
&lt;li&gt;复合(composition)&lt;/li&gt;
&lt;li&gt;委托(delegation)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义抽象数据类型&quot;&gt;&lt;a href=&quot;#定义抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;定义抽象数据类型&quot;&gt;&lt;/a&gt;定义抽象数据类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类的基本思想&lt;/strong&gt;：&lt;strong&gt;数据抽象&lt;/strong&gt;（data abstraction）和&lt;strong&gt;封装&lt;/strong&gt;（encapsulation）。&lt;/li&gt;
&lt;li&gt;数据抽象是一种依赖于&lt;strong&gt;接口&lt;/strong&gt;（interface）和&lt;strong&gt;实现&lt;/strong&gt;（implementation）分离的编程技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类成员-（Member）&quot;&gt;&lt;a href=&quot;#类成员-（Member）&quot; class=&quot;headerlink&quot; title=&quot;类成员 （Member）&quot;&gt;&lt;/a&gt;类成员 （Member）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;必须在类的内部声明，不能在其他地方增加成员。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成员可以是数据，函数，类型别名。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Primer [第 6 章函数]</title>
    <link href="https://hongbosherlock.github.io/2021/01/25/c-func/"/>
    <id>https://hongbosherlock.github.io/2021/01/25/c-func/</id>
    <published>2021-01-25T04:58:49.000Z</published>
    <updated>2021-01-28T15:03:46.765Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h3 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h3><p><strong>1. 实参和形参的区别</strong></p><ul><li>形参：在函数参数列表中声明的局部变量。 它们由每次调用函数时提供的实参初始化。</li><li><p>实参：在函数调用中提供的值，用于初始化函数的形参。</p><p><strong>2. 局部对象</strong></p></li></ul><p>（1）局部静态对象</p><p>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，在函数结束时还存在，直到程序终止才被销毁。</p><ul><li>局部静态对象只被初始化一次。</li></ul><p>(2) 函数应该在头文件中声明，在源文件中定义</p><a id="more"></a><p> <strong>3.分离式编译</strong></p><h3 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h3><p><strong>1. 使用引用避免拷贝</strong></p><p>string 对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare the length of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽量使用常量引用。</li><li>如果函数无需改变引用形参的值，最好将其声明为<strong>常量引用</strong>。</li></ul><p><strong>2. const 形参和实参</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能读取 i，但是不能向 i 写值 */</span>&#125;</span><br></pre></td></tr></table></figure><p>调用 fcn 函数时，既可以传入 const int，也可以传入 int。</p><p><strong>3. 数组引用形参</strong></p><p>形参也可以是数组的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: parameter is a reference to an array; the dimension is part of the type</span></span><br><span class="line">void print(int (&amp;arr)[10])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(&amp;arr)</code> 两端的括号不可少</li><li>这一用法无形中限制了只能将函数作用于大小为 10 的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">printf(k);</span><br></pre></td></tr></table></figure><p><strong>4. 传递多维数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix 指向数组的首元素，该数组的元素是又 10 个整数构成的数组</span></span><br><span class="line">void printf(int (*matrix)[10], int size)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p><strong>5. main 处理命令行选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, int *argv[])</span><br></pre></td></tr></table></figure><ul><li>第二个形参 argv是一个数组，它的元素是指向 C 风格字符串的指针。</li><li>第一个形参 argc 表示数组中字符串的数量。<blockquote><p>argv[0] = “prog”; // or argv[0] might point to an empty string<br>argv[1] = “-d”;<br>argv[2] = “-o”;<br>argv[3] = “ofile”;<br>argv[4] = “data0”;<br>argv[5] = 0;</p></blockquote></li></ul><p>当使用 argv 中的实参时，可选的实参要从 argv[1] 开始，argv[0]保存程序的名字，而非用户输入。</p><p><strong>6. initializer_list 形参</strong></p><p>initializer_list 是一种标准库类型，用于表示某种特定类型的值的数组。</p><p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>initializer_list&lt;T&gt; lst;</code></td><td>默认初始化；<code>T</code>类型元素的空列表</td></tr><tr><td><code>initializer_list&lt;T&gt; lst{a,b,c...};</code></td><td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td></tr><tr><td><code>lst2(lst)</code></td><td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td></tr><tr><td><code>lst2 = lst</code></td><td>同上</td></tr><tr><td><code>lst.size()</code></td><td>列表中的元素数量</td></tr><tr><td><code>lst.begin()</code></td><td>返回指向<code>lst</code>中首元素的指针</td></tr><tr><td><code>lst.end()</code></td><td>返回指向<code>lst</code>中微元素下一位置的指针</td></tr></tbody></table><p><code>initializer_list</code>使用 demo：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_msg</span><span class="params">(ErrCode e, <span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.begin(); beg != il.end(); ++ beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err_msg(ErrCode(<span class="number">0</span>), &#123;<span class="string">"functionX"</span>, <span class="string">"okay&#125;);</span></span><br></pre></td></tr></table></figure><ul><li><code>initializer_list</code> 对象中的元素永远是常量值。</li><li>所有实参类型相同，可以使用 <code>initializer_list</code>的标准库类型。</li><li>实参类型不同，可以使用<code>可变参数模板</code>。</li><li>省略形参符： <code>...</code>，便于<code>C++</code>访问某些 C 代码，这些 C 代码使用了 <code>varargs</code>的 C 标准功能。</li></ul><h3 id="6-3-返回类型和-return-语句"><a href="#6-3-返回类型和-return-语句" class="headerlink" title="6.3 返回类型和 return 语句"></a>6.3 返回类型和 return 语句</h3><p><strong>1. 无返回值函数</strong></p><p>没有返回值的 <code>return</code>语句只能用在返回类型是 <code>void</code>的函数中，返回 <code>void</code>的函数不要求非得有 <code>return</code>语句。</p><p><strong>2.有返回值函数</strong></p><ul><li><code>return</code>语句的返回值的类型必须和函数的返回类型相同，或者能够<strong>隐式地</strong>转换成函数的返回类型。</li><li>值是如何返回的：返回的值用于初始化调用点的一个<strong>临时量</strong>，该临时量就是函数调用的结果。</li><li><strong>不要返回局部对象的引用或指针</strong>。</li><li><strong>引用返回左值</strong>：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix]; <span class="comment">// get_val assumes the given index is valid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">get_val(s, <span class="number">0</span>) = <span class="string">'A'</span>; <span class="comment">// changes s[0] to A</span></span><br></pre></td></tr></table></figure><ul><li><strong>列表初始化返回值</strong>：函数可以返回花括号包围的值的列表。（<code>C++11</code>）</li><li><strong>主函数main的返回值</strong>：如果结尾没有<code>return</code>，编译器将隐式地插入一条返回0的<code>return</code>语句。返回0代表执行成功。</li></ul><p><strong>3. 返回数组指针</strong></p><ul><li><p><code>Type (*function (parameter_list))[dimension]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int (*func(int i))[10];</span><br><span class="line"></span><br><span class="line">- func(int i)表示调用 func 函数时需要一个 int 类型的实参。</span><br><span class="line">- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用的操作</span><br><span class="line">- (*func(int i))[10] 表示解引用 func 的调用将得到一个大小是 10 的数组</span><br><span class="line">- int (*func(int i))[10] 表示数组中的元素是 int 类型。</span><br></pre></td></tr></table></figure></li><li><p>使用类型别名：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];  <span class="comment">// arrT 是一个类型别名，它表示的类型是含有 10 个整数的数组。</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>;];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">()</span> </span>&#123;...&#125;;  <span class="comment">// func 返回一个指向含有 10 个整数的数组的指针。</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>decltype</code>： <code>decltype(odd) *arrPtr(int i) {...}</code></li><li><strong>尾置返回类型</strong>： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在形参列表后面以一个`-&gt;`开始：</span><br><span class="line">auto func(int i) -&gt; int(*)[10]（C++11）</span><br><span class="line">// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组。</span><br></pre></td></tr></table></figure><h3 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h3><ul><li><strong>重载</strong>：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。<blockquote><p>必须要形参数量或者形参类型不同，不能仅仅返回类型不同。</p></blockquote></li><li><code>main</code>函数不能重载。</li><li><strong>重载和const形参</strong>：<ul><li>一个有顶层const的形参和没有它的函数无法区分。 <code>Record lookup(Phone* const)</code>和 <code>Record lookup(Phone*)</code>无法区分。</li><li>相反，是否有某个底层const形参可以区分。 <code>Record lookup(Account*)</code>和 <code>Record lookup(const Account*)</code>可以区分。</li></ul></li><li><strong>重载和作用域</strong>：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。</li></ul><h3 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h3><h4 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h4><ul><li><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></li><li>一旦某个形参被赋予了默认值，那么它<strong>后面</strong>的形参都必须要有默认值。</li><li>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</li></ul><h4 id="内联（inline）函数"><a href="#内联（inline）函数" class="headerlink" title="内联（inline）函数"></a>内联（inline）函数</h4><ul><li>普通函数的缺点：调用函数比求解等价表达式要慢得多。</li><li><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</li><li>适用于规模小，流程直接，频繁调用的函数。</li><li><code>inline</code>函数应该在头文件中定义。</li></ul><h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><ul><li>指能用于常量表达式的函数。</li><li><code>constexpr int new_sz() {return 42;}</code></li><li>函数的返回类型及所有形参类型都要是字面值类型。</li><li>只有一个 return 语句。</li><li><code>constexpr</code>函数应该在头文件中定义。</li></ul><h4 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h4><ul><li><code>assert</code>是一种<strong>预处理宏</strong>（preprocessor macro）</li><li><code>assert(expr);</code> expr 为真时，assert 输出信息并终止程序执行。</li><li>预处理名字由预处理器而非编译器管理。</li></ul><p>开关调试状态：</p><p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        <span class="comment">// 如果 NDEBUG 未定义，则执行这段代码</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h3><ul><li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li><li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li><li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。</li><li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li></ul><h3 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h3><p><strong>函数指针</strong>：是指向函数的指针。函数的类型由它的<strong>返回类型</strong>和<strong>形参类型</strong>共同决定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">//该函数类型是 bool(const string &amp;, const string &amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数指针 pf，pf 两端的括号必不可少</span></span><br><span class="line"><span class="comment">// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"></span><br><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// equivalent call</span></span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// equivalent call</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>函数指针形参</strong>：<ul><li>形参中使用函数定义或者函数指针定义效果一样。</li><li>使用类型别名或者<code>decltype</code>。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line">void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line">void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;));</span><br></pre></td></tr></table></figure><p>直接使用函数指针冗长而繁琐：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Func and Func2 have function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>; <span class="comment">// equivalent type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FuncP and FuncP2 have pointer to function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>; <span class="comment">// equivalent type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent declarations of useBigger using type aliases</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, Func)</span></span>; <span class="comment">//编译器自动地将 Func 表示的函数类型转换为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li><strong>返回指向函数的指针</strong>：<ul><li>1.类型别名；<ul><li><code>using F = int(int*, int); // F is a function type, not a pointer</code></li><li><code>using PF = int(*)(int*, int); // PF is a pointer type</code></li></ul></li><li>2.尾置返回类型。<ul><li>decltype 作用于某个函数时，它返回函数类型而不是指针，需要显式地加上 <code>*</code></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 实参和形参的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形参：在函数参数列表中声明的局部变量。 它们由每次调用函数时提供的实参初始化。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实参：在函数调用中提供的值，用于初始化函数的形参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 局部对象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）局部静态对象&lt;/p&gt;
&lt;p&gt;局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，在函数结束时还存在，直到程序终止才被销毁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部静态对象只被初始化一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) 函数应该在头文件中声明，在源文件中定义&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——二叉树 (更新中)</title>
    <link href="https://hongbosherlock.github.io/2021/01/10/binary-tree/"/>
    <id>https://hongbosherlock.github.io/2021/01/10/binary-tree/</id>
    <published>2021-01-10T09:45:25.000Z</published>
    <updated>2021-02-26T15:06:01.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何遍历一棵树"><a href="#如何遍历一棵树" class="headerlink" title="如何遍历一棵树"></a>如何遍历一棵树</h3><p><strong>1. 前序遍历</strong></p><blockquote><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p></blockquote><p><strong>2. 中序遍历</strong></p><blockquote><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p></blockquote><p>通常来说，对于<strong>二叉搜索树</strong>，我们可以通过中序遍历得到一个<strong>递增</strong>的有序序列。 </p><p><strong>3. 后序遍历</strong></p><blockquote><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p></blockquote><p>当删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。</p><ul><li>前、中、后遍历用到了 <strong>栈</strong>，层序遍历用到了 <strong>队列</strong>。<br><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymmjeuu8j317w0l6gof.jpg" alt=""><a id="more"></a><br><strong>后缀表达式</strong></li></ul><p>编写程序来解析后缀表示法更为容易。 这里是一个例子：</p><p><img src="https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/2/traverse-a-tree/Figures/binary_tree/mathematical_expression.png" alt="image"></p><ul><li><p>可以使用<strong>中序遍历</strong>轻松找出原始表达式。 注意检查操作的优先级。</p></li><li><p><strong>后序遍历</strong>，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p></li></ul><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144  二叉树的前序遍历"></a>144  二叉树的前序遍历</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        preorderTraversal(root-&gt;left);</span><br><span class="line">        preorderTraversal(r</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        oot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用 <strong>深度优先搜索</strong> 的思想</p><p>在 A 的两棵子树中，遍历完左子树后，再遍历右子树。</p><p>从根节点开始，每次迭代弹出当前栈顶元素，并将其孩子节点压入栈中，先压右孩子再压左孩子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="comment">// 注意 stack 的类型是 TreeNode*</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            output.push_back(node-&gt;val);</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;<span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。</li><li>空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</li></ul><h3 id="94-二叉树中序遍历"><a href="#94-二叉树中序遍历" class="headerlink" title="94  二叉树中序遍历"></a>94  二叉树中序遍历</h3><h4 id="基于栈的遍历"><a href="#基于栈的遍历" class="headerlink" title="基于栈的遍历"></a>基于栈的遍历</h4><p><strong>思路</strong>：</p><ul><li>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。</li><li>在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        TreeNode* curr=root;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(curr);</span><br><span class="line">                curr= curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            v.push_back(curr-&gt;val);</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="145-二叉树后序遍历"><a href="#145-二叉树后序遍历" class="headerlink" title="145 二叉树后序遍历"></a>145 二叉树后序遍历</h3><p>从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从右至右左顺序依次压入栈中。</p><p>因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            v.insert(v.begin(),node-&gt;val);</span><br><span class="line">            <span class="comment">// 在头部插入新元素</span></span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* last = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* node = s.top();</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; right &amp;&amp; last != node -&gt; right) &#123;</span><br><span class="line">                    root = node -&gt; right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v.push_back(node -&gt; val);</span><br><span class="line">                    last = node;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102 二叉树的层序遍历"></a>102 二叉树的层序遍历</h3><p>当我们在树中进行 <strong>广度优先搜索</strong> 时，我们访问的节点的顺序是按照层序遍历顺序的。</p><p>使用 <strong>队列</strong> 来实现广度优先搜索</p><p><strong>方法一：递归</strong></p><ul><li>输出列表称为 res，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 res.size() 的大小，如果前者更大就向 res 添加一个空列表。</li><li>将当前节点插入到对应层的列表 res[level] 中。</li><li>递归非空的孩子节点：helper(node-&gt;left / node-&gt;right, level + 1)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==level)       </span><br><span class="line">            res.resize(level+<span class="number">1</span>);    <span class="comment">//level表示层数，也对应二维数组的第一层索引，</span></span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            helper(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：迭代</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> n=q.size();<span class="comment">//计算当前层有多少个元素：等于队列的长度。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//当前队列中的结点都是同一层的</span></span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                v.push_back(node-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="运用递归"><a href="#运用递归" class="headerlink" title="运用递归"></a>运用递归</h3><p>许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。</p><h4 id="“自顶向下”-的解决方案"><a href="#“自顶向下”-的解决方案" class="headerlink" title="“自顶向下” 的解决方案"></a>“自顶向下” 的解决方案</h4><p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种 <strong>前序遍历</strong>。</p><blockquote><ol><li>return specific value for null node</li><li>update the answer if needed                      // anwer &lt;– params</li><li>left_ans = top_down(root.left, left_params)      // left_params &lt;– root.val, params</li><li>right_ans = top_down(root.right, right_params)   &gt;// right_params &lt;– root.val, params</li><li>return the answer if needed                      &gt;// answer &lt;– left_ans, right_ans</li></ol></blockquote><p><strong>二叉树的最大深度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用“自顶向下”方案的情况</strong></p><ul><li>可以确定一些参数，从该节点自身解决出发寻找答案。</li><li>可以使用这些参数和节点本身的值来决定什么应该是 <strong>传递给它子节点</strong> 的参数。</li></ul><h4 id="“自底向上”-的解决方案"><a href="#“自底向上”-的解决方案" class="headerlink" title="“自底向上” 的解决方案"></a>“自底向上” 的解决方案</h4><p>在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是 <strong>后序遍历</strong> 的一种。</p><blockquote><ol><li>return specific value for null node</li><li>left_ans = bottom_up(root.left)          // call function recursively for left child</li><li>right_ans = bottom_up(root.right)        // call function recursively for right child</li><li>return answers                           // answer &lt;– left_ans, right_ans, root.val</li></ol></blockquote><p><strong>二叉树的最大深度</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>;  <span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用“自底向上”方案的情况</strong></p><ul><li>对于树中的任意一个节点，如果知道它 <strong>子节点</strong> 的答案，我们能计算出该节点的答案。</li></ul><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h3><p><strong>方法一：BFS</strong></p><ul><li>层序遍历二叉树，最大层数就是二叉树的深度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,n;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        n=q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p -&gt; left != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(p -&gt; right != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二：DFS</strong></p><p>双栈法：</p><ul><li>一个栈存储结点</li><li>一个栈存储当前深度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        res.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> dep=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">int</span> temp=res.top();</span><br><span class="line">            dep=max(dep,temp);</span><br><span class="line">            res.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">                res.push(temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">                res.push(temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>如果同时满足下面的条件，两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ul><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymos6v6qj30zk0k0tat.jpg" alt=""></p><p><strong>递归</strong></p><p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，pp 指针和 qq 指针一开始都指向这棵树的根，随后 pp 右移时，qq 左移，pp 左移时，qq 右移。每次检查当前 pp 和 qq 节点的值是否相等，如果相等再判断左右子树是否对称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* p ,TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p||!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> (q-&gt;val==p-&gt;val)&amp;&amp;check(p-&gt;left,q-&gt;right)&amp;&amp;check(p-&gt;right,q-&gt;left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>引入一个<strong>队列</strong>，这是把递归程序改写成迭代程序的常用方法。<br>初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u); q.push(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            u = q.front(); q.pop();</span><br><span class="line">            v = q.front(); q.pop();</span><br><span class="line">            <span class="comment">//注意下面条件的判断</span></span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;left); </span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;right); </span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h3><p><strong>递归</strong></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> sum==root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val)||hasPathSum(root-&gt;right,sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>广度优先搜索</strong></p><p>使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p><p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qval;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        qval.push(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            TreeNode* node=q.front();</span><br><span class="line">            <span class="keyword">int</span> val=qval.front();</span><br><span class="line">            q.pop(); qval.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum==val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                qval.push(val+node-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">                qval.push(val+node-&gt;right-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106  从中序与后序遍历序列构造二叉树"></a>106  从中序与后序遍历序列构造二叉树</h3><p>我们可以发现后序遍历的数组最后一个元素代表的即为根节点。知道这个性质后，我们可以利用已知的根节点信息在中序遍历的数组中找到根节点所在的下标，然后根据其将中序遍历的数组分成左右两部分，左边部分即左子树，右边部分为右子树，针对每个部分可以用同样的方法继续递归下去构造。</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymr2itr5j31jk0v9dn2.jpg" alt=""></p><ul><li>为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（元素，下标）键值对的哈希表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> post_end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootval=postorder[post_end];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line">        post_end--;</span><br><span class="line">        <span class="keyword">int</span> mid=m[rootval];</span><br><span class="line">        </span><br><span class="line">        root-&gt;right=helper(mid+<span class="number">1</span>,right,inorder,postorder);</span><br><span class="line">        root-&gt;left=helper(left,mid<span class="number">-1</span>,inorder,postorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(!inorder.size()||!postorder.size())</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        post_end=(<span class="keyword">int</span>)postorder.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)inorder.size();</span><br><span class="line">        <span class="keyword">int</span> in_start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[inorder[i]]=in_start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,n<span class="number">-1</span>,inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p>对于任意一颗树而言，前序遍历的形式总是</p><blockquote><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p></blockquote><p>而中序遍历的形式总是:</p><blockquote><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p></blockquote><p>初始时左子树的</p><ul><li>左子树的根节点是前序遍历中当前根节点的下一个元素。</li><li>右子树的根节点是前序遍历中当前根节点加上左子树的元素个数再加一。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pre_start,<span class="keyword">int</span> in_start,<span class="keyword">int</span> in_end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_start&gt;preorder.size()||in_start&gt;in_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[pre_start];</span><br><span class="line">        <span class="keyword">int</span> mid = m[root_val];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        root-&gt;left=helper(pre_start+<span class="number">1</span>,in_start,mid<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">        root-&gt;right=helper(pre_start+mid-in_start+<span class="number">1</span>,mid+<span class="number">1</span>,in_end,preorder,inorder);</span><br><span class="line">        <span class="comment">//先构建左子树或者右子树都行</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=inorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            m[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何遍历一棵树&quot;&gt;&lt;a href=&quot;#如何遍历一棵树&quot; class=&quot;headerlink&quot; title=&quot;如何遍历一棵树&quot;&gt;&lt;/a&gt;如何遍历一棵树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 前序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. 中序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常来说，对于&lt;strong&gt;二叉搜索树&lt;/strong&gt;，我们可以通过中序遍历得到一个&lt;strong&gt;递增&lt;/strong&gt;的有序序列。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 后序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前、中、后遍历用到了 &lt;strong&gt;栈&lt;/strong&gt;，层序遍历用到了 &lt;strong&gt;队列&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymmjeuu8j317w0l6gof.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://hongbosherlock.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>请回答 2020</title>
    <link href="https://hongbosherlock.github.io/2020/12/31/2020-sum/"/>
    <id>https://hongbosherlock.github.io/2020/12/31/2020-sum/</id>
    <published>2020-12-31T10:51:38.000Z</published>
    <updated>2021-01-30T02:30:20.660Z</updated>
    
    <content type="html"><![CDATA[<p>马上就到了 2021 年了，感觉今年过的尤其快。这是新冠疫情爆发的一年，也是我本科毕业的一年，那些人那些物不知何时再见。今年的最后我是一个人，在这个安静的夜晚，回忆在暗处流动，未来在偷偷发芽。</p><p>回顾了一下去年的总结，2019年对我来说是不太顺利的一年。其实我也有一些决策上的错误，错过了一些机会，也浪费了时间。好在最后折腾下来结果还不算差，仿佛去年的不顺在今年都转为了好运。</p><a id="more"></a><p>去年的 12.31 号我在图书馆里写下了年终总结，当时考完研的我对未来并不确定，也有不少迷茫。佩服那些很早就想清楚自己的方向，并为之努力的人。大学前两年我的路就是学习，拿奖学金，以后读研，对于未来还有哪些可能，我并没有思考很多。有的想了想，觉得并不可行也就算了。为绩点而努力，少了些 coding 的能力。现在想想我应该在大三暑假前找个实习的，有一段真实的工作经历。</p><p>“把目标设在月球，即使失败也能落在众星之间。”离开成都去北京，我想跳出之前的舒适环境，去闯一闯。当时觉得考研只是一种途径，即使失败我还有春招的机会。并没有二战的想法，或者担心我要怎么办的问题。</p><p>于是疫情在家里躺了两个月后，三月份我便开始准备春招了。复习知识点，刷题，面试。在面试过程中慢慢有了自信，找到了方向，最后有幸拿到了美团的 Java 开发 offer。看到牛客网上有发帖说考研失败然后拿到百度和字节的offer的大佬，觉得真的挺厉害的，功夫不负有心人啊。</p><p>5月份回校后接到现在导师的电话，最后面试通过成功补录。还记得当时和 lu 腾讯会议，她帮我纠正英文自我介绍。面试和毕设答辩赶在了一上午，面试后觉得很糟糕，没戏了。第二天和 xiao 打游戏时突然接到了通过的电话，顿时觉得时来运转。</p><p>最后选择了读研，有一部分是妥协，还有一点对工作的逃避，也有一些对研究生生活的期待。这是我自己的选择。</p><h3 id="1-告别与遇见"><a href="#1-告别与遇见" class="headerlink" title="1. 告别与遇见"></a>1. 告别与遇见</h3><p>成都是一座有烟火气息的慢节奏城市，川大有着包容的氛围，江安则是一片安静的乐土。回顾我的大学四年，并不算很精彩，也有一些遗憾，但这些并不妨碍在江安的日子将是我人生中一段美好的回忆。本科已经结束，我们遇见，然后告别。然而人生的大学仍在继续，并没有毕业的那一天。</p><p>来到北京，雁栖湖是一个远离市区很安静的地方。我觉得自己在这一学期是比较分裂的，一边需要上已经被安排好的不太感兴趣的课，一边在努力挤时间自学想学的知识。耗费了不少精力在不想做的事情上，自己想做的事情却进展不多。</p><p>在这里因为摄影遇到了一些新朋友，很开心。加入了记者团摄影部和摄影协会，后面感觉自己并没有融入进去，也许这就是我吧。</p><p>读研后，总有一种焦虑感，担心自己会落后于学校外的时代。25岁毕业，别人已经工作、在社会摸爬滚打了三年，而我还是初生牛犊。要多 coding，多实习，多思考。</p><p>要说今年的收获，春招拿到 offer，读上研。毕业前在学校度过了一个月的时光，参加了毕业典礼。用新买的相机给一些同学拍了毕业照。暑假拿到了驾照，跟着我爸去贵州玩了一周，今年难得的一次旅游。</p><p>下学期除了上课，还做了一件事，给实验室和医院合作的项目写了一个 PC 软件，虽然只是一个用 pyqt 写的简单 UI，看上去还不错，只是还需要再改进。</p><p>在未来到来之前，我们还是分开了。今夕的拥抱与临别，未曾断定恋情的结束。曾经在一起，也许没有什么是比这更重要的存在。</p><blockquote><p>人生有那么多可能，这么多也有趣，有意思，有意义的事情。为什么不去学，为什么不去做？几年之后你会发现，自己曾经烦恼的事情，不能算是人生中百分之一，更不能算作是浩瀚宇宙中的一抹流星。你遇见一个人，是为了成就更好的自己，还是为了尽情沉湎在过去的自己里？人生有百般借口，何须烦恼择其一。</p></blockquote><p>有时候感觉压力太多，想要逃避社会上的条条框框，去追求自由。但是抛弃一切就真的是自由了吗？也许不是，实际上我们没法单单为自己而活，我们不想承担责任，想独自一人，但是没法做到。我们不仅为自己而活，也为别人而活。对一个人来说，真正重要的是【懂得自由选择】，而不是【选择自由】。</p><h3 id="2-未来"><a href="#2-未来" class="headerlink" title="2. 未来"></a>2. 未来</h3><blockquote><p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。<br>——王小波《黄金时代》</p></blockquote><p>20多岁的年纪，刚刚大学毕业，就能真真正正想清楚一辈子要怎么活了吗？我并不外向，但我并不是一个喜欢宅的人，也不是一个安分的人。</p><p>知乎上有个<a href="https://www.zhihu.com/question/19832061" target="_blank" rel="noopener">23 岁的你曾处于什么样的状态？</a>的问题，我觉得里面的回答都不错。人只有不断保持努力，才会每年都是过去人生的巅峰。</p><p>对于明年要做的事情，我首先想到的就是<strong>学会游泳</strong>，我觉得这是一个很重要的生存技能。然后就是<strong>摄影</strong>，买相机还不到半年，但最近几周都没怎么动相机。明年要多学习，多拍，多思考。我会把一些觉得满意的照片发在这里。第三读更多的<strong>书</strong>，看更多的<strong>电影</strong>。学好<strong>C++</strong>，刷起 <strong>leetcode</strong>。最后，争取发一篇<strong>论文</strong>吧，现在还没决定具体做什么方向。</p><p>希望我的2021，我的23岁：</p><p><strong>不为过去后悔，永远相信未来。</strong></p><p>最后，祝各位：新年愉快，家庭和睦，事业有成，身体安康，温良恭谨，正直善良，无愧于心，怀有理想。</p><p>感谢大家的关注与支持，我们 2021 再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;马上就到了 2021 年了，感觉今年过的尤其快。这是新冠疫情爆发的一年，也是我本科毕业的一年，那些人那些物不知何时再见。今年的最后我是一个人，在这个安静的夜晚，回忆在暗处流动，未来在偷偷发芽。&lt;/p&gt;
&lt;p&gt;回顾了一下去年的总结，2019年对我来说是不太顺利的一年。其实我也有一些决策上的错误，错过了一些机会，也浪费了时间。好在最后折腾下来结果还不算差，仿佛去年的不顺在今年都转为了好运。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://hongbosherlock.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="https://hongbosherlock.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>智能陷阱：愿者上钩</title>
    <link href="https://hongbosherlock.github.io/2020/11/17/social-dilemma/"/>
    <id>https://hongbosherlock.github.io/2020/11/17/social-dilemma/</id>
    <published>2020-11-17T09:54:42.000Z</published>
    <updated>2021-02-10T04:59:42.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg" alt=""></p><p>回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。<a id="more"></a></p><p>前一阵子看了一部 Netflix 的纪录片——《监视资本主义：智能陷阱 The Social Dilemma》。特里斯坦·哈里斯是谷歌前设计道德伦理专家，他呼吁技术产业在产品中引进被他称为“道德伦理设计”的要素。硅谷之前的商业模式是公司通过销售硬件、软件这样的产品来盈利。而过去十年硅谷则一直在通过“出售”用户来盈利。</p><p>二十多年前，雅虎的杨致远和费罗首创了免费的互联网服务，并且找到了广告这种商业模式，这才让互联网成为一个开放免费的工具。如今网上已经有了很多免费产品，如果我们不用为使用这些产品付钱，那谁来付钱呢？广告商为我们使用的产品付钱。换句话说，广告商是顾客，我们是被销售的商品。</p><p><strong>“如果你没有花钱买产品，那你就是被卖的产品。”</strong>所谓的免费并不是真正的免费，而是广告商在为用户的注意力付钱，我们付出的是自己的时间。手机上各种应用，每天不断推送着通知，都在竞争用户的注意力，想办法增加日活，向广告商出售更多用户的时间。大部分应用会记录用户的浏览记录，甚至在哪张图片或视频上停留了多久。（这是真的）</p><p>我们在互联网上的数据被偷偷共享（还记得在QQ空间看到的京东广告吗），即使使用协议在某个地方注明了这一点，我们也并没有被着重通知。同时我们的数据被公司用来构建更精确的模型，来预判用户行为进而迎合用户：让我们不停滑动屏幕，沉浸其中。</p><p>那些精明的产品经理一般都比较了解心理学，深谙人性的弱点。他们黑入人们的心理，利用这一点一点点来慢慢操纵用户的使用习惯，而用户往往不知不觉地深陷其中。无论是“对方正在输入中”还是“下拉刷新内容”都是对我们心理上的某种操纵。每次下拉刷新都会出现新的内容，这在心理学上叫做“正积极强化”，给用户反馈和激励，有点像赌城的老虎机。</p><p>“我们想在心理学上弄清楚，怎么样以最快的速度操纵你。然后返回给让你产生兴奋的事物。”一位脸书的前用户增长负责人曾经说道。无论是点赞，还是粉丝数增加（有不少是僵尸粉），都是在实践这一点。这就是在利用人们心理的脆弱来赚钱。</p><p>社交媒体就像是毒品。我们都有着基本的欲望去和别人联系，需要和别人有社会性联系，需要得到认可。但我们不需要得到一万人的认可，也不需要每隔五分钟就获得一次社交认可。没有手机，我们能独处吗，可以处理自己的情绪吗？那些不自在、孤独、害怕的情绪很多时候都在指尖麻木地滑动屏幕之时被忽视了。</p><center><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0go8bt5j30zk0k00uk.jpg" alt=""></center><p>如摩尔定律所预测的那样，技术在快速进步，但是人脑却进化缓慢。我们一直在担忧人工智能发展带来的负面影响：人工智能会超过人类的智慧，最终觉醒然后统治人类吗？无论是《终结者》还是《我，机器人》都在传达这种担忧。虽然未来还不太明了，但事实上人工智能已经在碾压人性的弱点了。那些算法在促进人们的两极分化，使我们上瘾，变得激进化，激化我们的虚荣心……</p><p>纪录片中提到，Google 会基于人们的地理位置来进行搜索提示和展示搜索结果排序。这也使得人们变得两极分化，因为一个人看到的往往都是自己感兴趣的内容。Facebook可以说是一个强大的操纵工具，甚至可以对大选产生影响。互联网和社交媒体不断在动摇和侵蚀社会结构。问题不仅仅是观点的对立，而是极端的两极分化，各方丝毫不听取对方的观点，拒绝沟通。</p><p>人工智能并不知道什么是真理，只是被数据训练奔着某个最优的目标，算法是冰冷无情的。AI无法解决谣言和人们之间的对立。在互联网上谣言的传播是真相的6倍。虚假信息往往比较符合大众的口味，会吸引人们的兴趣。而真相和事实相比往往比较枯燥，所以人们会自发转发虚假信息，AI算法也会根据人们的”兴趣”不停地推荐虚假信息。新冠时期传播得快的不止是新冠，还有谣言。美国甚至有”新冠无害，5G有害”的谣言，人们冲上街上推倒5G信号杆，无不荒唐。</p><p>可以说，某种程度上人工智能算法技术在方便我们生活的同时，也把社会中最坏的东西带出来了，并通过网络放大传播，而这些东西是人类社会的威胁。</p><p>什么是「工具」？什么是「产品」？你在使用产品还是你是产品的一部分？这也许是我们每个人都应该思考的。</p><p>要终止现在的这一切很难，平台越做越大，雪球也越滚越大，很难停下来。而且互联网公司有自己营收和股东的压力，仅靠公司的自觉并不够，因此这些公司需要被监管，也急需数据隐私方面的立法。</p><p>推荐算法建造了信息茧房，也弱化了人们的主动思考。我们与之对抗的手段之一是不看推荐的内容，而是主动思考自己想要什么，搜索自己想要的内容。同时建造我们自己的信息茧房也同样重要，关键是选择可靠的信源，这样我们可以尽可能地屏蔽垃圾信息，获取更有价值的信息。</p><p>纪录片中提到，也可以通过下面这些方法减少社交网络的影响：关掉所有通知；分享之前，查找事实，思考信息来源，不要被情绪煽动；减少屏幕使用时间，减少社交媒体时间。不带电子设备进卧室；很多年轻人容易沉迷网络，也许比较好的做法是不要让16岁之前的孩子使用社交媒体。</p><center><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0h1efpoj30zk0ij75i.jpg" alt="你会选择哪一个"><br><div style="font-size:16px;color:#C0C0C0;text-decoration:underline">你会选择哪一个</div></center> <p>Elon musk做过一个访谈 提到了一些社交媒体的负面影响。其中有一点就是，很多人在朋友圈里分享的都是自己最快乐精彩的片段。这样的片段让很多人看到了会抑郁，因为自己的生活并没这么快乐精彩。其实上大部分人99%的时间都是不那么精彩的，大家只是有选择性的分享一些最好的时光。</p><p>我在过去一个月的时间里，周一到周五关闭朋友圈，周末两天打开。因为我平时总会时不时刷朋友圈，这样做确实减少一些了我看手机的时间，感觉效果还不错。但这样做的缺点就是，我不能及时和朋友互动：可能会错过最近发生的事情、少了给别人的点赞和评论。（有意思的是，设计 Facebook 点赞按钮的工程师的初衷是想通过“点赞”传递爱，现在我们却越来越在意点赞了。）</p><p>总之，在是否使用社交网络上需要做一些 Trade-off。但同时我们可以改变自己的一些不好的习惯，吃饭、睡觉、上厕所一直盯着手机，或者学习时被不断打扰。否则这样下去我们只会变成成天盯着屏幕看、把注意力都贡献成广告商的僵尸，从而错过自己本可以拥有的美好人生。</p><p>不妨放下手机，去外面走走，陪一陪自己爱的人和朋友吧。</p><p>推荐阅读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNTQ4ODg4OA==&amp;mid=2247486326&amp;idx=1&amp;sn=fb2b4998bb6a817d4fe08d658ce0384e&amp;chksm=e8e71861df909177e1f602b9f77df389f702e97b250270588b1d716ab5ad67194afe601910c1&amp;scene=21&amp;token=1554957162&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">「黑客帝国」和「楚门的世界」 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。
    
    </summary>
    
      <category term="科技" scheme="https://hongbosherlock.github.io/categories/%E7%A7%91%E6%8A%80/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://hongbosherlock.github.io/2020/03/29/queue/"/>
    <id>https://hongbosherlock.github.io/2020/03/29/queue/</id>
    <published>2020-03-29T09:41:19.000Z</published>
    <updated>2021-01-23T02:44:09.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><p>队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在 <strong>队列的末尾</strong>。 删除（delete）操作也被称为出队（dequeue)。 你只能移除 <strong>第一个元素</strong>。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png" alt="image"><br><a id="more"></a></p><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><p>为了实现队列，我们可以使用 <strong>动态数组</strong> 和 <strong>指向队列头部的索引</strong>。</p><p>如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// store elements</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">        <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyQueue() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.push_back(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">//出队时注意判断队列是否为空</span></span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.enQueue(<span class="number">5</span>);</span><br><span class="line">    q.enQueue(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>C++ STL</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line">q.front(); <span class="comment">//访问队列的队首元素</span></span><br><span class="line">q.back();  <span class="comment">//访问队列的队尾元素</span></span><br><span class="line">q.size();  <span class="comment">//队列的元素个数</span></span><br><span class="line">q.pop();   <span class="comment">//移除队列的队首元素</span></span><br></pre></td></tr></table></figure></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>我们可以使用 <strong>固定大小的数组</strong> 和 <strong>两个指针</strong> 来指示起始位置和结束位置。 目的是 <strong>重用</strong> 我们之前提到的被浪费的存储。</p><ul><li>队首指head针和队尾指针tail重合时，队列为空</li><li>tail+1 = head 时，队列满</li></ul><h2 id="队列和广度优先搜索"><a href="#队列和广度优先搜索" class="headerlink" title="队列和广度优先搜索"></a>队列和广度优先搜索</h2><h4 id="1-结点的处理顺序是什么？"><a href="#1-结点的处理顺序是什么？" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h4><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p><p>与树的层序遍历类似，<strong>越是接近根结点的结点将越早地遍历。</strong></p><p>如果在第 <strong>k</strong> 轮中将结点 <strong>X</strong> 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 <strong>k</strong>。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p><h4 id="2-队列的入队和出队顺序是什么？"><a href="#2-队列的入队和出队顺序是什么？" class="headerlink" title="2. 队列的入队和出队顺序是什么？"></a>2. 队列的入队和出队顺序是什么？</h4><p>如上面的动画所示，我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点 <strong>不会</strong> 立即遍历，而是在下一轮中处理。</p><p>结点的处理顺序与它们 <strong>添加</strong> 到队列的顺序是 <strong>完全相同的顺序</strong>，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p><p><strong>伪代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>如代码所示，在每一轮中，队列中的结点是 <strong>等待处理的结点。</strong></li><li>在每个更外一层的 <strong>while</strong> 循环之后，我们 <strong>距离根结点更远一步</strong>。变量 <strong>step</strong> 指示从根结点到我们正在访问的当前结点的距离。</li></ol><p>有两种情况不需要使用哈希集：</p><ol><li>代码中没有循环，例如，在树遍历中；</li><li>希望多次将结点添加到队列中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先进先出&quot;&gt;&lt;a href=&quot;#先进先出&quot; class=&quot;headerlink&quot; title=&quot;先进先出&quot;&gt;&lt;/a&gt;先进先出&lt;/h2&gt;&lt;p&gt;队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在 &lt;strong&gt;队列的末尾&lt;/strong&gt;。 删除（delete）操作也被称为出队（dequeue)。 你只能移除 &lt;strong&gt;第一个元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="队列" scheme="https://hongbosherlock.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://hongbosherlock.github.io/2020/03/23/stack/"/>
    <id>https://hongbosherlock.github.io/2020/03/23/stack/</id>
    <published>2020-03-23T02:41:10.000Z</published>
    <updated>2021-01-23T02:43:03.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先进后出"><a href="#先进后出" class="headerlink" title="先进后出"></a>先进后出</h2><p>栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 <strong>push</strong> 。与队列类似，总是在堆栈的 <strong>末尾添加一个新元素</strong>。但是，删除操作，退栈 <strong>pop</strong> ，将始终删除队列中相对于它的最后一个元素。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png" alt="image"><br><a id="more"></a></p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p><strong>动态数组</strong> 实现栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;               <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** Insert an element into the stack. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Get the top item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.pop_back();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStack s;</span><br><span class="line">    s.push(<span class="number">1</span>);</span><br><span class="line">    s.push(<span class="number">2</span>);</span><br><span class="line">    s.push(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (s.pop() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="栈和深度优先搜索"><a href="#栈和深度优先搜索" class="headerlink" title="栈和深度优先搜索"></a>栈和深度优先搜索</h2><p>在我们到达<strong>最深的结点</strong>之后，我们<strong>只会回溯</strong>并尝试另一条路径。</p><p>当到达终点时，并不一定是最短路径。</p><p>我们首先将根结点推入到栈中；当我们回溯时，我们将从栈中 <strong>弹出最深的结点</strong>，这实际上是推入到栈中的最后一个结点。</p><h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的 <strong>隐式栈</strong>，也称为调用栈（Call Stack）。</p><p>每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。<strong>在计算空间复杂度时，永远不要忘记考虑系统栈</strong>。 </p><h3 id="2-栈实现"><a href="#2-栈实现" class="headerlink" title="2. 栈实现"></a>2. 栈实现</h3><p>如果递归的深度太高，会产生堆栈溢出。 在这种情况下，可以使用 BFS，或使用显式栈实现 DFS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; s;</span><br><span class="line">    add root to s;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to s;</span><br><span class="line">                add next to visited;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove cur from s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该逻辑与递归解决方案完全相同。 但我们使用 <strong>while</strong> 循环和 <strong>栈</strong> 来模拟递归期间的 <strong>系统调用栈</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先进后出&quot;&gt;&lt;a href=&quot;#先进后出&quot; class=&quot;headerlink&quot; title=&quot;先进后出&quot;&gt;&lt;/a&gt;先进后出&lt;/h2&gt;&lt;p&gt;栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 &lt;strong&gt;push&lt;/strong&gt; 。与队列类似，总是在堆栈的 &lt;strong&gt;末尾添加一个新元素&lt;/strong&gt;。但是，删除操作，退栈 &lt;strong&gt;pop&lt;/strong&gt; ，将始终删除队列中相对于它的最后一个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="https://hongbosherlock.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>成长的烦恼 —— 2019 总结</title>
    <link href="https://hongbosherlock.github.io/2019/12/31/2019-sum/"/>
    <id>https://hongbosherlock.github.io/2019/12/31/2019-sum/</id>
    <published>2019-12-31T14:37:46.000Z</published>
    <updated>2021-02-10T04:56:45.664Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2019年的最后一天了，事实上明天和今天不会有太大差别，重要的是在这样一个具有仪式感的日子，总结过去，展望未来。</p><p>本来不想写总结的，因为我觉得自己要说的太多了，而且有些心里话也不适合公开写出来。但还是有必要把今年的一些经历和感想记录下来，一方面是对我过去一年学习生活的总结，另一方面也是让关心我的朋友们了解一下我的近况。<a id="more"></a></p><p>今年的事情用两个词总结起来可能就是<strong>失恋</strong>和<strong>失学</strong>了，别人爱情事业两丰收，我则两手空空（苦笑）。</p><p>一月份和她由异地转为异国，本来已经遥远的距离变得更遥远了，还加上了时差。那几天两个人的状态都不太好，她忙于自己的课程，我则在感到保研北航无望后开始纠结工作还是读研。气氛比较僵，我也没有去积极缓和。分手那天是星期三，晚上”川西人文风光漫谈”下课后，嗯仿佛一切都历历在目。</p><p>那一刻，以前的约定和承诺都显得如此苍白无力，那些曾经盼望过的美好也都化为了泡影，我们还是输给了现实。我曾经感受过幸福和美好，最终也体会到了失去心爱之人的痛楚。有时候分不清回忆是美好还是痛苦了，我想，美好是客观的，痛苦是心境吧。</p><p><strong>失恋，是我今年遇到的第一个成长烦恼。</strong>有些事情并不是理所应当，有些人也不会一直都在。“世间好物不坚牢，彩云易逝琉璃碎”。最重要的还是珍惜当前吧。我一直觉得只有初恋的人之间才能演绎出爱情的本真，那些酸甜苦也还都记得。成熟的人之间的爱情也许很美好，但可能也只有美好了。我想，我的青春可能已经结束了。</p><p>之后我一直在努力调整自己，失恋对我的影响比我想象的要严重，很长一段时间我并没有释怀。爸妈听说后还想过五一放假来看我，后来我才明白原来父母才是最了解自己的。</p><p>后来我综合了一下优劣，还是决定读研。和好友DS一起投了北航和其他几个学校的夏令营，最后只过了一个，北航没有过。虽说今年竞争激烈，终究还是我太菜了。7月份提前结束了学院的实习，飞去深圳参加了中科院深研院的夏令营，顺便参观了腾讯、华为，算是涨了一些见识。</p><p>我对自己能否拿到学院的保研名额也不太确定，暑假便留校开始备考北航，便没有再关注夏令营和联系老师（于是错过了一些机会）。开学后有幸拿到了学院的保研名额，开始疯狂给北邮的老师发邮件，回复的都说招满了。。。同时关注中科院几个所的补录，也报名了北航的九推面试。最后北航的预审都没有过，深受打击。</p><p>十一假期先后接到了软件所和信工所的面试通知，要去北京。当时已经过了九推，可以说我的对手很少。但当时我对自己考研信心满满（太天真了），比来比去还是觉得北航好，也不太喜欢研究所的氛围（现在觉得这些想法好矫情，好SB）。最后我就拒了面试。后面几个月的复习过程中，累的时候我就会想到这件事，怀疑自己的选择是否正确。自己选择的路，还是跪着走完吧。</p><p>十月中旬在学院老师的开导下幡然醒悟，在这里也非常感谢学院对我的帮助和宽容。抓住了中科院一个老师的最后一根稻草，联系的实验室的学长都说我应该稳了，煎熬等待将近一周后，最后老师要了一个北大数学的，希望落空。也顺便感谢学长给我的帮助和鼓励，去了北京还会见面的。</p><p>这时我的心态早已被锻炼的比较好了，开始调整状态全力考研，觉得自己无论如何都要考上北航。每天考研复习的强度也只是比之前我期末复习的强度大了一些，所以也没觉得有多苦，也没想过放弃。考研不是我的目标或终点，只是达成目标的一个途径，也不觉得考研是多么感动一件事。但看着图书馆和自习室里晚归的人儿，我一直是对那些有理想、有目标，坚持奋斗的人心怀敬意的。</p><p>我也不会看不起放弃考研的人，因为生活本来就不容易，人的忍受度和特长也不同。该找工作就找工作，出路有很多。不过对于那些大四了还在混混僵僵过日子，对未来没有目标、没有计划的人，我是不屑的。今年我既看到了前三年表现平平，但最后靠自己努力拿到了不错的 offer 的同学，也感受到了温水煮青蛙的可怕。</p><p><strong>未来选择，是我今年遇到的第二个成长烦恼。</strong>在逆境和迷茫之中，我感到自己隐隐约约已经知道自己想要做什么，想到成为什么样的人。沉浸于UNIX时期的黑客文化，想去追求纯粹的技术。处在今天这样一个科技改变世界的时代，想去用自己的想法和代码让世界变得更好。</p><p>曹大说，一定要知道自己想要的是什么，一定要知道自己最好奇，最痴迷的是什么，缺乏足够的好奇心，是没有可能在某个领域进入顶尖位置的。关于个人定位，不同时期也是不同的，我现在也还不太清晰，还有很长的路要走。</p><p>今年是不太好过的一年，幸运的是我都扛过来了。最最感激的是爸妈一直对我无条件的支持，无论是在物质上还是精神上。让我永远有勇气面对未来的一切挑战。当然也感谢老弟的支持，家人永远是我不离不弃的依靠，同时也希望自己不断成长，爱自己，爱家人，成为我爱的人的依靠。</p><p>有人说 2019 可能是未来10年中最好的一年了。只要我们心怀希望，一切都会好起来的。</p><p>万物之中，希望至美。至美之物，永不凋零</p><p><strong>感谢大家这半年多的关注！</strong>我们 2020 再见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2019年的最后一天了，事实上明天和今天不会有太大差别，重要的是在这样一个具有仪式感的日子，总结过去，展望未来。&lt;/p&gt;
&lt;p&gt;本来不想写总结的，因为我觉得自己要说的太多了，而且有些心里话也不适合公开写出来。但还是有必要把今年的一些经历和感想记录下来，一方面是对我过去一年学习生活的总结，另一方面也是让关心我的朋友们了解一下我的近况。
    
    </summary>
    
      <category term="生活" scheme="https://hongbosherlock.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="https://hongbosherlock.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>初识递归</title>
    <link href="https://hongbosherlock.github.io/2019/12/20/recursion/"/>
    <id>https://hongbosherlock.github.io/2019/12/20/recursion/</id>
    <published>2019-12-20T10:43:08.000Z</published>
    <updated>2021-01-18T10:31:08.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>一个函数调用本身就是递归。<br>递归和普通函数调用一样，是通过栈实现的。</p><h3 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h3><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h3 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h3><ul><li>代替多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解为规模更小的子问题进行求解</li></ul><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。</p></blockquote><p>不要试图想清楚整个递和归的过程，这样容易被绕进去。</p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。</strong></p><a id="more"></a><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="递归代码要警惕栈溢出"><a href="#递归代码要警惕栈溢出" class="headerlink" title="递归代码要警惕栈溢出"></a>递归代码要警惕栈溢出</h4><p>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有栈溢出的风险。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p>重复计算就是 f(k) 被计算多次，影响效率。<br>可以用数据结构（比如散列表），来保存已经求解过的 f(k)。</p><p>在计算斐波那契函数 F(n) 的过程中， 我们可以使用 <strong>哈希表</strong> 来跟踪每个以 n 为键的 F(n) 的结果。 <strong>散列表</strong> 作为一个缓存，可以避免重复计算。 <strong>记忆化技术</strong> 是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。</p><h4 id="函数可能会有多个位置进行自我调用"><a href="#函数可能会有多个位置进行自我调用" class="headerlink" title="函数可能会有多个位置进行自我调用"></a>函数可能会有多个位置进行自我调用</h4><h3 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h3><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 递归中函数调用较多，执行所需时间也比较多。<br>给出一个递归算法，其时间复杂度 O ( T ) 通常是 <strong>递归调用的数量</strong> (记作 R) 和单次计算的时间复杂度 (表示为 O ( S ) )的乘积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(T)=R∗O(s)</span><br></pre></td></tr></table></figure></p><p>一般情况下单次计算的时间复杂度为 O ( 1 )</p><p><strong>执行树</strong></p><blockquote><p><strong>执行树</strong> 是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p></blockquote><p>归函数的执行树将形成 n 叉树，其中 n 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 f(4) 的执行树。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/01/fibonacci.png" alt="image"></p><p>在 n 层的完全二叉树中，节点的总数为 2^n -1 。因此 f(n) 中递归数目的上限（尽管不严格）也是 2^n -1。那么我们可以估计 f(n) 的时间复杂度为 O(2^n)。</p><p>通过使用 <strong>记忆化技术</strong> 计算 f(n) 的递归将被调用 n-1 次以计算它所依赖的所有先验数字。</p><p>此时时间复杂度为: O ( 1 ) * n = O ( n )。记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><blockquote><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：<strong>递归相关空间</strong>（recursion related space）和 <strong>非递归相关空间</strong>（non-recursion related space）。</p></blockquote><h5 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h5><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。<br>因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要首先考虑这部分的开销。<br><img src="https://assets.leetcode.com/uploads/2019/01/25/card_recursion_stack.png" alt="image"></p><p>如果递归规模较大，可以自己模拟一个栈，用非递归的方法实现。因为递归借助的是我们看不到的系统栈，调用过多时系统栈会溢出。</p><h5 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h5><p>通常包括为全局变量分配的空间（通常在堆中）。<br>还可能包括使用 <strong>记忆化技术</strong> 时，保存递归调用的中间结果分配的空间。</p><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>一般递归调用会在系统调用栈上产生的隐式额外空间。有一种然而，你应该学习识别一种称为尾递归的特殊递归情况，它不受此空间开销的影响。</p><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p></blockquote><p>下面的<strong>打印字符串</strong>就是尾递归的一种情况，即递归调用之后就没有额外的计算语句了。</p><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。<br><img src="https://assets.leetcode.com/uploads/2019/01/26/card_recursion_tail.png" alt="image"></p><p>请注意，在尾递归的情况下，一旦从递归调用返回，我们也会立即返回，因此我们可以跳过整个递归调用返回链，直接返回到原始调用方。这意味着我们根本不需要所有递归调用的调用栈，这为我们节省了空间。</p><p>例如，在步骤（1）中，栈中的一个空间将被分配给 f(x1)，以便调用 f(x2)。然后，在步骤（2）中，函数 f(x2) 能够递归地调用 f(x3)，但是，系统不需要在栈上分配新的空间，而是可以简单地重用先前分配给第二次递归调用的空间。最后，在函数 f(x3) 中，我们达到了基本情况，<strong>该函数可以简单地将结果返回给原始调用方，而不会返回到之前的函数调用中。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、当我们面对一个问题，不清楚是否可以使用递归时，我们可以尝试写下递推关系式，利用数学公式来推导某些关系。</p><p>2、尽可能使用记忆化技术，减少重复计算</p><p>3、担心可能因为递归次数太多，而导致堆栈溢出时，可以使用尾递归。</p><h3 id="一些帮助理解的题目"><a href="#一些帮助理解的题目" class="headerlink" title="一些帮助理解的题目"></a>一些帮助理解的题目</h3><p><strong>一、以相反的顺序打印字符串</strong><br>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><p>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><ul><li>printReverse(str[1…n-1])：以相反的顺序打印子字符串 str[1…n-1] 。</li><li>print(str[0])：打印字符串中的第一个字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//函数首次传入的是 str 的首地址，也就是 &amp;str[0]</span></span><br><span class="line">  <span class="keyword">if</span> (!*str)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//在 str[n-1] = '\0' 时终止</span></span><br><span class="line">  printReverse(str + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>汉诺塔可以看做递归问题<br>N 皇后问题其实是回溯问题</p><p><strong>N皇后问题</strong><br>每行只能放置一个皇后、每列也只能放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出结果里的每一行都代表一种摆法。</span></span><br><span class="line"><span class="comment"> 行里的第i个数字如果是n，就代表第i行的数字应该放在第n列。</span></span><br><span class="line"><span class="comment"> 皇后的行、列编号都是从 1开始算。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> queenPos[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//用来存放算好的皇后位置。最左上角是 (0,0) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//在 0~k-1行已经摆好的情况下，摆第k行及其后面的元素</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==N)&#123;</span><br><span class="line"><span class="comment">//N个皇后已经摆好</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;queenPos[i]+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="comment">//逐尝试第k个皇后的位置</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++) &#123;</span><br><span class="line"><span class="comment">//和已经摆好的 k 个皇后的位置比较，看是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(queenPos[j] == i|| <span class="built_in">abs</span>(queenPos[j]-i)==<span class="built_in">abs</span>(k-j))</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="comment">//第一个条件表示第 i 列已经有皇后了</span></span><br><span class="line"><span class="comment">//第二个条件表示两个皇后是否在同一条对角斜线上 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j==k)&#123;</span><br><span class="line"><span class="comment">//当前选的位置 i 不冲突</span></span><br><span class="line">queenPos[k] = i;</span><br><span class="line"><span class="comment">//queenPos[k] 在第一次赋值后，回溯时值是可能会改变的。</span></span><br><span class="line">NQueen(k+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个for循环中的递归，称作回溯。</span></span><br><span class="line">&#125;<span class="comment">//for循环终止</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">NQueen(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">//从第0行开始摆皇后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全排列</strong></p><p>求 1~n 的全排列。可以分为若干个子问题：以 1 开头的全排列；以 2 开头的全排列；以 3 开头的全排列…</p><ul><li>数组 P 用来存放当前排列</li><li>散列数组 hashTable[x] 当整数 x 已经在数组 P 中时为 true。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// P为当前排列，hashTable 记录整数 x 是否已经在 P 中 </span></span><br><span class="line"><span class="keyword">int</span> n,P[maxn],hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 当前处理排列的第 index 位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123; <span class="comment">//递归边界,已经处理完排列的 n+1 位 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123; <span class="comment">//枚举 1~n，试图将 j 填入P[index]</span></span><br><span class="line"><span class="keyword">if</span>(hashTable[j]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 x 不在 P[0]~P[index-1]中 </span></span><br><span class="line">P[index]=j;           <span class="comment">// 把 x 加入当前排列 </span></span><br><span class="line">hashTable[j]=<span class="literal">true</span>;    <span class="comment">// 记 x 已在 P 中</span></span><br><span class="line">generate(index+<span class="number">1</span>);   <span class="comment">// 处理排列的第 index+1 位</span></span><br><span class="line">hashTable[j] = <span class="literal">false</span>; <span class="comment">// 已处理完 P[index] 为 j 的子问题，还原状态 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="number">3</span>;   </span><br><span class="line">generate(<span class="number">1</span>);  <span class="comment">// 从 P [1] 开始填</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回溯法实现 N 皇后</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;  <span class="comment">//递归边界 </span></span><br><span class="line">count++; <span class="comment">//能达到这里的一定是合法的</span></span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;  <span class="comment">//第 x 行 </span></span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123; <span class="comment">//第 x 行还没有皇后 </span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123; <span class="comment">//遍历之前的皇后 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre) == <span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123; <span class="comment">//可以把皇后放在第 n 行 </span></span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generate(index+<span class="number">1</span>); <span class="comment">//递归处理第 index+1 行皇后</span></span><br><span class="line">hashTable[x]=<span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h3&gt;&lt;p&gt;一个函数调用本身就是递归。&lt;br&gt;递归和普通函数调用一样，是通过栈实现的。&lt;/p&gt;
&lt;h3 id=&quot;递归的条件&quot;&gt;&lt;a href=&quot;#递归的条件&quot; class=&quot;headerlink&quot; title=&quot;递归的条件&quot;&gt;&lt;/a&gt;递归的条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个问题的解可以分解为几个子问题的解&lt;/li&gt;
&lt;li&gt;这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/li&gt;
&lt;li&gt;存在递归终止条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;递归的作用&quot;&gt;&lt;a href=&quot;#递归的作用&quot; class=&quot;headerlink&quot; title=&quot;递归的作用&quot;&gt;&lt;/a&gt;递归的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代替多重循环&lt;/li&gt;
&lt;li&gt;解决本来就是用递归形式定义的问题&lt;/li&gt;
&lt;li&gt;将问题分解为规模更小的子问题进行求解&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要试图想清楚整个递和归的过程，这样容易被绕进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://hongbosherlock.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>vector 用法总结</title>
    <link href="https://hongbosherlock.github.io/2019/09/04/vector/"/>
    <id>https://hongbosherlock.github.io/2019/09/04/vector/</id>
    <published>2019-09-04T02:36:34.000Z</published>
    <updated>2021-01-18T10:33:04.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vector-介绍"><a href="#vector-介绍" class="headerlink" title="vector 介绍"></a>vector 介绍</h4><p>vector 是表示可以改变大小的数组的序列容器。</p><p>vector 能够容纳许多其他类型相同的元素,因此又被称为<strong>容器</strong>。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够<strong>存放任意类型的动态数组</strong>，能够增加和压缩数据。</p><p>与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。</p><p><strong>容器特性</strong></p><p>1.顺序序列</p><blockquote><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p></blockquote><p>2.动态数组</p><blockquote><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p></blockquote><p>3.能够感知内存分配器的（Allocator-aware）</p><blockquote><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p></blockquote><a id="more"></a><h4 id="声明及初始化"><a href="#声明及初始化" class="headerlink" title="声明及初始化"></a>声明及初始化</h4><p><strong>头文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>vector 是一个模板类，所以需要用 vector<typename> arry 这样的方式来声明一个 vector。<br>vector 型变量的声明以及初始化的形式也有许多, 常用的有以下几种形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;             <span class="comment">//声明一个 int 型向量 a</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);         <span class="comment">//声明一个初始大小为 10 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>, <span class="number">1</span>);      <span class="comment">//声明一个初始大小为 10 且初始值都为 1 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a);          <span class="comment">//声明并用向量 a 初始化向量 b </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+<span class="number">3</span>); <span class="comment">//将a向量中从第0个到第2个(共3个)作为向量b的初始值</span></span><br></pre></td></tr></table></figure></typename></p><p>除此之外, 还可以直接使用数组来初始化向量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n, n+<span class="number">5</span>) ;      <span class="comment">//将数组 n 的前 5 个元素作为向量 a 的初值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n+<span class="number">1</span>, n+<span class="number">4</span>) ;    <span class="comment">//将 n[1]-n[4] 范围内的元素作为向量 a 的初值</span></span><br></pre></td></tr></table></figure></p><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const T&amp; x);   //向量尾部增加一个元素X</span><br><span class="line">void pop_back();   //删除向量中最后一个元素</span><br><span class="line"></span><br><span class="line">插入 - insert</span><br><span class="line">iterator insert(iterator it,const T&amp; x);     //向量中迭代器指向元素前增加一个元素x</span><br><span class="line">// vec.insert(vec.begin()+i,a);     在第i+1个元素前面插入a;</span><br><span class="line">vec.insert(a.begin(), 1000);            //将1000插入到向量a的起始位置前</span><br><span class="line">vec.insert(a.begin(), 3, 1000) ;        //将1000分别插入到向量元素位置的0-2处(共3个元素)</span><br><span class="line">b.insert(b.begin(), a.begin(), a.end()) ;   //将a.begin(), a.end()之间的全部元素插入到b.begin()前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除 - erase</span><br><span class="line">iterator erase(iterator it);  //删除向量中迭代器指向元素</span><br><span class="line">// vec.erase(vec.begin()+2);  删除第3个元素</span><br><span class="line">b.erase(b.begin()) ;                     //将起始位置的元素删除</span><br><span class="line">b.erase(b.begin(), b.begin()+3) ;        //将(b.begin(),b.begin()+3)之间的元素删除</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">iterator begin();    //返回向量头指针，指向第一个元素</span><br><span class="line">iterator end();      //返回向量尾指针，指向向量最后一个元素的下一个位置</span><br><span class="line"></span><br><span class="line">int size() const;    //返回向量中元素的个数</span><br><span class="line">void clear();        //清空向量中所有元素</span><br><span class="line">bool empty() const;  //判断向量是否为空，若为空，则向量中无元素</span><br></pre></td></tr></table></figure><p><strong>迭代</strong><br>使用迭代器将容器中数据输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it; </span><br><span class="line">auto it  //上面的简写</span><br><span class="line">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span><br><span class="line">for(it=v.begin(); it!=v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>v.end()</strong> 指向容器器的最后一个元素的后⼀个位置。</p><p><strong>排序</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(),vec.end());    <span class="comment">//默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想 sort 来降序，可重写 sort </span></span><br><span class="line">sort(a,a+n,compare);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a&lt; b;</span><br><span class="line">    <span class="comment">//升序排列，如果改为 return a &gt; b，则为降序 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">reverse(obj.begin(),obj.end()); <span class="comment">//从大到小</span></span><br></pre></td></tr></table></figure></p><p><strong>二维数组</strong></p><ul><li>声明了一个动态二维数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br></pre></td></tr></table></figure><ul><li>先定义好二维数组结构，再直接赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//得到一个 5 行 3 列的数组</span></span><br><span class="line"><span class="comment">//由 vector 实现的二维数组，可以通过 resize() 的形式改变行、列值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">    <span class="built_in">array</span>[i].resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>固定一维的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br></pre></td></tr></table></figure><p>上式类似声明了一个二维数组，第一维的大小是固定的（不超过maxn），但第二维的大小不固定。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用 vector 需要注意以下几点：</p><ul><li>如果要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低。</li><li>vector 作为函数的参数或者返回值时，需要注意它的写法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"> <span class="comment">// “&amp;”绝不可少。</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://blog.csdn.net/duan19920101/article/details/50617190" target="_blank" rel="noopener">C++ 中vector的使用方法</a></li><li><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" rel="noopener">学习C++ -&gt; 向量(vector)</a></li><li><a href="https://blog.csdn.net/w_linux/article/details/71600574" target="_blank" rel="noopener">C++（笔记）浅析vector容器的实例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vector-介绍&quot;&gt;&lt;a href=&quot;#vector-介绍&quot; class=&quot;headerlink&quot; title=&quot;vector 介绍&quot;&gt;&lt;/a&gt;vector 介绍&lt;/h4&gt;&lt;p&gt;vector 是表示可以改变大小的数组的序列容器。&lt;/p&gt;
&lt;p&gt;vector 能够容纳许多其他类型相同的元素,因此又被称为&lt;strong&gt;容器&lt;/strong&gt;。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够&lt;strong&gt;存放任意类型的动态数组&lt;/strong&gt;，能够增加和压缩数据。&lt;/p&gt;
&lt;p&gt;与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.顺序序列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.动态数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.能够感知内存分配器的（Allocator-aware）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容器使用一个内存分配器对象来动态地处理它的存储需求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="vector" scheme="https://hongbosherlock.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>malloc 和 memset 总结</title>
    <link href="https://hongbosherlock.github.io/2019/06/08/malloc/"/>
    <id>https://hongbosherlock.github.io/2019/06/08/malloc/</id>
    <published>2019-06-08T12:57:28.000Z</published>
    <updated>2021-01-18T10:30:19.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc()函数"></a>malloc()函数</h3><h4 id="1、函数原型及说明："><a href="#1、函数原型及说明：" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：#include <stdlib.h></stdlib.h></p><p>malloc() 函数用来动态地分配内存空间其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明:</strong></p><ul><li>size 为需要分配的内存空间的大小，以字节（Byte）计。</li><li>size -t 是无符号整数类型。</li></ul><p><strong>函数说明:</strong><br>malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。<br>这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。<br>如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。</p><a id="more"></a><p><strong>返回值:</strong><br>分配成功返回指向该内存的地址，失败则返回NULL。<br>关于分配失败的原因，应该有多种，比如说空间不足就是一种。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void free(void *FirstByte)：</span><br></pre></td></tr></table></figure><p>该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。</p><h4 id="2、函数的用法："><a href="#2、函数的用法：" class="headerlink" title="2、函数的用法："></a>2、函数的用法：</h4><p>向malloc申请的空间的⼤大⼩小是以字节为单位的。</p><ul><li>返回的结果是void*，需要类型转换为自己需要的类型 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* num;</span><br><span class="line">num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><p>程序示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc example: random string generator*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      /* printf, scanf, NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     /* malloc, free, rand */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,n;</span><br><span class="line">  <span class="keyword">char</span> * buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"How long do you want the string? "</span>);</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">  buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span> (i+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer==<span class="literal">NULL</span>) <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;i; n++)</span><br><span class="line">    buffer[n]=rand()%<span class="number">26</span>+<span class="string">'a'</span>;</span><br><span class="line">  buffer[i]=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"Random string: %s\n"</span>,buffer);</span><br><span class="line">  <span class="built_in">free</span> (buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序生成一个由用户指定的长度的字符串，由字母字符组成。此字符串的可能长度仅受malloc可用内存量的限制。</p><h4 id="3、注意事项："><a href="#3、注意事项：" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>malloc的返回值是一个指针，指向一段可用内存的起始地址。</li><li>申请了内存空间后，必须检查是否分配成功。</li><li>当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。</li><li>malloc() 和 free() 这两个函数应该配对。如果申请后不释放会出现内存泄露</li><li>虽然malloc()函数的类型是(void<em>),任何类型的指针都可以转换成(void </em>),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。</li></ul><h3 id="memset-函数"><a href="#memset-函数" class="headerlink" title="memset()函数"></a>memset()函数</h3><h4 id="1、函数原型及说明：-1"><a href="#1、函数原型及说明：-1" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：#include <string.h></string.h></p><p>memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span><span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明：</strong></p><ul><li>ptr 为要操作的内存的指针。</li><li>value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。（最终解释为 unsigned char)</li><li>num 为 ptr 的前 num 个字节。</li><li>size_t 就是unsigned int。</li></ul><p><strong>函数说明:</strong>  memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。</p><p><strong>返回值:</strong>   返回指向 ptr 的指针。</p><h4 id="2、函数用法："><a href="#2、函数用法：" class="headerlink" title="2、函数用法："></a>2、函数用法：</h4><p>memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(str)<span class="number">-1</span>); <span class="comment">// 0或者'\0'是等价的</span></span><br></pre></td></tr></table></figure></p><p>对整型数组初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* num;</span><br><span class="line">num = (int*)malloc( n*sizeof(int) );</span><br><span class="line">memset(num,0,n*sizeof(int) );</span><br></pre></td></tr></table></figure></p><h4 id="3、注意事项：-1"><a href="#3、注意事项：-1" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>memset() 中的第三个参数一定要使用 sizeof 操作符，因为每个系统下对类型长度的定义可能不一样。</li><li>memset() 中的第一个参数一定要是一个已知的、已经被分配内存的地址，否则会出错。</li></ul><ul><li><strong>最重要的一点：</strong> 对于单字节数据类型（char）可以初始化为任意支持的值，多字节数据类型只能初始化为 0。</li></ul><p><strong>原因：</strong></p><p>memset是按照字节对待初始化空间进行初始化的，也就是说，函数里面的第二个参数的那个初值（一般为0）是按照一个个字节往第一个参数所指区域赋值的，所以，对于单字节数据类型（char）可以初始化为任意支持的值，都没有问题。</p><p>但是对于多字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。如果将 int 类型数组初始化为1，那么因为int一般是4个字节，那么相当于将一个int元素初始化成了 <strong>0000 0001 0000 0001 0000 0001 0000 0001</strong>，<br>这样对于一个int元素肯定不是1，而是一个很大的数，结果出乎意料。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" target="_blank" rel="noopener">malloc和free函数详解</a></li><li><a href="https://blog.csdn.net/dan15188387481/article/details/49621447" target="_blank" rel="noopener">透彻分析C/C++中memset函数</a></li><li><a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc -C++ Reference</a></li><li><a href="http://www.cplusplus.com/reference/cstring/memset/" target="_blank" rel="noopener">memset -C++ Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;malloc-函数&quot;&gt;&lt;a href=&quot;#malloc-函数&quot; class=&quot;headerlink&quot; title=&quot;malloc()函数&quot;&gt;&lt;/a&gt;malloc()函数&lt;/h3&gt;&lt;h4 id=&quot;1、函数原型及说明：&quot;&gt;&lt;a href=&quot;#1、函数原型及说明：&quot; class=&quot;headerlink&quot; title=&quot;1、函数原型及说明：&quot;&gt;&lt;/a&gt;1、函数原型及说明：&lt;/h4&gt;&lt;p&gt;头文件：#include &lt;stdlib.h&gt;&lt;/stdlib.h&gt;&lt;/p&gt;
&lt;p&gt;malloc() 函数用来动态地分配内存空间其原型为：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;malloc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size 为需要分配的内存空间的大小，以字节（Byte）计。&lt;/li&gt;
&lt;li&gt;size -t 是无符号整数类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数说明:&lt;/strong&gt;&lt;br&gt;malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。&lt;br&gt;这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。&lt;br&gt;如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="malloc" scheme="https://hongbosherlock.github.io/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>STL 简介</title>
    <link href="https://hongbosherlock.github.io/2019/05/26/stl/"/>
    <id>https://hongbosherlock.github.io/2019/05/26/stl/</id>
    <published>2019-05-26T11:40:15.000Z</published>
    <updated>2021-01-18T10:31:59.529Z</updated>
    
    <content type="html"><![CDATA[<p>STL (Standard Template Library) 标准模板库</p><p>需要引入头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="排序算法sort"><a href="#排序算法sort" class="headerlink" title="排序算法sort"></a>排序算法sort</h3><h4 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h4><p>对基本类型的数组从小到大排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2);</span><br></pre></td></tr></table></figure></p><p>n1 和 n2 都是 int 类型的表达式，可以包含变量。<br>将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。</p><a id="more"></a><h4 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h4><p>对元素类型为 T的基本类型数组从大到小排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, greater&lt;T&gt;());</span><br></pre></td></tr></table></figure></p><h4 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h4><p>用自定义的排序规则，对任何类型 T 的数组排序，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>排序规则结构的定义方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  T &amp;a1, <span class="keyword">const</span> T &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若 a1 应该在 a2 前面，则返回 true。</span></span><br><span class="line">        <span class="comment">//否则返回 false。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>排序规则返回 true ，意味着 a1 必须在 a2 前面。<br>返回 false ，意味着 a1 并非必须在 a2 前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//从大到小排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1 &gt; a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按个位数从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a1%<span class="number">10</span> &lt; a2%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对结构体数组进行排列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按姓名从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stricmp(s1.name&lt;s2.name)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按 id 从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><p>STL 提供在排好序的数组上进行二分查找的算法。</p><h4 id="用法一-1"><a href="#用法一-1" class="headerlink" title="用法一"></a>用法一</h4><p>在从小到大排好序的基本类型数组上进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值);</span><br></pre></td></tr></table></figure></p><p>查找区间为下标范围为 [n1,n2) 的元素，下标为 n2 的元素不在排列区间内。</p><p>在该区间内查找 “等于值”的元素，返回为true(找到）或 false（没找到）。</p><h4 id="用法二-1"><a href="#用法二-1" class="headerlink" title="用法二"></a>用法二</h4><p>在用自定义排序规则排好序的、元素为任意的 T 类型的数组中进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>查找时的排序规则，必须和<strong>排序时</strong>(sort函数)的规则一致。</p><p>二分查找实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在包含 size 个元素的 、从小到大排序的 int 数组 a里查找元素 p, 如果找到，则返回元素下标，如果找不到，则返回-1。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>; <span class="comment">//左端点 </span></span><br><span class="line"><span class="keyword">int</span> R=size<span class="number">-1</span>; <span class="comment">//右端点</span></span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=L+(R-L)/<span class="number">2</span>; <span class="comment">//防止 L+R 过大溢出</span></span><br><span class="line"><span class="keyword">if</span>(a[mid]==p)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p&gt;a[mid])</span><br><span class="line">L=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">R=mid<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p>求下面方程的 一个 根： $f(x) =x^3-5x^2+10x-80 = 0$<br>若求出的根是 a，则要求 $|f(a)| &lt;= 10^-6$</p><ul><li>解法：对 f(x) 求导，得 $f’(x)=3x^2-10x+10$ 。由一元二次方程 求根公式知f’(x)= 0 无解，因此 f’(x) 恒大于 0。故f(x) 是单调递增的 。易知 f(0) &lt; 0 且 f(100)&gt;0,,所以 区间 [0,100]内必然有且只一个根 。由于 f(x) 在[0,100]内是单调的，所以可用二分办法在区间  [0,100]中寻找根。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ESP = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x*x<span class="number">-5</span>*x*x+<span class="number">10</span>*x<span class="number">-80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> root,y;</span><br><span class="line"><span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;</span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fabs</span>(y)&gt;ESP)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">x2=root;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x1=root;</span><br><span class="line"></span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>,root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>寻找指定和的整数对<br>输入 n ( n&lt;= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯定有解 )。题中所有整数都能用int 表示。</p><ul><li>解法一<br>1)将数组排序，复杂度是O(n x log(n))<br>2)对数组中的每个元素a[i],在数组中二分查找m-a[i]，看能否找到。复杂度log(n)，最坏要查找n-2次，所以查找这部分的复杂度也是 O(n ×log(n))</li><li>解法二<br>1)将数组排序，复杂度是O(n x log(n))<br>2)查找的时候，设置两个变量 i 和 j，i 初值是 0，j 初值是 n-1。看 a[i]+a[j],如果大于 m，则j-1，如果小于m就让 i+1。直到 a[i]+a[j] = m。</li></ul><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><p><strong>Aggressive cows</strong><br>总时间限制: 1000ms   内存限制: 65536kB</p><p><strong>描述</strong><br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p><p><strong>输入</strong></p><ul><li>Line 1: Two space-separated integers: N and C</li><li>Lines 2..N+1: Line i+1 contains an integer stall location, xi</li></ul><p><strong>输出</strong></p><ul><li>Line 1: One integer: the largest minimum distance</li></ul><p><strong>样例输入</strong></p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>3</p></blockquote><p><strong>提示</strong><br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p><strong>思路</strong></p><ul><li>先得到排序后的隔间坐标 x1,…,xN</li><li>在 [L,R] 内用二分法尝试“最大最近距离”，D=(L+R)/2,(L,R初值为[1,1000000000/C])</li><li>若 D 可行，则记录该 D，然后在新的 [L,R] 中继续尝试。(L = D+1)。          若 D 不行，则在新 [L,R] 中继续尝试。( R = D-1)</li></ul><p>尝试方法：</p><ul><li>第一头牛放在x1</li><li>若第 k 头牛放在 xi，则找到x（i+1）到 xN 中第一个位于[xi+D,1000000000]中的xj，第 k+1 头牛放在 xj。找不到这样的 xj，则说明不可行。</li></ul><p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> N,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t,s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sort(a,a+N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R=MAX/C;</span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">D = L+(R-L)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]-a[pre]&gt;=D)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=i;</span><br><span class="line">             t++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t&gt;=C)&#123;</span><br><span class="line"></span><br><span class="line">s=D;</span><br><span class="line">L=D+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">R=D<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL (Standard Template Library) 标准模板库&lt;/p&gt;
&lt;p&gt;需要引入头文件：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序算法sort&quot;&gt;&lt;a href=&quot;#排序算法sort&quot; class=&quot;headerlink&quot; title=&quot;排序算法sort&quot;&gt;&lt;/a&gt;排序算法sort&lt;/h3&gt;&lt;h4 id=&quot;用法一&quot;&gt;&lt;a href=&quot;#用法一&quot; class=&quot;headerlink&quot; title=&quot;用法一&quot;&gt;&lt;/a&gt;用法一&lt;/h4&gt;&lt;p&gt;对基本类型的数组从小到大排序：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sort(数组名+n1, 数组名+n2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;n1 和 n2 都是 int 类型的表达式，可以包含变量。&lt;br&gt;将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="STL" scheme="https://hongbosherlock.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="https://hongbosherlock.github.io/2019/05/15/struct/"/>
    <id>https://hongbosherlock.github.io/2019/05/15/struct/</id>
    <published>2019-05-15T13:28:41.000Z</published>
    <updated>2021-01-17T15:04:40.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>声明结构的形式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span>       <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                   <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                  <span class="comment">//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>对于第⼀和第二种形式，都声明了结构point。但是第三种形式没有声明point，只是定义了两个变量。</p><p>一般来说，一个结构变量所占的内存空间的大小就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。</p><ul><li><p>访问变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br><span class="line">p1.y</span><br></pre></td></tr></table></figure></li><li><p>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• p1 = (struct point)&#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 相当于p1.x = 5;p1.y = 10;</span></span><br><span class="line">• p1 = p2;</span><br><span class="line"><span class="comment">// 相当于p1.x = p2.x; p1.y = p2.y;</span></span><br></pre></td></tr></table></figure></li><li><p>结构体指针</p></li></ul><p>和数组不同，结构变量的名字并不是结构变量的地址，必须使⽤用&amp;运算符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">p</span> = &amp;<span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure></p><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>（1）结构体作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(struct point p)</span></span></span><br></pre></td></tr></table></figure><p>• 整个结构可以作为参数的值传⼊入函数</p><p>• 这时候是在函数内新建⼀一个结构变量，并复制调⽤用者的结构的值</p><p>• 也可以返回⼀一个结构</p><p><strong>注意</strong>：传⼊入结构和传⼊数组是不同的：</p><ul><li>函数参数传入的是数组的引用。</li><li>传入结构时，传入的是结构体的拷贝。</li></ul><p>（2）结构指针作为参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct point *p = &amp;p1;</span><br><span class="line">(*p).x = 2;</span><br><span class="line">p-&gt;x = 2;</span><br></pre></td></tr></table></figure></p><p>⽤用<strong>-&gt;</strong>表⽰示指针所指的结构变量中的成员</p><p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct point* <span class="title">inputPoint</span><span class="params">(struct point* p)</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(p-&gt;x),&amp;(p-&gt;y));        </span><br><span class="line"><span class="comment">// 同 (*p).x 和 (*p).y</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(struct point p)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span>=&#123;</span><span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">inputPoint(&amp;y);</span><br><span class="line">output(y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• 好处是传⼊传出只是一个指针的大小。</p><p>• 如果需要保护传入的结构不被函数修改。</p><ul><li>const struct point *p</li></ul><p>• 返回传⼊的指针是一种套路。</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[100];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[]=&#123;</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明结构的形式：&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;p1&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;p2&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                   &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                  &lt;span class=&quot;comment&quot;&gt;//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="结构体" scheme="https://hongbosherlock.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>函数和字符串</title>
    <link href="https://hongbosherlock.github.io/2019/05/10/string/"/>
    <id>https://hongbosherlock.github.io/2019/05/10/string/</id>
    <published>2019-05-10T10:28:32.000Z</published>
    <updated>2021-01-17T15:05:09.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一维数组作为形参时的写法如下：</p><ul><li>类型名 数组名 []</li></ul><p>数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。</p><p>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。</p><p>二维数组作为函数形参时，必须写明函数有多少列</p><ul><li>类型名 数组名 [][N]   N为列数</li></ul><a id="more"></a><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>&#125;          <span class="comment">//字符数组</span></span><br><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'\0'</span>&#125;     <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure><p>0标志字符串的结束，是字符数组的一部分，但它不是字符串的⼀部分。</p><ul><li>计算字符串⻓长度的时候不包含这个0</li></ul><p>常见的字符串声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• <span class="keyword">char</span> *str = “Hello”;             <span class="comment">//字符串常量，不可修改</span></span><br><span class="line">• <span class="keyword">char</span> word[] = “Hello”;           <span class="comment">//可修改</span></span><br><span class="line">• <span class="keyword">char</span> line[<span class="number">10</span>] = “Hello”;         <span class="comment">//数组大小为6</span></span><br></pre></td></tr></table></figure></p><p>C语⾔言的字符串是以字符数组的形态存在的，″Hello″会被编译器变成⼀个字符数组放在某处，这个数组的长度是6，结尾还有表⽰示结束的0。</p><ul><li>如果要构造⼀一个字符串—&gt;数组</li><li>如果要处理⼀一个字符串—&gt;指针</li></ul><p><strong>声明一个空字符串</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str;          <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"\0"</span>;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">""</span>;    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p>str 是一个空字符串，str[0] == ‘\0’.</p><p>数组 str 的长度为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%<span class="number">7</span>s”, str);</span><br></pre></td></tr></table></figure></p><ul><li>在%和s之间的数字表⽰示最多允许读⼊入的字符的数量，这个数字应该⽐比数组的大小⼀</li><li>scanf 会自动添加结尾的’\0’</li><li><p>scanf 和 cin 读入到空格为止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型 ：gets(char buf[] )</span></span><br><span class="line"><span class="keyword">while</span>( gets(str) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure></li><li><p>读入一行，自动添加 ‘\0’.</p></li><li>回车换行符不会写入 buf，但是会从输入流中去掉。</li></ul><p><strong>字符串数组</strong></p><ul><li>char **a</li></ul><p> a是⼀一个指针，指向另⼀一个指针，那个指针指向⼀一个字符（串）</p><ul><li>char a[][]</li></ul><p>a是⼀一个⼆二维数组，第⼆二个维度的⼤大⼩小不知道，不能编译</p><ul><li>char a[][10]</li></ul><p>a是⼀一个⼆二维数组，a[x]是⼀一个char[10]</p><ul><li>char *a[]</li></ul><p>a是⼀一个⼀一维数组，a[x]是⼀一个char*</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>getchar()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getchar(void);</span><br></pre></td></tr></table></figure></p><ul><li>从标准输⼊入读⼊一个字符</li><li>返回类型是int是为了返回EOF（-1）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=EOF)&#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="库函数-string-h"><a href="#库函数-string-h" class="headerlink" title="库函数 string.h"></a>库函数 string.h</h4><p><strong>strcmp</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure></p><p>比较两个字符串，返回：</p><ul><li><strong>0 : s1==s2</strong></li><li><strong>&gt;0 : s1&gt;s2</strong></li><li><strong>&lt;0 : s1&lt;s2</strong></li></ul><p><strong>strcnmp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strncmp(const char *s1, const char *s2, int  n);</span><br></pre></td></tr></table></figure></p><p>比较 s1 前 n 个字符组成的子串和 s2 前 n 个字符组成的子串的大小。</p><ul><li>若长度不足 n，则取整个串作为子串。返回值和 strcmp 类似。</li></ul><p><strong>strcpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char *restrict dst, const char *restrict src);</span><br></pre></td></tr></table></figure></p><ul><li>把 src 的字符串拷⻉贝到 dst</li><li>restrict 表明 src 和 dst 不重叠（C99）</li></ul><p><strong>strncpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strncpy(char *restrict dst, const char *restrict src, int n);</span><br></pre></td></tr></table></figure></p><p>拷贝 src 的前 n 个字符到 dest。</p><ul><li>如果 src 长度大于或等于 n，该函数不会自动往 dest 中写入’\0’；若</li><li>若 src 长度不足 n，则拷贝 src 的全部内容以及结尾的’\0’到 dest。</li></ul><p><strong>strcat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcat(char *restrict s1, const char *restrict s2);</span><br></pre></td></tr></table></figure></p><ul><li>把s2拷⻉贝到s1的后⾯面，接成⼀一个⻓长的字符串</li><li>返回s1</li><li>s1必须具有⾜足够的空间</li></ul><h5 id="字符串中找字符："><a href="#字符串中找字符：" class="headerlink" title="字符串中找字符："></a>字符串中找字符：</h5><p><strong>strchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strchr(const char *str, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>第一次</strong>出现的位置。</p><ul><li>如果找到，就返回指向该位置的 char* 指针</li><li>若没找到，返回 NULL</li></ul><p><strong>strrchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strrchr(const char *s, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>最后一次</strong>出现的位置。</p><h5 id="字符串中找字符串："><a href="#字符串中找字符串：" class="headerlink" title="字符串中找字符串："></a>字符串中找字符串：</h5><p><strong>strstr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strstr(const char *s1, const char *s2);</span><br></pre></td></tr></table></figure></p><p>寻找子串 s2 在 s1 中第一次出现的位置。</p><ul><li>如果找到，就返回指向该位置的指针。</li><li>若没找到，返回 NULL<br><strong>源码</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len2;</span><br><span class="line">　　<span class="keyword">if</span> ( !(len2 = <span class="built_in">strlen</span>(s2)) )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;   <span class="comment">//字符串为空</span></span><br><span class="line">　　<span class="keyword">for</span> ( ; *s1; ++s1 )</span><br><span class="line">　&#123;</span><br><span class="line">　　<span class="keyword">if</span> ( *s1 == *s2 &amp;&amp; <span class="built_in">strncmp</span>( s1, s2, len2 )==<span class="number">0</span> )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;</span><br><span class="line">　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h5><p><strong>strtok</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strtok( char *str, const char *delim);</span><br></pre></td></tr></table></figure></p><p>连续调用该函数若干次，可以做到：从 str 中逐个抽取被字符串 delim 中的字符分隔开的若干字符串。</p><hr><h4 id="判断子串的函数"><a href="#判断子串的函数" class="headerlink" title="判断子串的函数"></a>判断子串的函数</h4><p> <strong>描述:</strong></p><p> 编写一个函数：</p><blockquote><p>int Strstr( char s1[], char s2[]);</p></blockquote><p>如果 s2 不是 s1 的子串，返回 -1,如果 s2 是 s1 的子串，返回在 s1 中第一次出现的位置。空串是任何串的子串，且出现位置为 0.</p><p> <strong>代码:</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;bits/stdc++.h&gt; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Strstr(const char* s1, const char* s2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(s2[0]==0)</span><br><span class="line">return 0;</span><br><span class="line">for(int i=0;s1[i];i++)&#123;</span><br><span class="line">int k=i;</span><br><span class="line">int j=0;</span><br><span class="line">for(;s2[j];j++,k++)&#123;</span><br><span class="line">if(s1[k]!=s2[j])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(s2[j]==0)</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">char s1[50];</span><br><span class="line">gets(s1);</span><br><span class="line"></span><br><span class="line">char s2[20];</span><br><span class="line">gets(s2);</span><br><span class="line"></span><br><span class="line">int f;</span><br><span class="line">f = Strstr(s1,s2);</span><br><span class="line">cout&lt;&lt;f;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;一维数组作为形参时的写法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 []&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。&lt;/p&gt;
&lt;p&gt;数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。&lt;/p&gt;
&lt;p&gt;二维数组作为函数形参时，必须写明函数有多少列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 [][N]   N为列数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="字符串" scheme="https://hongbosherlock.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="https://hongbosherlock.github.io/2019/05/05/pointer/"/>
    <id>https://hongbosherlock.github.io/2019/05/05/pointer/</id>
    <published>2019-05-05T04:27:07.000Z</published>
    <updated>2021-02-10T04:55:26.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 &amp; 不能对没有地址的东西取址。</p><p>2、指针是能够保存地址的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"><span class="keyword">int</span>* p,q;    <span class="comment">// p 是 int* 类型的指针，大小为8；q 是 int 整数，大小为4。</span></span><br><span class="line"><span class="keyword">int</span> *p,q;    <span class="comment">// p 是 int* 类型的指针，q 是 int 整数。       </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p,*q;   <span class="comment">// p 和 q 都是 int* 类型的指针。</span></span><br></pre></td></tr></table></figure></p><p>这说明指针也有内存地址，而且指针变量的值就是其他变量的内存地址。</p><a id="more"></a><p>3、* 是一个单目运算符, 用来访问指针的值所表示的地址上的变量。</p><ul><li><p>可以做右值也可以做左值</p><p> • int k = *p;</p><p> • *p = k+1;</p></li></ul><p>互相反作⽤：</p><ul><li><em>&amp;yptr -&gt; </em> (&amp;yptr) -&gt; * (yptr的地址)-&gt; 得到那个地址上的变量 -&gt; yptr</li><li>&amp;<em>yptr -&gt; &amp;(</em>yptr) -&gt; &amp;(y) -&gt; 得到y的地址，也就是yptr -&gt; yptr</li></ul><p>4、<strong>应用场景一：</strong><br>交换两个变量的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用指针之前要初始化。</p><p>5、 以下四种函数原型是等价的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>6、指针与const<br><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1g2pjx2gpzcj30px070jrq.jpg" alt="">（1）指针是const：<br> 一旦得到某个变量的地址，不能再指向其他变量。</p><p>（2）所指内容是const<br> 表⽰示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;i;    <span class="comment">//p1所指是const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;i;    <span class="comment">//p2所指是const， const在 * 的前面</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;i;    <span class="comment">//指针 p3 是const， const 在 * 的后面</span></span><br></pre></td></tr></table></figure><p>7、 const数组</p><ul><li>const int a[] = {1,2,3,4,5,6,};</li><li>数组变量已经是const的指针了，这⾥里的 const 表明数组的每个单元都是 const int</li><li>所以必须通过初始化进⾏行赋值</li></ul><p>8、保护数组</p><ul><li>把数组传⼊入函数时传递的是地址，则那个函数内部可以修改数组的值</li><li>为了保护数组不被函数破坏，可以设置参数为const</li><li>int sum(const int a[], int length);</li></ul><p>9、指针运算<br>(1) *p++</p><ul><li>取出p所指的那个数据来，完事之后顺便把 p 移到下⼀一个位置去</li><li>*的优先级虽然⾼高，但是没有 ++ ⾼高</li></ul><p>(2) 两个同类型的指针变量可以相加减:</p><ul><li>两个 T* 类型的指针 p1,p2 </li><li>p1 - p2 = (地址 p1 - 地址 p2)/sizeof(T)</li></ul><p>(3) 指针变量加减一个整数的结果是指针:<br> p : T* 类型的指针<br> n ：整数<br> p + n : 指向地址 ：地址 p + sizeof(T)</p><p>(4)可以用“ NULL”关键字对任何类型的指针进行赋值。NULL实际上就是整数 0, 值为 NULL的指针 就是空指针。</p><p>(5) 指针的用处</p><ul><li>需要传⼊入较⼤大的数据时⽤用作参数</li><li>传⼊入数组后对数组做操作</li><li><p>函数返回不⽌止⼀一个结果</p><p>• 需要⽤用函数来修改不⽌止⼀一个变量</p><p>(6)动态内存分配<br>C99可以⽤用变量做数组定义的⼤大⼩小，C99之前呢？</p></li><li>int <em>a = (int</em>)malloc(n*sizeof(int));</li></ul><p>如果申请失败则返回0，或者叫做NUL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free()</span><br></pre></td></tr></table></figure></p><ul><li>把申请得来的空间还给“系统”。</li><li>只能还申请来的空间的⾸首地址。</li></ul><p>memset()函数：将内存的前n个字节设置为特定的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将数组 a 置 0。</span><br><span class="line">memset(a,0,sizeof(a))</span><br></pre></td></tr></table></figure></p><p>10、指针与数组<br>数组的名字是一个指针常量，指向数字的起始地址。</p><h3 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h3><p>1、二维数组</p><p> T a[M][N];</p><ul><li>a[i] 是一个一维数组。</li><li>列数 N必须给出，行数 M可以不给，由编译器给出。</li><li><strong>a[i] 的类型是 T*</strong></li><li>a[i] 指向的地址：数组 a 的起始地址 + i × N × sizeof(T)</li></ul><p>2、指向指针的指针</p><ul><li>T <em>*p;<br>p是指向指针的指针， p指向的地方应该存放着一个类型为 T </em> 的指针。<br><em>p 的类型是 T </em><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **pp;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">1234</span>;</span><br><span class="line">p=&amp;n;</span><br><span class="line">pp=&amp;p;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(*pp));</span><br></pre></td></tr></table></figure></li></ul><p>3、指针和字符串<br>字符串常量的类型就是 char <em><br>字符数组名的类型也是 char </em> </p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>将函数的入口地址赋给一个指针变量，使该指针变量向函数。然后通过变量就可以调用这个函数。种指向的指针变量称为“ 函数指针 ”。<br>类型名 (* 指针变量名 )( 参数类型 1, 参数类型 2,…);<br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  (* pf )(<span class="keyword">int</span> ,<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure></p><p>表示 pf 是一个函数指针，它所向的返回值类型应是int，该函数应有两个参数，第一是 int  类型，第二个是 char 类型。</p><h5 id="函数指针和-qsort-函数"><a href="#函数指针和-qsort-函数" class="headerlink" title="函数指针和 qsort 函数"></a>函数指针和 qsort 函数</h5><p>c 语言快速排序库函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span> <span class="params">( <span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</span></span></span><br><span class="line">int (*pfCompare)(const void *, const void *));</span><br></pre></td></tr></table></figure></p><p>可以对任意类型的数组进行排序。</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1g2x6lgm2isj30wc0jognz.jpg" alt=""></p><p>pfCompare: 函数指针，它指向一个“比较函数”。该比较函数应为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 函数名 (const void *elem1, const void *elem2);</span><br></pre></td></tr></table></figure></p><p>比较函数是由我们自定义的。</p><p>比较函数编写规则：<br>1) 如果 <em> elem1 应该排在 </em> elem2  <strong>前面</strong> ，则函数返回值是<strong>负整数</strong>。<br>2) 如果 <em> elem1和</em> elem2 哪个排在前面都行，那么函数返回0<br>3) 如果 <em> elem1 应该排在 </em> elem2 <strong>后面</strong> ，则函数返回值是<strong>正整数</strong>。</p><p>下面的程序，功能是调用 qsort qsortqsort库函数，将一个 库函数，将一个 unsigned int unsigned int unsigned int 数组按 照个位数从小到大进行排序。比如 8，23 ，15 三个数，按位从小到 三个数，按位从小到 大排序，就应该是 23 ，15 ，8<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* elem1, <span class="keyword">const</span> <span class="keyword">void</span>* elem2)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *p1,*p2;</span><br><span class="line">p1 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*) elem1;</span><br><span class="line">p2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*) elem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (*p1%<span class="number">10</span>)-(*p2%<span class="number">10</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[num]=&#123;<span class="number">8</span>,<span class="number">123</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>&#125;;</span><br><span class="line">qsort(a,num,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),myCompare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;1、 &amp;amp; 不能对没有地址的东西取址。&lt;/p&gt;
&lt;p&gt;2、指针是能够保存地址的变量。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p = &amp;amp;i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p,q;    &lt;span class=&quot;comment&quot;&gt;// p 是 int* 类型的指针，大小为8；q 是 int 整数，大小为4。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p,q;    &lt;span class=&quot;comment&quot;&gt;// p 是 int* 类型的指针，q 是 int 整数。       &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p,*q;   &lt;span class=&quot;comment&quot;&gt;// p 和 q 都是 int* 类型的指针。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这说明指针也有内存地址，而且指针变量的值就是其他变量的内存地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="https://hongbosherlock.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>SCUNET使用IPv6的方法</title>
    <link href="https://hongbosherlock.github.io/2019/04/17/ipv6/"/>
    <id>https://hongbosherlock.github.io/2019/04/17/ipv6/</id>
    <published>2019-04-17T12:27:29.000Z</published>
    <updated>2021-02-10T05:08:17.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/ipv.jpg" alt=""></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前我一直是在 vps 上自搭梯子来科学上网（Do+ssr），虽说网速挺快，也能触达大部分网站。但还有一类网站无法访问，那就是 IPv6 网站。我曾经在 Ubuntu 下折腾了很久，都没有成功用上我的 ssr。最后看网上的教程，接入 IPv6 网络（开启 Teredo 隧道）<a id="more"></a>，修改了 hosts 文件，再配合<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">XX-Net</a>一起食用,又恢复了原来的 freedom。关于 Ubuntu 下如何科学上网，抽个时间单独写一篇吧。逃:）</p><p>相比 Ubuntu，win 就不那么友好了。我在校园网、寝室电信、家里的电信网络环境里，都能在 Ubuntu 下开启 IPv6 服务。但是 win 复杂的配置让我摸不着头脑（好吧，其实是我不懂），就一直没能在 win 上体验过 IPv6 的便捷。网上已经有人试过通过配置 vps 和服务器端的 ss(r) 来使用 IPv6 服务，方法有些麻烦，我就懒得折腾了。正好前几天权游第八季开播，这么火的剧我还没看过一集，而且质量也很好。强哥就给我推荐了<a href="https://bt.byr.cn/login.php" target="_blank" rel="noopener">北邮人</a>,这是个 IPv6 的 BT 网站，有很多高质量的影视资源。于是，我就开始了 win 下 IPv6 的探索之旅······</p><h3 id="啥是-IPv6？"><a href="#啥是-IPv6？" class="headerlink" title="啥是 IPv6？"></a>啥是 IPv6？</h3><p>别说 IPv6 ，很多人可能连 <a href="https://baike.baidu.com/item/IPv4" target="_blank" rel="noopener">IPv4</a> 都不太清楚。我之前也只是听过这两个名词，直到学了<strong>计算机网络</strong>，我才逐渐揭开了 IPv6 神秘的面纱。</p><p>IPv6 是下一代因特网协议。大部分因特网使用 IPv4，而且此协议在 20 多年来被证明是可靠的、富于弹性的。然而，IPv4 也存在局限性并且随着因特网的扩展会导致许多问题。IPv6 是 IPv4 的更新版本并且它将逐渐替代 IPv4 而作为网际标准。</p><p>IPv6 地址的大小和格式使得寻址功能大为增强。</p><p>IPv6 地址大小为 128 位。首选 IPv6 地址表示法为 x:x:x:x:x:x:x:x，其中每个 x 是地址的 8 个 16 位部分的十六进制值。IPv6 地址范围从 0000:0000:0000:0000:0000:0000:0000:0000 至 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff。</p><h3 id="如何开启IPv6"><a href="#如何开启IPv6" class="headerlink" title="如何开启IPv6"></a>如何开启IPv6</h3><p> <strong>ISP 商直接提供 IPv6 支持</strong></p><blockquote><p>部分地区的运营商已开通 IPv6原生支持。比如电信运营商已经在骨干网实现了IPv6支持。</p><p>高校教育网一般已开通原生 IPv6。</p></blockquote><p><strong>通过各种隧道获取 IPv6 支持</strong></p><blockquote><p>公网ip用户：6to4 隧道</p><p>内网ip用户：<a href="https://github.com/XX-net/XX-Net/wiki/teredo" target="_blank" rel="noopener">teredo 隧道</a></p><p>未开通原生 IPv6 的教育网用户：教育网 ISATAP 隧道</p></blockquote><p>教育网用户可以通过双栈及 ISATAP 隧道的方式进行 IPv6 的访问。</p><p><strong>双栈方式</strong></p><p>所谓双栈( Dual IP Stack ),是指用户计算机及全校网络设备上同时运行 IPv4 和 IPv6 协议栈，同时支持两种协议的数据传输。在双栈开通区域，无需额外配置（ IPv6 地址 及DNS 均自动获取），只要正常认证通过，即可直接使用 IPv6 网。对于不支持双栈的区域，用户可以通过 ISATAP 隧道的方式进行IPv6的访问。</p><p><strong>ISATAP隧道方式</strong></p><p>ISATAP全名是Intra-Site Automatic Tunnel Addressing Protocol，是一种IPv6隧道技术，使用户可以在IPv4网络上访问IPv6资源。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>川大校园网已经开通了 IPv6 网络，用户可以通过双栈及 ISATAP 隧道的方式进行 IPv6 的访问。目前，望江校区、华西校区均开通了双栈方式，江安校区只有部分区域支持。</p><p>我是使用了 ISATAP 隧道方式接入了 IPv6 网络。</p><p><strong>启动</strong></p><p>Win+X 打开 CMD 或 Windows PowerShell（管理员）, 在命令行下操作。</p><p>若系统自动启用了其他隧道会影响正常访问，可选择禁用其他IPv6隧道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh interface teredo set state disable    （禁用 teredo 隧道）</span><br><span class="line">netsh interface 6to4 set state disable      （禁用 6to4 隧道）</span><br></pre></td></tr></table></figure></p><p>设定 ISATAP 路由器和启用 ISATAP 隧道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface isatap set state default</span><br><span class="line">netsh int ipv6 isatap set router 202.115.39.98  //&lt;ISATAP隧道服务器地址&gt;</span><br><span class="line">netsh int ipv6 isatap set state enabled</span><br></pre></td></tr></table></figure><p><strong>测试 IPv6 连接</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping -6 ipv6.test-ipv6.com</span><br><span class="line">ping -6 [2001:470:1:18::125]</span><br></pre></td></tr></table></figure></p><p>连接成功：</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1g25z8qrt14j30is05c0te.jpg" alt=""></p><p>不需要每个包都收到了，只要有包成功发送接收，就表明连通了。</p><p><strong>重置 IPv6 配置（可选）</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 reset</span><br></pre></td></tr></table></figure></p><p><strong>检查</strong></p><p>通过命令 ipconfig /all 查看当前网络信息:</p><blockquote><p>若有2001:250:2003:为前缀的IPv6地址，说明已正常连接了我校IPv6网，</p><p>若是其他前缀的IPv6地址，如FE80：或2001：0:：等开头的，说明IPv6未连通或是连接的非我校IPv6网。</p></blockquote><p><strong>如果发现掉线了：</strong></p><p>执行这3条，全禁掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface teredo set state disabled</span><br><span class="line">netsh interface 6to4 set state disabled</span><br><span class="line">netsh interface ipv6 isatap set state disabled</span><br></pre></td></tr></table></figure></p><p>查看teredo状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 show teredo stat</span><br></pre></td></tr></table></figure></p><p>teredo状态如下：</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1g25z9q03ruj30gu0593yr.jpg" alt=""></p><p>最后再重复之前的设置过程就好了。</p><p>以下操作为非必须。如果按照上述提示操作以后仍无法正常访问 IPv6 站点，可以尝试：</p><ul><li>右键点击桌面“计算机”图标，选择“管理”，展开“服务和应用程序”，选择“服务”，确认“IP Helper”服务已开启；</li><li>确认 Teredo 隧道已经关闭（管理员模式在命令行运行 netsh int teredo set state disable）；</li><li>确认原生 IPv6 已经关闭（ Internet 协议版本 6 (TCP/IPv6)前的对勾取消，位置在控制面板→网络和 Internet→网络和共享中心→更改适配器设置→双击本地连接→属性）；<br>尝试重启系统。</li></ul><h3 id="IPv6常用资源"><a href="#IPv6常用资源" class="headerlink" title="IPv6常用资源"></a>IPv6常用资源</h3><p><strong>一、IPTV</strong></p><p>清华大学：<a href="http://iptv.tsinghua.edu.cn/" target="_blank" rel="noopener">http://iptv.tsinghua.edu.cn/</a></p><p>北京邮电大学 <a href="http://tv.byr.cn/show" target="_blank" rel="noopener">http://tv.byr.cn/show</a></p><p>中国科技大学：<a href="http://tv6.ustc.edu.cn/" target="_blank" rel="noopener">http://tv6.ustc.edu.cn/</a></p><p>东北大学：<a href="http://video.neu6.edu.cn/" target="_blank" rel="noopener">http://video.neu6.edu.cn/</a></p><p>沈阳航空航天：<a href="http://dh.sau6.com/" target="_blank" rel="noopener">http://dh.sau6.com/</a></p><p>安徽农业大学：<a href="http://itv.ahau.edu.cn/" target="_blank" rel="noopener">http://itv.ahau.edu.cn/</a></p><p><strong>二、BT</strong></p><p>六维空间：<a href="http://bt.neu6.edu.cn/" target="_blank" rel="noopener">http://bt.neu6.edu.cn/</a></p><p>北邮人：<a href="http://bt.byr.cn/" target="_blank" rel="noopener">http://bt.byr.cn/</a></p><p>上大乐乎：<a href="http://bt6.shu6.edu.cn/" target="_blank" rel="noopener">http://bt6.shu6.edu.cn/</a></p><p>品知人大：<a href="http://bt.ruc6.edu.cn/" target="_blank" rel="noopener">http://bt.ruc6.edu.cn/</a></p><p><strong>三、其他</strong></p><p>Google : <a href="https://ipv6.google.com/" target="_blank" rel="noopener">https://ipv6.google.com/</a></p><p>ipv6测试 ：<a href="http://result.ds.test-ipv6.com/" target="_blank" rel="noopener">http://result.ds.test-ipv6.com/</a></p><p>ipv6论坛：<a href="http://www.ipv6forum.com/" target="_blank" rel="noopener">http://www.ipv6forum.com/</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/tuna/ipv6.tsinghua.edu.cn/blob/master/isatap.md" target="_blank" rel="noopener">ISATAP隧道</a></p><p><a href="https://github.com/XX-net/XX-Net/wiki/IPv6-Win10" target="_blank" rel="noopener">IPv6 Win10</a></p><p><a href="http://imc.scu.edu.cn/info/1012/1089.htm" target="_blank" rel="noopener">CNGI驻地网开通及IPv6使用指南</a></p><p><a href="https://www.cnblogs.com/xuanmanstein/p/7675406.html" target="_blank" rel="noopener">ping找不到主机问题</a></p><p><br></p><div style="text-align: center"><br><img src="![](https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png)" width="50%" height="50%" align="center"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/ipv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前我一直是在 vps 上自搭梯子来科学上网（Do+ssr），虽说网速挺快，也能触达大部分网站。但还有一类网站无法访问，那就是 IPv6 网站。我曾经在 Ubuntu 下折腾了很久，都没有成功用上我的 ssr。最后看网上的教程，接入 IPv6 网络（开启 Teredo 隧道）
    
    </summary>
    
      <category term="技术" scheme="https://hongbosherlock.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IPv6" scheme="https://hongbosherlock.github.io/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>第n小的质数</title>
    <link href="https://hongbosherlock.github.io/2019/03/08/zhishu/"/>
    <id>https://hongbosherlock.github.io/2019/03/08/zhishu/</id>
    <published>2019-03-08T08:14:21.000Z</published>
    <updated>2021-01-18T10:33:17.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>输入一个正整数n，求第n小的质数。<br><strong>输入</strong><br>一个不超过10000的正整数n。<br><strong>输出</strong><br>第n小的质数。</p><a id="more"></a><p><strong>样例输入</strong></p><blockquote><p>10</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>29</p></blockquote><p><strong>方法一</strong><br>判断一个数n是不是素数，可以用2到$\sqrt{n}$之间的所有整数去除n，看能否整除，如果都不能则n是质数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;s</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">1</span>,i,t=<span class="number">2</span>,f;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">f=<span class="number">1</span>;</span><br><span class="line">m+=<span class="number">2</span>;    <span class="comment">//偶数不是质数，步长可以加大 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=<span class="built_in">sqrt</span>(m);i=i+<span class="number">2</span>)&#123;   <span class="comment">//m是奇数，当然不能被偶数整除，步长也可以加大。</span></span><br><span class="line"><span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">  f=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="built_in">sqrt</span>(m))</span><br><span class="line"> t++;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br>筛选法求质数：把2到n中所有的数都列出来，然后从2开始，先划掉n内所有2的倍数，然后每一次从下一个剩下的数（必然是素数）开始，划掉其n内的所有倍数。最后剩下的数，都是素数。<br>以空间换时间，加快了计算速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 1000000</span></span><br><span class="line"><span class="keyword">bool</span> isPrime[MAX_NUM+<span class="number">10</span>];  <span class="comment">//值为1表示i为素数 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)</span><br><span class="line">isPrime[i]=<span class="literal">true</span>;   <span class="comment">//开始假设所有数都是素数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)&#123;   <span class="comment">//每一次将一个素数的所有倍数标记为非素数 </span></span><br><span class="line"><span class="keyword">if</span>(isPrime[i])&#123;   <span class="comment">//仅标记素数的倍数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=MAX_NUM;j+=i)</span><br><span class="line">isPrime[j]=<span class="literal">false</span>;<span class="comment">//将素数i的倍数标记为非素数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(isPrime[i])</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span>(c==n)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;br&gt;输入一个正整数n，求第n小的质数。&lt;br&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;一个不超过10000的正整数n。&lt;br&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;第n小的质数。&lt;/p&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>菲波那契数列</title>
    <link href="https://hongbosherlock.github.io/2019/03/08/fib/"/>
    <id>https://hongbosherlock.github.io/2019/03/08/fib/</id>
    <published>2019-03-08T08:11:50.000Z</published>
    <updated>2021-01-17T15:08:50.216Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。<br>给出一个正整数k，要求菲波那契数列中第k个数是多少。<br><a id="more"></a><strong>输入</strong><br>输入一行，包含一个正整数k。（1 &lt;= k &lt;= 46）<br><strong>输出</strong><br>输出一行，包含一个正整数，表示菲波那契数列中第k个数的大小</p><p><strong>样例输入</strong></p><blockquote><p>19</p></blockquote><p><strong>样例输出</strong> </p><blockquote><p>4181</p></blockquote><p>Code:</p><p><strong>解法一：递归</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib(n<span class="number">-2</span>)+Fib(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonac</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> Fibonac(a+b,a,n<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//第几个斐波那契数列</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="comment">//printf("%d\n",Fib(k));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//斐波那契数列的第一项  </span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>; <span class="comment">//第二项  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Fibonac(a,b,k));<span class="comment">//优化后的递归  ;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法二:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a1=<span class="number">1</span>,a2=<span class="number">1</span>,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>||k==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k<span class="number">-2</span>;i++)&#123;</span><br><span class="line">sum=a1+a2;</span><br><span class="line">a1=a2;</span><br><span class="line">a2=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;br&gt;菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。&lt;br&gt;给出一个正整数k，要求菲波那契数列中第k个数是多少。&lt;br&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="斐波那锲" scheme="https://hongbosherlock.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E9%94%B2/"/>
    
  </entry>
  
  <entry>
    <title>成绩排序（选择排序，结构体数组）</title>
    <link href="https://hongbosherlock.github.io/2019/01/23/sort1/"/>
    <id>https://hongbosherlock.github.io/2019/01/23/sort1/</id>
    <published>2019-01-23T03:24:47.000Z</published>
    <updated>2019-01-23T03:26:38.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="02-成绩排序"><a href="#02-成绩排序" class="headerlink" title="02:成绩排序"></a>02:成绩排序</h4><hr><p>总时间限制: 1000ms 内存限制: 65536kB</p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则<strong>名字字典序</strong>小的在前。<br><a id="more"></a></p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行为n (0 &lt; n &lt; 20)，表示班里的学生数目；<br>接下来的n行，每行为每个学生的名字和他的成绩, 中间用单个空格隔开。名字只包含字母且长度不超过20，成绩为一个不大于100的非负整数。</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>把成绩单按分数从高到低的顺序进行排序并输出，每行包含名字和分数两项，之间有一个空格。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><blockquote><p>4<br>Kitty 80<br>Hanmeimei 90<br>Joey 92<br>Tim 28</p><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><p>Joey 92<br>Hanmeimei 90<br>Kitty 80<br>Tim 28</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>简单的排序问题，每个待排序的对象包括两个元素，需要用二维数组或者结构体数组。<br>这里采用结构体数组的方法，采用选择排序实现。<br><strong>【注意】</strong>题目中说名字字典序，是整个字符串，并不代表首字母。</p><h6 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h6><p>简单的说就是，从原有的数组中选择最大/最小的数依次加入新的数组，并从原数组中删除这个值。 这里我们只用一个数组，前部是已排序的（新数组），后部是待排序的（旧数组）</p><h6 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h6><p>(1) 首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。<br>(2) 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>(3) 左右两边分别排序，直到各区间只有一个数。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line">Student stu[<span class="number">10001</span>]; <span class="comment">//定义Student类型的数组stu</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student* stu,<span class="keyword">int</span>  i,<span class="keyword">int</span>  j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student t;</span><br><span class="line">t=stu[i]; </span><br><span class="line">stu[i]=stu[j];</span><br><span class="line">stu[j]=t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选择排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(Student stu[<span class="number">1001</span>],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="comment">//double t1,t2;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序 </span></span><br><span class="line"><span class="keyword">if</span>(stu[j].grade&gt;stu[min].grade)</span><br><span class="line">    min=j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(stu[j].grade==stu[min].grade&amp;&amp;stu[j].name&lt;stu[min].name) </span><br><span class="line">    min=j; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(stu,i,min);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;stu[i].name&gt;&gt;stu[i].grade;</span><br><span class="line"></span><br><span class="line">selectionSort(stu,n);</span><br><span class="line"><span class="comment">//quickSort2(a,0,n-1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;stu[i].name&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[i].grade&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;02-成绩排序&quot;&gt;&lt;a href=&quot;#02-成绩排序&quot; class=&quot;headerlink&quot; title=&quot;02:成绩排序&quot;&gt;&lt;/a&gt;02:成绩排序&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;总时间限制: 1000ms 内存限制: 65536kB&lt;/p&gt;
&lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h5&gt;&lt;p&gt;给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则&lt;strong&gt;名字字典序&lt;/strong&gt;小的在前。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://hongbosherlock.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
