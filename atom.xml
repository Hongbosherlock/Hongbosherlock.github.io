<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HongboSherlock&#39;blog</title>
  <icon>https://www.gravatar.com/avatar/01a6e634aaa732c8a71d6c3caae87072</icon>
  <subtitle>Stay Hungry, Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongbosherlock.github.io/"/>
  <updated>2021-01-18T10:29:28.363Z</updated>
  <id>https://hongbosherlock.github.io/</id>
  
  <author>
    <name>Xu Hongbo</name>
    <email>hongbosherlock@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>请回答 2020</title>
    <link href="https://hongbosherlock.github.io/2020/12/31/2020-sum/"/>
    <id>https://hongbosherlock.github.io/2020/12/31/2020-sum/</id>
    <published>2020-12-31T10:51:38.000Z</published>
    <updated>2021-01-18T10:29:28.363Z</updated>
    
    <content type="html"><![CDATA[<p>马上就到了 2021 年了，感觉今年过的尤其快。这是新冠疫情爆发的一年，也是我本科毕业的一年，那些人那些物不知何时再见。今年的最后我是一个人，在这个安静的夜晚，回忆在暗处流动，未来在偷偷发芽。</p><p>回顾了一下去年的总结，2019年对我来说是不太顺利的一年。其实我也有一些决策上的错误，错过了一些机会，也浪费了时间。好在最后折腾下来结果还不算差，仿佛去年的不顺在今年都转为了好运。</p><a id="more"></a><p>去年的 12.31 号我在图书馆里写下了年终总结，当时考完研的我对未来并不确定，也有不少迷茫。佩服那些很早就想清楚自己的方向，并为之努力的人。大学前两年我的路就是学习，拿奖学金，以后读研，对于未来还有哪些可能，我并没有思考很多。有的想了想，觉得并不可行也就算了。为绩点而努力，少了些 coding 的能力。现在想想我应该在大三暑假前找个实习的，有一段真实的工作经历。</p><p>“把目标设在月球，即使失败也能落在众星之间。”离开成都去北京，我想跳出之前的舒适环境，去闯一闯。当时觉得考研只是一种途径，即使失败我还有春招的机会。并没有二战的想法，或者担心我要怎么办的问题。</p><p>于是疫情在家里躺了两个月后，三月份我便开始准备春招了。复习知识点，刷题，面试。在面试过程中慢慢有了自信，找到了方向，最后有幸拿到了美团的 Java 开发 offer。看到牛客网上有发帖说考研失败然后拿到百度和字节的offer的大佬，觉得真的挺厉害的，功夫不负有心人啊。</p><p>5月份回校后接到现在导师的电话，最后面试通过成功补录。还记得当时和 lu 腾讯会议，她帮我纠正英文自我介绍。面试和毕设答辩赶在了一上午，面试后觉得很糟糕，没戏了。第二天和 xiao 打游戏时突然接到了通过的电话，顿时觉得时来运转。</p><p>最后选择了读研，有一部分是妥协，还有一点对工作的逃避，也有一些对研究生生活的期待。这是我自己的选择。</p><h3 id="1-告别与遇见"><a href="#1-告别与遇见" class="headerlink" title="1. 告别与遇见"></a>1. 告别与遇见</h3><p>成都是一座有烟火气息的慢节奏城市，川大有着包容的氛围，江安则是一片安静的乐土。回顾我的大学四年，并不算很精彩，也有一些遗憾，但这些并不妨碍在江安的日子将是我人生中一段美好的回忆。本科已经结束，我们遇见，然后告别。然而人生的大学仍在继续，并没有毕业的那一天。</p><p>来到北京，雁栖湖是一个远离市区很安静的地方。我觉得自己在这一学期是比较分裂的，一边需要上已经被安排好的不太感兴趣的课，一边在努力挤时间自学想学的知识。耗费了不少精力在不想做的事情上，自己想做的事情却进展不多。</p><p>在这里因为摄影遇到了一些新朋友，很开心。加入了记者团摄影部和摄影协会，后面感觉自己并没有融入进去，也许这就是我吧。</p><p>读研后，总有一种焦虑感，担心自己会落后于学校外的时代。25岁毕业，别人已经工作、在社会摸爬滚打了三年，而我还是初生牛犊。要多 coding，多实习，多思考。</p><p>要说今年的收获，春招拿到 offer，读上研。毕业前在学校度过了一个月的时光，参加了毕业典礼。用新买的相机给一些同学拍了毕业照。暑假拿到了驾照，跟着我爸去贵州玩了一周，今年难得的一次旅游。</p><p>下学期除了上课，还做了一件事，给实验室和医院合作的项目写了一个 PC 软件，虽然只是一个用 pyqt 写的简单 UI，看上去还不错，只是还需要再改进。</p><p>在未来到来之前，我们还是分开了。今夕的拥抱与临别，未曾断定恋情的结束。曾经在一起，也许没有什么是比这更重要的存在。</p><blockquote><p>人生有那么多可能，这么多也有趣，有意思，有意义的事情。为什么不去学，为什么不去做？几年之后你会发现，自己曾经烦恼的事情，不能算是人生中百分之一，更不能算作是浩瀚宇宙中的一抹流星。你遇见一个人，是为了成就更好的自己，还是为了尽情沉湎在过去的自己里？人生有百般借口，何须烦恼择其一。</p></blockquote><p>有时候感觉压力太多，想要逃避社会上的条条框框，去追求自由。但是抛弃一切就真的是自由了吗？也许不是，实际上我们没法单单为自己而活，我们不想承担责任，想独自一人，但是没法做到。我们不仅为自己而活，也为别人而活。对一个人来说，真正重要的是【懂得自由选择】，而不是【选择自由】。</p><h3 id="2-未来"><a href="#2-未来" class="headerlink" title="2. 未来"></a>2. 未来</h3><blockquote><p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。<br>——王小波《黄金时代》</p></blockquote><p>20多岁的年纪，刚刚大学毕业，就能真真正正想清楚一辈子要怎么活了吗？我并不外向，但我并不是一个喜欢宅的人，也不是一个安分的人。</p><p>知乎上有个<a href="https://www.zhihu.com/question/19832061" target="_blank" rel="noopener">23 岁的你曾处于什么样的状态？</a>的问题，我觉得里面的回答都不错。人只有不断保持努力，才会每年都是过去人生的巅峰。</p><p>对于明年要做的事情，我首先想到的就是<strong>学会游泳</strong>，我觉得这是一个很重要的生存技能。然后就是<strong>摄影</strong>，买相机还不到半年，但最近几周都没怎么动相机。明年要多学习，多拍，多思考。我会把一些觉得满意的照片发在这里。第三读更多的<strong>书</strong>，看更多的<strong>电影</strong>。学好<strong>C++</strong>，刷起 <strong>leetcode</strong>。最后，争取发一篇<strong>论文</strong>吧，现在还没决定具体做什么方向。</p><p>希望我的2021，我的23岁：</p><p><strong>不为过去后悔，永远相信未来。</strong></p><p>最后，祝各位：新年愉快，家庭和睦，事业有成，身体安康，温良恭谨，正直善良，无愧于心，怀有理想。</p><p>感谢大家的关注与支持，我们 2021 再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;马上就到了 2021 年了，感觉今年过的尤其快。这是新冠疫情爆发的一年，也是我本科毕业的一年，那些人那些物不知何时再见。今年的最后我是一个人，在这个安静的夜晚，回忆在暗处流动，未来在偷偷发芽。&lt;/p&gt;
&lt;p&gt;回顾了一下去年的总结，2019年对我来说是不太顺利的一年。其实我也有一些决策上的错误，错过了一些机会，也浪费了时间。好在最后折腾下来结果还不算差，仿佛去年的不顺在今年都转为了好运。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://hongbosherlock.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="https://hongbosherlock.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>智能陷阱：愿者上钩</title>
    <link href="https://hongbosherlock.github.io/2020/11/17/social-dilemma/"/>
    <id>https://hongbosherlock.github.io/2020/11/17/social-dilemma/</id>
    <published>2020-11-17T09:54:42.000Z</published>
    <updated>2021-01-18T10:31:15.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg" alt=""></p><p>回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。<a id="more"></a></p><p>前一阵子看了一部 Netflix 的纪录片——《监视资本主义：智能陷阱 The Social Dilemma》。特里斯坦·哈里斯是谷歌前设计道德伦理专家，他呼吁技术产业在产品中引进被他称为“道德伦理设计”的要素。硅谷之前的商业模式是公司通过销售硬件、软件这样的产品来盈利。而过去十年硅谷则一直在通过“出售”用户来盈利。</p><p>二十多年前，雅虎的杨致远和费罗首创了免费的互联网服务，并且找到了广告这种商业模式，这才让互联网成为一个开放免费的工具。如今网上已经有了很多免费产品，如果我们不用为使用这些产品付钱，那谁来付钱呢？广告商为我们使用的产品付钱。换句话说，广告商是顾客，我们是被销售的商品。</p><p><strong>“如果你没有花钱买产品，那你就是被卖的产品。”</strong>所谓的免费并不是真正的免费，而是广告商在为用户的注意力付钱，我们付出的是自己的时间。手机上各种应用，每天不断推送着通知，都在竞争用户的注意力，想办法增加日活，向广告商出售更多用户的时间。大部分应用会记录用户的浏览记录，甚至在哪张图片或视频上停留了多久。（这是真的）</p><p>我们在互联网上的数据被偷偷共享（还记得在QQ空间看到的京东广告吗），即使使用协议在某个地方注明了这一点，我们也并没有被着重通知。同时我们的数据被公司用来构建更精确的模型，来预判用户行为进而迎合用户：让我们不停滑动屏幕，沉浸其中。</p><p>那些精明的产品经理一般都比较了解心理学，深谙人性的弱点。他们黑入人们的心理，利用这一点一点点来慢慢操纵用户的使用习惯，而用户往往不知不觉地深陷其中。无论是“对方正在输入中”还是“下拉刷新内容”都是对我们心理上的某种操纵。每次下拉刷新都会出现新的内容，这在心理学上叫做“正积极强化”，给用户反馈和激励，有点像赌城的老虎机。</p><p>“我们想在心理学上弄清楚，怎么样以最快的速度操纵你。然后返回给让你产生兴奋的事物。”一位脸书的前用户增长负责人曾经说道。无论是点赞，还是粉丝数增加（有不少是僵尸粉），都是在实践这一点。这就是在利用人们心理的脆弱来赚钱。</p><p>社交媒体就像是毒品。我们都有着基本的欲望去和别人联系，需要和别人有社会性联系，需要得到认可。但我们不需要得到一万人的认可，也不需要每隔五分钟就获得一次社交认可。没有手机，我们能独处吗，可以处理自己的情绪吗？那些不自在、孤独、害怕的情绪很多时候都在指尖麻木地滑动屏幕之时被忽视了。</p><p><div align="center"><img src="http://ww1.sinaimg.cn/mw690/006w4HKkly1gms0go8bt5j30zk0k00uk.jpg" alt=""></div></p><p>如摩尔定律所预测的那样，技术在快速进步，但是人脑却进化缓慢。我们一直在担忧人工智能发展带来的负面影响：人工智能会超过人类的智慧，最终觉醒然后统治人类吗？无论是《终结者》还是《我，机器人》都在传达这种担忧。虽然未来还不太明了，但事实上人工智能已经在碾压人性的弱点了。那些算法在促进人们的两极分化，使我们上瘾，变得激进化，激化我们的虚荣心……</p><p>纪录片中提到，Google 会基于人们的地理位置来进行搜索提示和展示搜索结果排序。这也使得人们变得两极分化，因为一个人看到的往往都是自己感兴趣的内容。Facebook可以说是一个强大的操纵工具，甚至可以对大选产生影响。互联网和社交媒体不断在动摇和侵蚀社会结构。问题不仅仅是观点的对立，而是极端的两极分化，各方丝毫不听取对方的观点，拒绝沟通。</p><p>人工智能并不知道什么是真理，只是被数据训练奔着某个最优的目标，算法是冰冷无情的。AI无法解决谣言和人们之间的对立。在互联网上谣言的传播是真相的6倍。虚假信息往往比较符合大众的口味，会吸引人们的兴趣。而真相和事实相比往往比较枯燥，所以人们会自发转发虚假信息，AI算法也会根据人们的”兴趣”不停地推荐虚假信息。新冠时期传播得快的不止是新冠，还有谣言。美国甚至有”新冠无害，5G有害”的谣言，人们冲上街上推倒5G信号杆，无不荒唐。</p><p>可以说，某种程度上人工智能算法技术在方便我们生活的同时，也把社会中最坏的东西带出来了，并通过网络放大传播，而这些东西是人类社会的威胁。</p><p>什么是「工具」？什么是「产品」？你在使用产品还是你是产品的一部分？这也许是我们每个人都应该思考的。</p><p>要终止现在的这一切很难，平台越做越大，雪球也越滚越大，很难停下来。而且互联网公司有自己营收和股东的压力，仅靠公司的自觉并不够，因此这些公司需要被监管，也急需数据隐私方面的立法。</p><p>推荐算法建造了信息茧房，也弱化了人们的主动思考。我们与之对抗的手段之一是不看推荐的内容，而是主动思考自己想要什么，搜索自己想要的内容。同时建造我们自己的信息茧房也同样重要，关键是选择可靠的信源，这样我们可以尽可能地屏蔽垃圾信息，获取更有价值的信息。</p><p>纪录片中提到，也可以通过下面这些方法减少社交网络的影响：关掉所有通知；分享之前，查找事实，思考信息来源，不要被情绪煽动；减少屏幕使用时间，减少社交媒体时间。不带电子设备进卧室；很多年轻人容易沉迷网络，也许比较好的做法是不要让16岁之前的孩子使用社交媒体。</p><center><img src="http://ww1.sinaimg.cn/mw690/006w4HKkly1gms0h1efpoj30zk0ij75i.jpg" alt="你会选择哪一个"><br><div style="font-size:16px;color:#C0C0C0;text-decoration:underline">你会选择哪一个</div></center> <p>Elon musk做过一个访谈 提到了一些社交媒体的负面影响。其中有一点就是，很多人在朋友圈里分享的都是自己最快乐精彩的片段。这样的片段让很多人看到了会抑郁，因为自己的生活并没这么快乐精彩。其实上大部分人99%的时间都是不那么精彩的，大家只是有选择性的分享一些最好的时光。</p><p>我在过去一个月的时间里，周一到周五关闭朋友圈，周末两天打开。因为我平时总会时不时刷朋友圈，这样做确实减少一些了我看手机的时间，感觉效果还不错。但这样做的缺点就是，我不能及时和朋友互动：可能会错过最近发生的事情、少了给别人的点赞和评论。（有意思的是，设计 Facebook 点赞按钮的工程师的初衷是想通过“点赞”传递爱，现在我们却越来越在意点赞了。）</p><p>总之，在是否使用社交网络上需要做一些 Trade-off。但同时我们可以改变自己的一些不好的习惯，吃饭、睡觉、上厕所一直盯着手机，或者学习时被不断打扰。否则这样下去我们只会变成成天盯着屏幕看、把注意力都贡献成广告商的僵尸，从而错过自己本可以拥有的美好人生。</p><p>不妨放下手机，去外面走走，陪一陪自己爱的人和朋友吧。</p><p>推荐阅读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNTQ4ODg4OA==&amp;mid=2247486326&amp;idx=1&amp;sn=fb2b4998bb6a817d4fe08d658ce0384e&amp;chksm=e8e71861df909177e1f602b9f77df389f702e97b250270588b1d716ab5ad67194afe601910c1&amp;scene=21&amp;token=1554957162&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">「黑客帝国」和「楚门的世界」 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。
    
    </summary>
    
      <category term="科技" scheme="https://hongbosherlock.github.io/categories/%E7%A7%91%E6%8A%80/"/>
    
    
  </entry>
  
  <entry>
    <title>成长的烦恼 —— 2019 总结</title>
    <link href="https://hongbosherlock.github.io/2019/12/31/2019-sum/"/>
    <id>https://hongbosherlock.github.io/2019/12/31/2019-sum/</id>
    <published>2019-12-31T14:37:46.000Z</published>
    <updated>2021-01-18T10:29:15.594Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2019年的最后一天了，事实上明天和今天不会有太大差别，重要的是在这样一个具有仪式感的日子，总结过去，展望未来。</p><p>本来不想写总结的，因为我觉得自己要说的太多了，而且有些心里话也不适合公开写出来。但还是有必要把今年的一些经历和感想记录下来，一方面是对我过去一年学习生活的总结，另一方面也是让关心我的朋友们了解一下我的近况。<a id="more"></a></p><p>今年的事情用两个词总结起来可能就是<strong>失恋</strong>和<strong>失学</strong>了，别人爱情事业两丰收，我则两手空空（苦笑）。</p><p>一月份和她由异地转为异国，本来已经遥远的距离变得更遥远了，还加上了时差。那几天两个人的状态都不太好，她忙于自己的课程，我则在感到保研北航无望后开始纠结工作还是读研。气氛比较僵，我也没有去积极缓和。分手那天是星期三，晚上”川西人文风光漫谈”下课后，嗯仿佛一切都历历在目。</p><p>那一刻，以前的约定和承诺都显得如此苍白无力，那些曾经盼望过的美好也都化为了泡影，我们还是输给了现实。我曾经感受过幸福和美好，最终也体会到了失去心爱之人的痛楚。有时候分不清回忆是美好还是痛苦了，我想，美好是客观的，痛苦是心境吧。</p><p><strong>失恋，是我今年遇到的第一个成长烦恼。</strong>有些事情并不是理所应当，有些人也不会一直都在。“世间好物不坚牢，彩云易逝琉璃碎”。最重要的还是珍惜当前吧。我一直觉得只有初恋的人之间才能演绎出爱情的本真，那些酸甜苦也还都记得。成熟的人之间的爱情也许很美好，但可能也只有美好了。我想，我的青春可能已经结束了。</p><p>之后我一直在努力调整自己，失恋对我的影响比我想象的要严重，很长一段时间我并没有释怀。爸妈听说后还想过五一放假来看我，后来我才明白原来父母才是最了解自己的。</p><p>后来我综合了一下优劣，还是决定读研。和好友DS一起投了北航和其他几个学校的夏令营，最后只过了一个，北航没有过。虽说今年竞争激烈，终究还是我太菜了。7月份提前结束了学院的实习，飞去深圳参加了中科院深研院的夏令营，顺便参观了腾讯、华为，算是涨了一些见识。</p><p>我对自己能否拿到学院的保研名额也不太确定，暑假便留校开始备考北航，便没有再关注夏令营和联系老师（于是错过了一些机会）。开学后有幸拿到了学院的保研名额，开始疯狂给北邮的老师发邮件，回复的都说招满了。。。同时关注中科院几个所的补录，也报名了北航的九推面试。最后北航的预审都没有过，深受打击。</p><p>十一假期先后接到了软件所和信工所的面试通知，要去北京。当时已经过了九推，可以说我的对手很少。但当时我对自己考研信心满满（太天真了），比来比去还是觉得北航好，也不太喜欢研究所的氛围（现在觉得这些想法好矫情，好SB）。最后我就拒了面试。后面几个月的复习过程中，累的时候我就会想到这件事，怀疑自己的选择是否正确。自己选择的路，还是跪着走完吧。</p><p>十月中旬在学院老师的开导下幡然醒悟，在这里也非常感谢学院对我的帮助和宽容。抓住了中科院一个老师的最后一根稻草，联系的实验室的学长都说我应该稳了，煎熬等待将近一周后，最后老师要了一个北大数学的，希望落空。也顺便感谢学长给我的帮助和鼓励，去了北京还会见面的。</p><p>这时我的心态早已被锻炼的比较好了，开始调整状态全力考研，觉得自己无论如何都要考上北航。每天考研复习的强度也只是比之前我期末复习的强度大了一些，所以也没觉得有多苦，也没想过放弃。考研不是我的目标或终点，只是达成目标的一个途径，也不觉得考研是多么感动一件事。但看着图书馆和自习室里晚归的人儿，我一直是对那些有理想、有目标，坚持奋斗的人心怀敬意的。</p><p>我也不会看不起放弃考研的人，因为生活本来就不容易，人的忍受度和特长也不同。该找工作就找工作，出路有很多。不过对于那些大四了还在混混僵僵过日子，对未来没有目标、没有计划的人，我是不屑的。今年我既看到了前三年表现平平，但最后靠自己努力拿到了不错的 offer 的同学，也感受到了温水煮青蛙的可怕。</p><p><strong>未来选择，是我今年遇到的第二个成长烦恼。</strong>在逆境和迷茫之中，我感到自己隐隐约约已经知道自己想要做什么，想到成为什么样的人。沉浸于UNIX时期的黑客文化，想去追求纯粹的技术。处在今天这样一个科技改变世界的时代，想去用自己的想法和代码让世界变得更好。</p><p>曹大说，一定要知道自己想要的是什么，一定要知道自己最好奇，最痴迷的是什么，缺乏足够的好奇心，是没有可能在某个领域进入顶尖位置的。关于个人定位，不同时期也是不同的，我现在也还不太清晰，还有很长的路要走。</p><p>今年是不太好过的一年，幸运的是我都扛过来了。最最感激的是爸妈一直对我无条件的支持，无论是在物质上还是精神上。让我永远有勇气面对未来的一切挑战。当然也感谢老弟的支持，家人永远是我不离不弃的依靠，同时也希望自己不断成长，爱自己，爱家人，成为我爱的人的依靠。</p><p>有人说 2019 可能是未来10年中最好的一年了。只要我们心怀希望，一切都会好起来的。</p><p>万物之中，希望至美。至美之物，永不凋零</p><p><strong>感谢大家这半年多的关注！</strong>我们 2020 再见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2019年的最后一天了，事实上明天和今天不会有太大差别，重要的是在这样一个具有仪式感的日子，总结过去，展望未来。&lt;/p&gt;
&lt;p&gt;本来不想写总结的，因为我觉得自己要说的太多了，而且有些心里话也不适合公开写出来。但还是有必要把今年的一些经历和感想记录下来，一方面是对我过去一年学习生活的总结，另一方面也是让关心我的朋友们了解一下我的近况。
    
    </summary>
    
      <category term="生活" scheme="https://hongbosherlock.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="https://hongbosherlock.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>初识递归</title>
    <link href="https://hongbosherlock.github.io/2019/12/20/recursion/"/>
    <id>https://hongbosherlock.github.io/2019/12/20/recursion/</id>
    <published>2019-12-20T10:43:08.000Z</published>
    <updated>2021-01-18T10:31:08.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>一个函数调用本身就是递归。<br>递归和普通函数调用一样，是通过栈实现的。</p><h3 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h3><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h3 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h3><ul><li>代替多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解为规模更小的子问题进行求解</li></ul><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。</p></blockquote><p>不要试图想清楚整个递和归的过程，这样容易被绕进去。</p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。</strong></p><a id="more"></a><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="递归代码要警惕栈溢出"><a href="#递归代码要警惕栈溢出" class="headerlink" title="递归代码要警惕栈溢出"></a>递归代码要警惕栈溢出</h4><p>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有栈溢出的风险。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p>重复计算就是 f(k) 被计算多次，影响效率。<br>可以用数据结构（比如散列表），来保存已经求解过的 f(k)。</p><p>在计算斐波那契函数 F(n) 的过程中， 我们可以使用 <strong>哈希表</strong> 来跟踪每个以 n 为键的 F(n) 的结果。 <strong>散列表</strong> 作为一个缓存，可以避免重复计算。 <strong>记忆化技术</strong> 是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。</p><h4 id="函数可能会有多个位置进行自我调用"><a href="#函数可能会有多个位置进行自我调用" class="headerlink" title="函数可能会有多个位置进行自我调用"></a>函数可能会有多个位置进行自我调用</h4><h3 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h3><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 递归中函数调用较多，执行所需时间也比较多。<br>给出一个递归算法，其时间复杂度 O ( T ) 通常是 <strong>递归调用的数量</strong> (记作 R) 和单次计算的时间复杂度 (表示为 O ( S ) )的乘积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(T)=R∗O(s)</span><br></pre></td></tr></table></figure></p><p>一般情况下单次计算的时间复杂度为 O ( 1 )</p><p><strong>执行树</strong></p><blockquote><p><strong>执行树</strong> 是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p></blockquote><p>归函数的执行树将形成 n 叉树，其中 n 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 f(4) 的执行树。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/01/fibonacci.png" alt="image"></p><p>在 n 层的完全二叉树中，节点的总数为 2^n -1 。因此 f(n) 中递归数目的上限（尽管不严格）也是 2^n -1。那么我们可以估计 f(n) 的时间复杂度为 O(2^n)。</p><p>通过使用 <strong>记忆化技术</strong> 计算 f(n) 的递归将被调用 n-1 次以计算它所依赖的所有先验数字。</p><p>此时时间复杂度为: O ( 1 ) * n = O ( n )。记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><blockquote><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：<strong>递归相关空间</strong>（recursion related space）和 <strong>非递归相关空间</strong>（non-recursion related space）。</p></blockquote><h5 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h5><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。<br>因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要首先考虑这部分的开销。<br><img src="https://assets.leetcode.com/uploads/2019/01/25/card_recursion_stack.png" alt="image"></p><p>如果递归规模较大，可以自己模拟一个栈，用非递归的方法实现。因为递归借助的是我们看不到的系统栈，调用过多时系统栈会溢出。</p><h5 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h5><p>通常包括为全局变量分配的空间（通常在堆中）。<br>还可能包括使用 <strong>记忆化技术</strong> 时，保存递归调用的中间结果分配的空间。</p><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>一般递归调用会在系统调用栈上产生的隐式额外空间。有一种然而，你应该学习识别一种称为尾递归的特殊递归情况，它不受此空间开销的影响。</p><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p></blockquote><p>下面的<strong>打印字符串</strong>就是尾递归的一种情况，即递归调用之后就没有额外的计算语句了。</p><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。<br><img src="https://assets.leetcode.com/uploads/2019/01/26/card_recursion_tail.png" alt="image"></p><p>请注意，在尾递归的情况下，一旦从递归调用返回，我们也会立即返回，因此我们可以跳过整个递归调用返回链，直接返回到原始调用方。这意味着我们根本不需要所有递归调用的调用栈，这为我们节省了空间。</p><p>例如，在步骤（1）中，栈中的一个空间将被分配给 f(x1)，以便调用 f(x2)。然后，在步骤（2）中，函数 f(x2) 能够递归地调用 f(x3)，但是，系统不需要在栈上分配新的空间，而是可以简单地重用先前分配给第二次递归调用的空间。最后，在函数 f(x3) 中，我们达到了基本情况，<strong>该函数可以简单地将结果返回给原始调用方，而不会返回到之前的函数调用中。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、当我们面对一个问题，不清楚是否可以使用递归时，我们可以尝试写下递推关系式，利用数学公式来推导某些关系。</p><p>2、尽可能使用记忆化技术，减少重复计算</p><p>3、担心可能因为递归次数太多，而导致堆栈溢出时，可以使用尾递归。</p><h3 id="一些帮助理解的题目"><a href="#一些帮助理解的题目" class="headerlink" title="一些帮助理解的题目"></a>一些帮助理解的题目</h3><p><strong>一、以相反的顺序打印字符串</strong><br>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><p>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><ul><li>printReverse(str[1…n-1])：以相反的顺序打印子字符串 str[1…n-1] 。</li><li>print(str[0])：打印字符串中的第一个字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//函数首次传入的是 str 的首地址，也就是 &amp;str[0]</span></span><br><span class="line">  <span class="keyword">if</span> (!*str)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//在 str[n-1] = '\0' 时终止</span></span><br><span class="line">  printReverse(str + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>汉诺塔可以看做递归问题<br>N 皇后问题其实是回溯问题</p><p><strong>N皇后问题</strong><br>每行只能放置一个皇后、每列也只能放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出结果里的每一行都代表一种摆法。</span></span><br><span class="line"><span class="comment"> 行里的第i个数字如果是n，就代表第i行的数字应该放在第n列。</span></span><br><span class="line"><span class="comment"> 皇后的行、列编号都是从 1开始算。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> queenPos[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//用来存放算好的皇后位置。最左上角是 (0,0) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//在 0~k-1行已经摆好的情况下，摆第k行及其后面的元素</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==N)&#123;</span><br><span class="line"><span class="comment">//N个皇后已经摆好</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;queenPos[i]+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="comment">//逐尝试第k个皇后的位置</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++) &#123;</span><br><span class="line"><span class="comment">//和已经摆好的 k 个皇后的位置比较，看是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(queenPos[j] == i|| <span class="built_in">abs</span>(queenPos[j]-i)==<span class="built_in">abs</span>(k-j))</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="comment">//第一个条件表示第 i 列已经有皇后了</span></span><br><span class="line"><span class="comment">//第二个条件表示两个皇后是否在同一条对角斜线上 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j==k)&#123;</span><br><span class="line"><span class="comment">//当前选的位置 i 不冲突</span></span><br><span class="line">queenPos[k] = i;</span><br><span class="line"><span class="comment">//queenPos[k] 在第一次赋值后，回溯时值是可能会改变的。</span></span><br><span class="line">NQueen(k+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个for循环中的递归，称作回溯。</span></span><br><span class="line">&#125;<span class="comment">//for循环终止</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">NQueen(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">//从第0行开始摆皇后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全排列</strong></p><p>求 1~n 的全排列。可以分为若干个子问题：以 1 开头的全排列；以 2 开头的全排列；以 3 开头的全排列…</p><ul><li>数组 P 用来存放当前排列</li><li>散列数组 hashTable[x] 当整数 x 已经在数组 P 中时为 true。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// P为当前排列，hashTable 记录整数 x 是否已经在 P 中 </span></span><br><span class="line"><span class="keyword">int</span> n,P[maxn],hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 当前处理排列的第 index 位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123; <span class="comment">//递归边界,已经处理完排列的 n+1 位 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123; <span class="comment">//枚举 1~n，试图将 j 填入P[index]</span></span><br><span class="line"><span class="keyword">if</span>(hashTable[j]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 x 不在 P[0]~P[index-1]中 </span></span><br><span class="line">P[index]=j;           <span class="comment">// 把 x 加入当前排列 </span></span><br><span class="line">hashTable[j]=<span class="literal">true</span>;    <span class="comment">// 记 x 已在 P 中</span></span><br><span class="line">generate(index+<span class="number">1</span>);   <span class="comment">// 处理排列的第 index+1 位</span></span><br><span class="line">hashTable[j] = <span class="literal">false</span>; <span class="comment">// 已处理完 P[index] 为 j 的子问题，还原状态 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="number">3</span>;   </span><br><span class="line">generate(<span class="number">1</span>);  <span class="comment">// 从 P [1] 开始填</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回溯法实现 N 皇后</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;  <span class="comment">//递归边界 </span></span><br><span class="line">count++; <span class="comment">//能达到这里的一定是合法的</span></span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;  <span class="comment">//第 x 行 </span></span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123; <span class="comment">//第 x 行还没有皇后 </span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123; <span class="comment">//遍历之前的皇后 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre) == <span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123; <span class="comment">//可以把皇后放在第 n 行 </span></span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generate(index+<span class="number">1</span>); <span class="comment">//递归处理第 index+1 行皇后</span></span><br><span class="line">hashTable[x]=<span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h3&gt;&lt;p&gt;一个函数调用本身就是递归。&lt;br&gt;递归和普通函数调用一样，是通过栈实现的。&lt;/p&gt;
&lt;h3 id=&quot;递归的条件&quot;&gt;&lt;a href=&quot;#递归的条件&quot; class=&quot;headerlink&quot; title=&quot;递归的条件&quot;&gt;&lt;/a&gt;递归的条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个问题的解可以分解为几个子问题的解&lt;/li&gt;
&lt;li&gt;这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/li&gt;
&lt;li&gt;存在递归终止条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;递归的作用&quot;&gt;&lt;a href=&quot;#递归的作用&quot; class=&quot;headerlink&quot; title=&quot;递归的作用&quot;&gt;&lt;/a&gt;递归的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代替多重循环&lt;/li&gt;
&lt;li&gt;解决本来就是用递归形式定义的问题&lt;/li&gt;
&lt;li&gt;将问题分解为规模更小的子问题进行求解&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要试图想清楚整个递和归的过程，这样容易被绕进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://hongbosherlock.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>vector 用法总结</title>
    <link href="https://hongbosherlock.github.io/2019/09/04/vector/"/>
    <id>https://hongbosherlock.github.io/2019/09/04/vector/</id>
    <published>2019-09-04T02:36:34.000Z</published>
    <updated>2021-01-18T10:33:04.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vector-介绍"><a href="#vector-介绍" class="headerlink" title="vector 介绍"></a>vector 介绍</h4><p>vector 是表示可以改变大小的数组的序列容器。</p><p>vector 能够容纳许多其他类型相同的元素,因此又被称为<strong>容器</strong>。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够<strong>存放任意类型的动态数组</strong>，能够增加和压缩数据。</p><p>与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。</p><p><strong>容器特性</strong></p><p>1.顺序序列</p><blockquote><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p></blockquote><p>2.动态数组</p><blockquote><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p></blockquote><p>3.能够感知内存分配器的（Allocator-aware）</p><blockquote><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p></blockquote><a id="more"></a><h4 id="声明及初始化"><a href="#声明及初始化" class="headerlink" title="声明及初始化"></a>声明及初始化</h4><p><strong>头文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>vector 是一个模板类，所以需要用 vector<typename> arry 这样的方式来声明一个 vector。<br>vector 型变量的声明以及初始化的形式也有许多, 常用的有以下几种形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;             <span class="comment">//声明一个 int 型向量 a</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);         <span class="comment">//声明一个初始大小为 10 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>, <span class="number">1</span>);      <span class="comment">//声明一个初始大小为 10 且初始值都为 1 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a);          <span class="comment">//声明并用向量 a 初始化向量 b </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+<span class="number">3</span>); <span class="comment">//将a向量中从第0个到第2个(共3个)作为向量b的初始值</span></span><br></pre></td></tr></table></figure></typename></p><p>除此之外, 还可以直接使用数组来初始化向量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n, n+<span class="number">5</span>) ;      <span class="comment">//将数组 n 的前 5 个元素作为向量 a 的初值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n+<span class="number">1</span>, n+<span class="number">4</span>) ;    <span class="comment">//将 n[1]-n[4] 范围内的元素作为向量 a 的初值</span></span><br></pre></td></tr></table></figure></p><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const T&amp; x);   //向量尾部增加一个元素X</span><br><span class="line">void pop_back();   //删除向量中最后一个元素</span><br><span class="line"></span><br><span class="line">插入 - insert</span><br><span class="line">iterator insert(iterator it,const T&amp; x);     //向量中迭代器指向元素前增加一个元素x</span><br><span class="line">// vec.insert(vec.begin()+i,a);     在第i+1个元素前面插入a;</span><br><span class="line">vec.insert(a.begin(), 1000);            //将1000插入到向量a的起始位置前</span><br><span class="line">vec.insert(a.begin(), 3, 1000) ;        //将1000分别插入到向量元素位置的0-2处(共3个元素)</span><br><span class="line">b.insert(b.begin(), a.begin(), a.end()) ;   //将a.begin(), a.end()之间的全部元素插入到b.begin()前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除 - erase</span><br><span class="line">iterator erase(iterator it);  //删除向量中迭代器指向元素</span><br><span class="line">// vec.erase(vec.begin()+2);  删除第3个元素</span><br><span class="line">b.erase(b.begin()) ;                     //将起始位置的元素删除</span><br><span class="line">b.erase(b.begin(), b.begin()+3) ;        //将(b.begin(),b.begin()+3)之间的元素删除</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">iterator begin();    //返回向量头指针，指向第一个元素</span><br><span class="line">iterator end();      //返回向量尾指针，指向向量最后一个元素的下一个位置</span><br><span class="line"></span><br><span class="line">int size() const;    //返回向量中元素的个数</span><br><span class="line">void clear();        //清空向量中所有元素</span><br><span class="line">bool empty() const;  //判断向量是否为空，若为空，则向量中无元素</span><br></pre></td></tr></table></figure><p><strong>迭代</strong><br>使用迭代器将容器中数据输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it; </span><br><span class="line">auto it  //上面的简写</span><br><span class="line">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span><br><span class="line">for(it=v.begin(); it!=v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>v.end()</strong> 指向容器器的最后一个元素的后⼀个位置。</p><p><strong>排序</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(),vec.end());    <span class="comment">//默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想 sort 来降序，可重写 sort </span></span><br><span class="line">sort(a,a+n,compare);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a&lt; b;</span><br><span class="line">    <span class="comment">//升序排列，如果改为 return a &gt; b，则为降序 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">reverse(obj.begin(),obj.end()); <span class="comment">//从大到小</span></span><br></pre></td></tr></table></figure></p><p><strong>二维数组</strong></p><ul><li>声明了一个动态二维数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br></pre></td></tr></table></figure><ul><li>先定义好二维数组结构，再直接赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//得到一个 5 行 3 列的数组</span></span><br><span class="line"><span class="comment">//由 vector 实现的二维数组，可以通过 resize() 的形式改变行、列值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">    <span class="built_in">array</span>[i].resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>固定一维的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br></pre></td></tr></table></figure><p>上式类似声明了一个二维数组，第一维的大小是固定的（不超过maxn），但第二维的大小不固定。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用 vector 需要注意以下几点：</p><ul><li>如果要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低。</li><li>vector 作为函数的参数或者返回值时，需要注意它的写法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"> <span class="comment">// “&amp;”绝不可少。</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://blog.csdn.net/duan19920101/article/details/50617190" target="_blank" rel="noopener">C++ 中vector的使用方法</a></li><li><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" rel="noopener">学习C++ -&gt; 向量(vector)</a></li><li><a href="https://blog.csdn.net/w_linux/article/details/71600574" target="_blank" rel="noopener">C++（笔记）浅析vector容器的实例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vector-介绍&quot;&gt;&lt;a href=&quot;#vector-介绍&quot; class=&quot;headerlink&quot; title=&quot;vector 介绍&quot;&gt;&lt;/a&gt;vector 介绍&lt;/h4&gt;&lt;p&gt;vector 是表示可以改变大小的数组的序列容器。&lt;/p&gt;
&lt;p&gt;vector 能够容纳许多其他类型相同的元素,因此又被称为&lt;strong&gt;容器&lt;/strong&gt;。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够&lt;strong&gt;存放任意类型的动态数组&lt;/strong&gt;，能够增加和压缩数据。&lt;/p&gt;
&lt;p&gt;与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.顺序序列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.动态数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.能够感知内存分配器的（Allocator-aware）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容器使用一个内存分配器对象来动态地处理它的存储需求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="vector" scheme="https://hongbosherlock.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>malloc 和 memset 总结</title>
    <link href="https://hongbosherlock.github.io/2019/06/08/malloc/"/>
    <id>https://hongbosherlock.github.io/2019/06/08/malloc/</id>
    <published>2019-06-08T12:57:28.000Z</published>
    <updated>2021-01-18T10:30:19.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc()函数"></a>malloc()函数</h3><h4 id="1、函数原型及说明："><a href="#1、函数原型及说明：" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：#include <stdlib.h></stdlib.h></p><p>malloc() 函数用来动态地分配内存空间其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明:</strong></p><ul><li>size 为需要分配的内存空间的大小，以字节（Byte）计。</li><li>size -t 是无符号整数类型。</li></ul><p><strong>函数说明:</strong><br>malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。<br>这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。<br>如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。</p><a id="more"></a><p><strong>返回值:</strong><br>分配成功返回指向该内存的地址，失败则返回NULL。<br>关于分配失败的原因，应该有多种，比如说空间不足就是一种。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void free(void *FirstByte)：</span><br></pre></td></tr></table></figure><p>该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。</p><h4 id="2、函数的用法："><a href="#2、函数的用法：" class="headerlink" title="2、函数的用法："></a>2、函数的用法：</h4><p>向malloc申请的空间的⼤大⼩小是以字节为单位的。</p><ul><li>返回的结果是void*，需要类型转换为自己需要的类型 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* num;</span><br><span class="line">num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><p>程序示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc example: random string generator*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      /* printf, scanf, NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     /* malloc, free, rand */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,n;</span><br><span class="line">  <span class="keyword">char</span> * buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"How long do you want the string? "</span>);</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">  buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span> (i+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer==<span class="literal">NULL</span>) <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;i; n++)</span><br><span class="line">    buffer[n]=rand()%<span class="number">26</span>+<span class="string">'a'</span>;</span><br><span class="line">  buffer[i]=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"Random string: %s\n"</span>,buffer);</span><br><span class="line">  <span class="built_in">free</span> (buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序生成一个由用户指定的长度的字符串，由字母字符组成。此字符串的可能长度仅受malloc可用内存量的限制。</p><h4 id="3、注意事项："><a href="#3、注意事项：" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>malloc的返回值是一个指针，指向一段可用内存的起始地址。</li><li>申请了内存空间后，必须检查是否分配成功。</li><li>当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。</li><li>malloc() 和 free() 这两个函数应该配对。如果申请后不释放会出现内存泄露</li><li>虽然malloc()函数的类型是(void<em>),任何类型的指针都可以转换成(void </em>),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。</li></ul><h3 id="memset-函数"><a href="#memset-函数" class="headerlink" title="memset()函数"></a>memset()函数</h3><h4 id="1、函数原型及说明：-1"><a href="#1、函数原型及说明：-1" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：#include <string.h></string.h></p><p>memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span><span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明：</strong></p><ul><li>ptr 为要操作的内存的指针。</li><li>value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。（最终解释为 unsigned char)</li><li>num 为 ptr 的前 num 个字节。</li><li>size_t 就是unsigned int。</li></ul><p><strong>函数说明:</strong>  memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。</p><p><strong>返回值:</strong>   返回指向 ptr 的指针。</p><h4 id="2、函数用法："><a href="#2、函数用法：" class="headerlink" title="2、函数用法："></a>2、函数用法：</h4><p>memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(str)<span class="number">-1</span>); <span class="comment">// 0或者'\0'是等价的</span></span><br></pre></td></tr></table></figure></p><p>对整型数组初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* num;</span><br><span class="line">num = (int*)malloc( n*sizeof(int) );</span><br><span class="line">memset(num,0,n*sizeof(int) );</span><br></pre></td></tr></table></figure></p><h4 id="3、注意事项：-1"><a href="#3、注意事项：-1" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>memset() 中的第三个参数一定要使用 sizeof 操作符，因为每个系统下对类型长度的定义可能不一样。</li><li>memset() 中的第一个参数一定要是一个已知的、已经被分配内存的地址，否则会出错。</li></ul><ul><li><strong>最重要的一点：</strong> 对于单字节数据类型（char）可以初始化为任意支持的值，多字节数据类型只能初始化为 0。</li></ul><p><strong>原因：</strong></p><p>memset是按照字节对待初始化空间进行初始化的，也就是说，函数里面的第二个参数的那个初值（一般为0）是按照一个个字节往第一个参数所指区域赋值的，所以，对于单字节数据类型（char）可以初始化为任意支持的值，都没有问题。</p><p>但是对于多字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。如果将 int 类型数组初始化为1，那么因为int一般是4个字节，那么相当于将一个int元素初始化成了 <strong>0000 0001 0000 0001 0000 0001 0000 0001</strong>，<br>这样对于一个int元素肯定不是1，而是一个很大的数，结果出乎意料。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" target="_blank" rel="noopener">malloc和free函数详解</a></li><li><a href="https://blog.csdn.net/dan15188387481/article/details/49621447" target="_blank" rel="noopener">透彻分析C/C++中memset函数</a></li><li><a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc -C++ Reference</a></li><li><a href="http://www.cplusplus.com/reference/cstring/memset/" target="_blank" rel="noopener">memset -C++ Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;malloc-函数&quot;&gt;&lt;a href=&quot;#malloc-函数&quot; class=&quot;headerlink&quot; title=&quot;malloc()函数&quot;&gt;&lt;/a&gt;malloc()函数&lt;/h3&gt;&lt;h4 id=&quot;1、函数原型及说明：&quot;&gt;&lt;a href=&quot;#1、函数原型及说明：&quot; class=&quot;headerlink&quot; title=&quot;1、函数原型及说明：&quot;&gt;&lt;/a&gt;1、函数原型及说明：&lt;/h4&gt;&lt;p&gt;头文件：#include &lt;stdlib.h&gt;&lt;/stdlib.h&gt;&lt;/p&gt;
&lt;p&gt;malloc() 函数用来动态地分配内存空间其原型为：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;malloc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size 为需要分配的内存空间的大小，以字节（Byte）计。&lt;/li&gt;
&lt;li&gt;size -t 是无符号整数类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数说明:&lt;/strong&gt;&lt;br&gt;malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。&lt;br&gt;这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。&lt;br&gt;如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="malloc" scheme="https://hongbosherlock.github.io/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>STL 简介</title>
    <link href="https://hongbosherlock.github.io/2019/05/26/stl/"/>
    <id>https://hongbosherlock.github.io/2019/05/26/stl/</id>
    <published>2019-05-26T11:40:15.000Z</published>
    <updated>2021-01-18T10:31:59.529Z</updated>
    
    <content type="html"><![CDATA[<p>STL (Standard Template Library) 标准模板库</p><p>需要引入头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="排序算法sort"><a href="#排序算法sort" class="headerlink" title="排序算法sort"></a>排序算法sort</h3><h4 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h4><p>对基本类型的数组从小到大排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2);</span><br></pre></td></tr></table></figure></p><p>n1 和 n2 都是 int 类型的表达式，可以包含变量。<br>将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。</p><a id="more"></a><h4 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h4><p>对元素类型为 T的基本类型数组从大到小排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, greater&lt;T&gt;());</span><br></pre></td></tr></table></figure></p><h4 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h4><p>用自定义的排序规则，对任何类型 T 的数组排序，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>排序规则结构的定义方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  T &amp;a1, <span class="keyword">const</span> T &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若 a1 应该在 a2 前面，则返回 true。</span></span><br><span class="line">        <span class="comment">//否则返回 false。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>排序规则返回 true ，意味着 a1 必须在 a2 前面。<br>返回 false ，意味着 a1 并非必须在 a2 前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//从大到小排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1 &gt; a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按个位数从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a1%<span class="number">10</span> &lt; a2%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对结构体数组进行排列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按姓名从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stricmp(s1.name&lt;s2.name)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按 id 从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><p>STL 提供在排好序的数组上进行二分查找的算法。</p><h4 id="用法一-1"><a href="#用法一-1" class="headerlink" title="用法一"></a>用法一</h4><p>在从小到大排好序的基本类型数组上进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值);</span><br></pre></td></tr></table></figure></p><p>查找区间为下标范围为 [n1,n2) 的元素，下标为 n2 的元素不在排列区间内。</p><p>在该区间内查找 “等于值”的元素，返回为true(找到）或 false（没找到）。</p><h4 id="用法二-1"><a href="#用法二-1" class="headerlink" title="用法二"></a>用法二</h4><p>在用自定义排序规则排好序的、元素为任意的 T 类型的数组中进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>查找时的排序规则，必须和<strong>排序时</strong>(sort函数)的规则一致。</p><p>二分查找实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在包含 size 个元素的 、从小到大排序的 int 数组 a里查找元素 p, 如果找到，则返回元素下标，如果找不到，则返回-1。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>; <span class="comment">//左端点 </span></span><br><span class="line"><span class="keyword">int</span> R=size<span class="number">-1</span>; <span class="comment">//右端点</span></span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=L+(R-L)/<span class="number">2</span>; <span class="comment">//防止 L+R 过大溢出</span></span><br><span class="line"><span class="keyword">if</span>(a[mid]==p)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p&gt;a[mid])</span><br><span class="line">L=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">R=mid<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p>求下面方程的 一个 根： $f(x) =x^3-5x^2+10x-80 = 0$<br>若求出的根是 a，则要求 $|f(a)| &lt;= 10^-6$</p><ul><li>解法：对 f(x) 求导，得 $f’(x)=3x^2-10x+10$ 。由一元二次方程 求根公式知f’(x)= 0 无解，因此 f’(x) 恒大于 0。故f(x) 是单调递增的 。易知 f(0) &lt; 0 且 f(100)&gt;0,,所以 区间 [0,100]内必然有且只一个根 。由于 f(x) 在[0,100]内是单调的，所以可用二分办法在区间  [0,100]中寻找根。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ESP = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x*x<span class="number">-5</span>*x*x+<span class="number">10</span>*x<span class="number">-80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> root,y;</span><br><span class="line"><span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;</span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fabs</span>(y)&gt;ESP)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">x2=root;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x1=root;</span><br><span class="line"></span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>,root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>寻找指定和的整数对<br>输入 n ( n&lt;= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯定有解 )。题中所有整数都能用int 表示。</p><ul><li>解法一<br>1)将数组排序，复杂度是O(n x log(n))<br>2)对数组中的每个元素a[i],在数组中二分查找m-a[i]，看能否找到。复杂度log(n)，最坏要查找n-2次，所以查找这部分的复杂度也是 O(n ×log(n))</li><li>解法二<br>1)将数组排序，复杂度是O(n x log(n))<br>2)查找的时候，设置两个变量 i 和 j，i 初值是 0，j 初值是 n-1。看 a[i]+a[j],如果大于 m，则j-1，如果小于m就让 i+1。直到 a[i]+a[j] = m。</li></ul><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><p><strong>Aggressive cows</strong><br>总时间限制: 1000ms   内存限制: 65536kB</p><p><strong>描述</strong><br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p><p><strong>输入</strong></p><ul><li>Line 1: Two space-separated integers: N and C</li><li>Lines 2..N+1: Line i+1 contains an integer stall location, xi</li></ul><p><strong>输出</strong></p><ul><li>Line 1: One integer: the largest minimum distance</li></ul><p><strong>样例输入</strong></p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>3</p></blockquote><p><strong>提示</strong><br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p><strong>思路</strong></p><ul><li>先得到排序后的隔间坐标 x1,…,xN</li><li>在 [L,R] 内用二分法尝试“最大最近距离”，D=(L+R)/2,(L,R初值为[1,1000000000/C])</li><li>若 D 可行，则记录该 D，然后在新的 [L,R] 中继续尝试。(L = D+1)。          若 D 不行，则在新 [L,R] 中继续尝试。( R = D-1)</li></ul><p>尝试方法：</p><ul><li>第一头牛放在x1</li><li>若第 k 头牛放在 xi，则找到x（i+1）到 xN 中第一个位于[xi+D,1000000000]中的xj，第 k+1 头牛放在 xj。找不到这样的 xj，则说明不可行。</li></ul><p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> N,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t,s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sort(a,a+N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R=MAX/C;</span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">D = L+(R-L)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]-a[pre]&gt;=D)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=i;</span><br><span class="line">             t++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t&gt;=C)&#123;</span><br><span class="line"></span><br><span class="line">s=D;</span><br><span class="line">L=D+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">R=D<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL (Standard Template Library) 标准模板库&lt;/p&gt;
&lt;p&gt;需要引入头文件：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序算法sort&quot;&gt;&lt;a href=&quot;#排序算法sort&quot; class=&quot;headerlink&quot; title=&quot;排序算法sort&quot;&gt;&lt;/a&gt;排序算法sort&lt;/h3&gt;&lt;h4 id=&quot;用法一&quot;&gt;&lt;a href=&quot;#用法一&quot; class=&quot;headerlink&quot; title=&quot;用法一&quot;&gt;&lt;/a&gt;用法一&lt;/h4&gt;&lt;p&gt;对基本类型的数组从小到大排序：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sort(数组名+n1, 数组名+n2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;n1 和 n2 都是 int 类型的表达式，可以包含变量。&lt;br&gt;将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="STL" scheme="https://hongbosherlock.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="https://hongbosherlock.github.io/2019/05/15/struct/"/>
    <id>https://hongbosherlock.github.io/2019/05/15/struct/</id>
    <published>2019-05-15T13:28:41.000Z</published>
    <updated>2021-01-17T15:04:40.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>声明结构的形式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span>       <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                   <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                  <span class="comment">//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>对于第⼀和第二种形式，都声明了结构point。但是第三种形式没有声明point，只是定义了两个变量。</p><p>一般来说，一个结构变量所占的内存空间的大小就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。</p><ul><li><p>访问变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br><span class="line">p1.y</span><br></pre></td></tr></table></figure></li><li><p>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• p1 = (struct point)&#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 相当于p1.x = 5;p1.y = 10;</span></span><br><span class="line">• p1 = p2;</span><br><span class="line"><span class="comment">// 相当于p1.x = p2.x; p1.y = p2.y;</span></span><br></pre></td></tr></table></figure></li><li><p>结构体指针</p></li></ul><p>和数组不同，结构变量的名字并不是结构变量的地址，必须使⽤用&amp;运算符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">p</span> = &amp;<span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure></p><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>（1）结构体作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(struct point p)</span></span></span><br></pre></td></tr></table></figure><p>• 整个结构可以作为参数的值传⼊入函数</p><p>• 这时候是在函数内新建⼀一个结构变量，并复制调⽤用者的结构的值</p><p>• 也可以返回⼀一个结构</p><p><strong>注意</strong>：传⼊入结构和传⼊数组是不同的：</p><ul><li>函数参数传入的是数组的引用。</li><li>传入结构时，传入的是结构体的拷贝。</li></ul><p>（2）结构指针作为参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct point *p = &amp;p1;</span><br><span class="line">(*p).x = 2;</span><br><span class="line">p-&gt;x = 2;</span><br></pre></td></tr></table></figure></p><p>⽤用<strong>-&gt;</strong>表⽰示指针所指的结构变量中的成员</p><p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct point* <span class="title">inputPoint</span><span class="params">(struct point* p)</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(p-&gt;x),&amp;(p-&gt;y));        </span><br><span class="line"><span class="comment">// 同 (*p).x 和 (*p).y</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(struct point p)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span>=&#123;</span><span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">inputPoint(&amp;y);</span><br><span class="line">output(y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• 好处是传⼊传出只是一个指针的大小。</p><p>• 如果需要保护传入的结构不被函数修改。</p><ul><li>const struct point *p</li></ul><p>• 返回传⼊的指针是一种套路。</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[100];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[]=&#123;</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明结构的形式：&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;p1&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;p2&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                   &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                  &lt;span class=&quot;comment&quot;&gt;//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="结构体" scheme="https://hongbosherlock.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>函数和字符串</title>
    <link href="https://hongbosherlock.github.io/2019/05/10/string/"/>
    <id>https://hongbosherlock.github.io/2019/05/10/string/</id>
    <published>2019-05-10T10:28:32.000Z</published>
    <updated>2021-01-17T15:05:09.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一维数组作为形参时的写法如下：</p><ul><li>类型名 数组名 []</li></ul><p>数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。</p><p>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。</p><p>二维数组作为函数形参时，必须写明函数有多少列</p><ul><li>类型名 数组名 [][N]   N为列数</li></ul><a id="more"></a><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>&#125;          <span class="comment">//字符数组</span></span><br><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'\0'</span>&#125;     <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure><p>0标志字符串的结束，是字符数组的一部分，但它不是字符串的⼀部分。</p><ul><li>计算字符串⻓长度的时候不包含这个0</li></ul><p>常见的字符串声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• <span class="keyword">char</span> *str = “Hello”;             <span class="comment">//字符串常量，不可修改</span></span><br><span class="line">• <span class="keyword">char</span> word[] = “Hello”;           <span class="comment">//可修改</span></span><br><span class="line">• <span class="keyword">char</span> line[<span class="number">10</span>] = “Hello”;         <span class="comment">//数组大小为6</span></span><br></pre></td></tr></table></figure></p><p>C语⾔言的字符串是以字符数组的形态存在的，″Hello″会被编译器变成⼀个字符数组放在某处，这个数组的长度是6，结尾还有表⽰示结束的0。</p><ul><li>如果要构造⼀一个字符串—&gt;数组</li><li>如果要处理⼀一个字符串—&gt;指针</li></ul><p><strong>声明一个空字符串</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str;          <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"\0"</span>;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">""</span>;    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p>str 是一个空字符串，str[0] == ‘\0’.</p><p>数组 str 的长度为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%<span class="number">7</span>s”, str);</span><br></pre></td></tr></table></figure></p><ul><li>在%和s之间的数字表⽰示最多允许读⼊入的字符的数量，这个数字应该⽐比数组的大小⼀</li><li>scanf 会自动添加结尾的’\0’</li><li><p>scanf 和 cin 读入到空格为止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型 ：gets(char buf[] )</span></span><br><span class="line"><span class="keyword">while</span>( gets(str) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure></li><li><p>读入一行，自动添加 ‘\0’.</p></li><li>回车换行符不会写入 buf，但是会从输入流中去掉。</li></ul><p><strong>字符串数组</strong></p><ul><li>char **a</li></ul><p> a是⼀一个指针，指向另⼀一个指针，那个指针指向⼀一个字符（串）</p><ul><li>char a[][]</li></ul><p>a是⼀一个⼆二维数组，第⼆二个维度的⼤大⼩小不知道，不能编译</p><ul><li>char a[][10]</li></ul><p>a是⼀一个⼆二维数组，a[x]是⼀一个char[10]</p><ul><li>char *a[]</li></ul><p>a是⼀一个⼀一维数组，a[x]是⼀一个char*</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>getchar()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getchar(void);</span><br></pre></td></tr></table></figure></p><ul><li>从标准输⼊入读⼊一个字符</li><li>返回类型是int是为了返回EOF（-1）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=EOF)&#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="库函数-string-h"><a href="#库函数-string-h" class="headerlink" title="库函数 string.h"></a>库函数 string.h</h4><p><strong>strcmp</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure></p><p>比较两个字符串，返回：</p><ul><li><strong>0 : s1==s2</strong></li><li><strong>&gt;0 : s1&gt;s2</strong></li><li><strong>&lt;0 : s1&lt;s2</strong></li></ul><p><strong>strcnmp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strncmp(const char *s1, const char *s2, int  n);</span><br></pre></td></tr></table></figure></p><p>比较 s1 前 n 个字符组成的子串和 s2 前 n 个字符组成的子串的大小。</p><ul><li>若长度不足 n，则取整个串作为子串。返回值和 strcmp 类似。</li></ul><p><strong>strcpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char *restrict dst, const char *restrict src);</span><br></pre></td></tr></table></figure></p><ul><li>把 src 的字符串拷⻉贝到 dst</li><li>restrict 表明 src 和 dst 不重叠（C99）</li></ul><p><strong>strncpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strncpy(char *restrict dst, const char *restrict src, int n);</span><br></pre></td></tr></table></figure></p><p>拷贝 src 的前 n 个字符到 dest。</p><ul><li>如果 src 长度大于或等于 n，该函数不会自动往 dest 中写入’\0’；若</li><li>若 src 长度不足 n，则拷贝 src 的全部内容以及结尾的’\0’到 dest。</li></ul><p><strong>strcat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcat(char *restrict s1, const char *restrict s2);</span><br></pre></td></tr></table></figure></p><ul><li>把s2拷⻉贝到s1的后⾯面，接成⼀一个⻓长的字符串</li><li>返回s1</li><li>s1必须具有⾜足够的空间</li></ul><h5 id="字符串中找字符："><a href="#字符串中找字符：" class="headerlink" title="字符串中找字符："></a>字符串中找字符：</h5><p><strong>strchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strchr(const char *str, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>第一次</strong>出现的位置。</p><ul><li>如果找到，就返回指向该位置的 char* 指针</li><li>若没找到，返回 NULL</li></ul><p><strong>strrchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strrchr(const char *s, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>最后一次</strong>出现的位置。</p><h5 id="字符串中找字符串："><a href="#字符串中找字符串：" class="headerlink" title="字符串中找字符串："></a>字符串中找字符串：</h5><p><strong>strstr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strstr(const char *s1, const char *s2);</span><br></pre></td></tr></table></figure></p><p>寻找子串 s2 在 s1 中第一次出现的位置。</p><ul><li>如果找到，就返回指向该位置的指针。</li><li>若没找到，返回 NULL<br><strong>源码</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len2;</span><br><span class="line">　　<span class="keyword">if</span> ( !(len2 = <span class="built_in">strlen</span>(s2)) )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;   <span class="comment">//字符串为空</span></span><br><span class="line">　　<span class="keyword">for</span> ( ; *s1; ++s1 )</span><br><span class="line">　&#123;</span><br><span class="line">　　<span class="keyword">if</span> ( *s1 == *s2 &amp;&amp; <span class="built_in">strncmp</span>( s1, s2, len2 )==<span class="number">0</span> )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;</span><br><span class="line">　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h5><p><strong>strtok</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strtok( char *str, const char *delim);</span><br></pre></td></tr></table></figure></p><p>连续调用该函数若干次，可以做到：从 str 中逐个抽取被字符串 delim 中的字符分隔开的若干字符串。</p><hr><h4 id="判断子串的函数"><a href="#判断子串的函数" class="headerlink" title="判断子串的函数"></a>判断子串的函数</h4><p> <strong>描述:</strong></p><p> 编写一个函数：</p><blockquote><p>int Strstr( char s1[], char s2[]);</p></blockquote><p>如果 s2 不是 s1 的子串，返回 -1,如果 s2 是 s1 的子串，返回在 s1 中第一次出现的位置。空串是任何串的子串，且出现位置为 0.</p><p> <strong>代码:</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;bits/stdc++.h&gt; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Strstr(const char* s1, const char* s2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(s2[0]==0)</span><br><span class="line">return 0;</span><br><span class="line">for(int i=0;s1[i];i++)&#123;</span><br><span class="line">int k=i;</span><br><span class="line">int j=0;</span><br><span class="line">for(;s2[j];j++,k++)&#123;</span><br><span class="line">if(s1[k]!=s2[j])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(s2[j]==0)</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">char s1[50];</span><br><span class="line">gets(s1);</span><br><span class="line"></span><br><span class="line">char s2[20];</span><br><span class="line">gets(s2);</span><br><span class="line"></span><br><span class="line">int f;</span><br><span class="line">f = Strstr(s1,s2);</span><br><span class="line">cout&lt;&lt;f;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;一维数组作为形参时的写法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 []&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。&lt;/p&gt;
&lt;p&gt;数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。&lt;/p&gt;
&lt;p&gt;二维数组作为函数形参时，必须写明函数有多少列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 [][N]   N为列数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="字符串" scheme="https://hongbosherlock.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="https://hongbosherlock.github.io/2019/05/05/pointer/"/>
    <id>https://hongbosherlock.github.io/2019/05/05/pointer/</id>
    <published>2019-05-05T04:27:07.000Z</published>
    <updated>2021-01-18T10:30:34.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1、 &amp; 不能对没有地址的东西取址。</p><p>2、指针是能够保存地址的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"><span class="keyword">int</span>* p,q;    <span class="comment">// p 是 int* 类型的指针，大小为8；q 是 int 整数，大小为4。</span></span><br><span class="line"><span class="keyword">int</span> *p,q;    <span class="comment">// p 是 int* 类型的指针，q 是 int 整数。       </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p,*q;   <span class="comment">// p 和 q 都是 int* 类型的指针。</span></span><br></pre></td></tr></table></figure></p><p>这说明指针也有内存地址，而且指针变量的值就是其他变量的内存地址。</p><a id="more"></a><p>3、* 是一个单目运算符, 用来访问指针的值所表示的地址上的变量。</p><ul><li><p>可以做右值也可以做左值</p><p> • int k = *p;</p><p> • *p = k+1;</p></li></ul><p>互相反作⽤：</p><ul><li><em>&amp;yptr -&gt; </em> (&amp;yptr) -&gt; * (yptr的地址)-&gt; 得到那个地址上的变量 -&gt; yptr</li><li>&amp;<em>yptr -&gt; &amp;(</em>yptr) -&gt; &amp;(y) -&gt; 得到y的地址，也就是yptr -&gt; yptr</li></ul><p>4、<strong>应用场景一：</strong><br>交换两个变量的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用指针之前要初始化。</p><p>5、 以下四种函数原型是等价的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">• <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>6、指针与const<br><img src="http://ww1.sinaimg.cn/large/006w4HKkly1g2pjx2gpzcj30px070jrq.jpg" alt=""></p><p>（1）指针是const：<br> 一旦得到某个变量的地址，不能再指向其他变量。</p><p>（2）所指内容是const<br> 表⽰示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;i;    <span class="comment">//p1所指是const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;i;    <span class="comment">//p2所指是const， const在 * 的前面</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;i;    <span class="comment">//指针 p3 是const， const 在 * 的后面</span></span><br></pre></td></tr></table></figure><p>7、 const数组</p><ul><li>const int a[] = {1,2,3,4,5,6,};</li><li>数组变量已经是const的指针了，这⾥里的 const 表明数组的每个单元都是 const int</li><li>所以必须通过初始化进⾏行赋值</li></ul><p>8、保护数组</p><ul><li>把数组传⼊入函数时传递的是地址，则那个函数内部可以修改数组的值</li><li>为了保护数组不被函数破坏，可以设置参数为const</li><li>int sum(const int a[], int length);</li></ul><p>9、指针运算<br>(1) *p++</p><ul><li>取出p所指的那个数据来，完事之后顺便把 p 移到下⼀一个位置去</li><li>*的优先级虽然⾼高，但是没有 ++ ⾼高</li></ul><p>(2) 两个同类型的指针变量可以相加减:</p><ul><li>两个 T* 类型的指针 p1,p2 </li><li>p1 - p2 = (地址 p1 - 地址 p2)/sizeof(T)</li></ul><p>(3) 指针变量加减一个整数的结果是指针:<br> p : T* 类型的指针<br> n ：整数<br> p + n : 指向地址 ：地址 p + sizeof(T)</p><p>(4)可以用“ NULL”关键字对任何类型的指针进行赋值。NULL实际上就是整数 0, 值为 NULL的指针 就是空指针。</p><p>(5) 指针的用处</p><ul><li>需要传⼊入较⼤大的数据时⽤用作参数</li><li>传⼊入数组后对数组做操作</li><li><p>函数返回不⽌止⼀一个结果</p><p>• 需要⽤用函数来修改不⽌止⼀一个变量</p><p>(6)动态内存分配<br>C99可以⽤用变量做数组定义的⼤大⼩小，C99之前呢？</p></li><li>int <em>a = (int</em>)malloc(n*sizeof(int));</li></ul><p>如果申请失败则返回0，或者叫做NUL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free()</span><br></pre></td></tr></table></figure></p><ul><li>把申请得来的空间还给“系统”。</li><li>只能还申请来的空间的⾸首地址。</li></ul><p>memset()函数：将内存的前n个字节设置为特定的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将数组 a 置 0。</span><br><span class="line">memset(a,0,sizeof(a))</span><br></pre></td></tr></table></figure></p><p>10、指针与数组<br>数组的名字是一个指针常量，指向数字的起始地址。</p><h3 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h3><p>1、二维数组</p><p> T a[M][N];</p><ul><li>a[i] 是一个一维数组。</li><li>列数 N必须给出，行数 M可以不给，由编译器给出。</li><li><strong>a[i] 的类型是 T*</strong></li><li>a[i] 指向的地址：数组 a 的起始地址 + i × N × sizeof(T)</li></ul><p>2、指向指针的指针</p><ul><li>T <em>*p;<br>p是指向指针的指针， p指向的地方应该存放着一个类型为 T </em> 的指针。<br><em>p 的类型是 T </em><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **pp;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">1234</span>;</span><br><span class="line">p=&amp;n;</span><br><span class="line">pp=&amp;p;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(*pp));</span><br></pre></td></tr></table></figure></li></ul><p>3、指针和字符串<br>字符串常量的类型就是 char <em><br>字符数组名的类型也是 char </em> </p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>将函数的入口地址赋给一个指针变量，使该指针变量向函数。然后通过变量就可以调用这个函数。种指向的指针变量称为“ 函数指针 ”。<br>类型名 (* 指针变量名 )( 参数类型 1, 参数类型 2,…);<br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  (* pf )(<span class="keyword">int</span> ,<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure></p><p>表示 pf 是一个函数指针，它所向的返回值类型应是int，该函数应有两个参数，第一是 int  类型，第二个是 char 类型。</p><h5 id="函数指针和-qsort-函数"><a href="#函数指针和-qsort-函数" class="headerlink" title="函数指针和 qsort 函数"></a>函数指针和 qsort 函数</h5><p>c 语言快速排序库函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span> <span class="params">( <span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</span></span></span><br><span class="line">int (*pfCompare)(const void *, const void *));</span><br></pre></td></tr></table></figure></p><p>可以对任意类型的数组进行排序。</p><p><img src="http://ww1.sinaimg.cn/mw690/006w4HKkly1g2x6lgm2isj30wc0jognz.jpg" alt=""></p><p>pfCompare: 函数指针，它指向一个“比较函数”。该比较函数应为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 函数名 (const void *elem1, const void *elem2);</span><br></pre></td></tr></table></figure></p><p>比较函数是由我们自定义的。</p><p>比较函数编写规则：<br>1) 如果 <em> elem1 应该排在 </em> elem2  <strong>前面</strong> ，则函数返回值是<strong>负整数</strong>。<br>2) 如果 <em> elem1和</em> elem2 哪个排在前面都行，那么函数返回0<br>3) 如果 <em> elem1 应该排在 </em> elem2 <strong>后面</strong> ，则函数返回值是<strong>正整数</strong>。</p><p>下面的程序，功能是调用 qsort qsortqsort库函数，将一个 库函数，将一个 unsigned int unsigned int unsigned int 数组按 照个位数从小到大进行排序。比如 8，23 ，15 三个数，按位从小到 三个数，按位从小到 大排序，就应该是 23 ，15 ，8<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* elem1, <span class="keyword">const</span> <span class="keyword">void</span>* elem2)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *p1,*p2;</span><br><span class="line">p1 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*) elem1;</span><br><span class="line">p2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*) elem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (*p1%<span class="number">10</span>)-(*p2%<span class="number">10</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[num]=&#123;<span class="number">8</span>,<span class="number">123</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>&#125;;</span><br><span class="line">qsort(a,num,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),myCompare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;1、 &amp;amp; 不能对没有地址的东西取址。&lt;/p&gt;
&lt;p&gt;2、指针是能够保存地址的变量。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p = &amp;amp;i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p,q;    &lt;span class=&quot;comment&quot;&gt;// p 是 int* 类型的指针，大小为8；q 是 int 整数，大小为4。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p,q;    &lt;span class=&quot;comment&quot;&gt;// p 是 int* 类型的指针，q 是 int 整数。       &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p,*q;   &lt;span class=&quot;comment&quot;&gt;// p 和 q 都是 int* 类型的指针。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这说明指针也有内存地址，而且指针变量的值就是其他变量的内存地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="https://hongbosherlock.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>SCUNET使用IPv6的方法</title>
    <link href="https://hongbosherlock.github.io/2019/04/17/ipv6/"/>
    <id>https://hongbosherlock.github.io/2019/04/17/ipv6/</id>
    <published>2019-04-17T12:27:29.000Z</published>
    <updated>2019-04-22T11:47:16.815Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006w4HKkgy1g260sx6ajpj32220opkch.jpg" alt=""></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前我一直是在 vps 上自搭梯子来科学上网（Do+ssr），虽说网速挺快，也能触达大部分网站。但还有一类网站无法访问，那就是 IPv6 网站。我曾经在 Ubuntu 下折腾了很久，都没有成功用上我的 ssr。最后看网上的教程，接入 IPv6 网络（开启 Teredo 隧道）<a id="more"></a>，修改了 hosts 文件，再配合<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">XX-Net</a>一起食用,又恢复了原来的 freedom。关于 Ubuntu 下如何科学上网，抽个时间单独写一篇吧。逃:）</p><p>相比 Ubuntu，win 就不那么友好了。我在校园网、寝室电信、家里的电信网络环境里，都能在 Ubuntu 下开启 IPv6 服务。但是 win 复杂的配置让我摸不着头脑（好吧，其实是我不懂），就一直没能在 win 上体验过 IPv6 的便捷。网上已经有人试过通过配置 vps 和服务器端的 ss(r) 来使用 IPv6 服务，方法有些麻烦，我就懒得折腾了。正好前几天权游第八季开播，这么火的剧我还没看过一集，而且质量也很好。强哥就给我推荐了<a href="https://bt.byr.cn/login.php" target="_blank" rel="noopener">北邮人</a>,这是个 IPv6 的 BT 网站，有很多高质量的影视资源。于是，我就开始了 win 下 IPv6 的探索之旅······</p><h3 id="啥是-IPv6？"><a href="#啥是-IPv6？" class="headerlink" title="啥是 IPv6？"></a>啥是 IPv6？</h3><p>别说 IPv6 ，很多人可能连 <a href="https://baike.baidu.com/item/IPv4" target="_blank" rel="noopener">IPv4</a> 都不太清楚。我之前也只是听过这两个名词，直到学了<strong>计算机网络</strong>，我才逐渐揭开了 IPv6 神秘的面纱。</p><p>IPv6 是下一代因特网协议。大部分因特网使用 IPv4，而且此协议在 20 多年来被证明是可靠的、富于弹性的。然而，IPv4 也存在局限性并且随着因特网的扩展会导致许多问题。IPv6 是 IPv4 的更新版本并且它将逐渐替代 IPv4 而作为网际标准。</p><p>IPv6 地址的大小和格式使得寻址功能大为增强。</p><p>IPv6 地址大小为 128 位。首选 IPv6 地址表示法为 x:x:x:x:x:x:x:x，其中每个 x 是地址的 8 个 16 位部分的十六进制值。IPv6 地址范围从 0000:0000:0000:0000:0000:0000:0000:0000 至 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff。</p><h3 id="如何开启IPv6"><a href="#如何开启IPv6" class="headerlink" title="如何开启IPv6"></a>如何开启IPv6</h3><p> <strong>ISP 商直接提供 IPv6 支持</strong></p><blockquote><p>部分地区的运营商已开通 IPv6原生支持。比如电信运营商已经在骨干网实现了IPv6支持。</p><p>高校教育网一般已开通原生 IPv6。</p></blockquote><p><strong>通过各种隧道获取 IPv6 支持</strong></p><blockquote><p>公网ip用户：6to4 隧道</p><p>内网ip用户：<a href="https://github.com/XX-net/XX-Net/wiki/teredo" target="_blank" rel="noopener">teredo 隧道</a></p><p>未开通原生 IPv6 的教育网用户：教育网 ISATAP 隧道</p></blockquote><p>教育网用户可以通过双栈及 ISATAP 隧道的方式进行 IPv6 的访问。</p><p><strong>双栈方式</strong></p><p>所谓双栈( Dual IP Stack ),是指用户计算机及全校网络设备上同时运行 IPv4 和 IPv6 协议栈，同时支持两种协议的数据传输。在双栈开通区域，无需额外配置（ IPv6 地址 及DNS 均自动获取），只要正常认证通过，即可直接使用 IPv6 网。对于不支持双栈的区域，用户可以通过 ISATAP 隧道的方式进行IPv6的访问。</p><p><strong>ISATAP隧道方式</strong></p><p>ISATAP全名是Intra-Site Automatic Tunnel Addressing Protocol，是一种IPv6隧道技术，使用户可以在IPv4网络上访问IPv6资源。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>川大校园网已经开通了 IPv6 网络，用户可以通过双栈及 ISATAP 隧道的方式进行 IPv6 的访问。目前，望江校区、华西校区均开通了双栈方式，江安校区只有部分区域支持。</p><p>我是使用了 ISATAP 隧道方式接入了 IPv6 网络。</p><p><strong>启动</strong></p><p>Win+X 打开 CMD 或 Windows PowerShell（管理员）, 在命令行下操作。</p><p>若系统自动启用了其他隧道会影响正常访问，可选择禁用其他IPv6隧道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh interface teredo set state disable    （禁用 teredo 隧道）</span><br><span class="line">netsh interface 6to4 set state disable      （禁用 6to4 隧道）</span><br></pre></td></tr></table></figure></p><p>设定 ISATAP 路由器和启用 ISATAP 隧道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface isatap set state default</span><br><span class="line">netsh int ipv6 isatap set router 202.115.39.98  //&lt;ISATAP隧道服务器地址&gt;</span><br><span class="line">netsh int ipv6 isatap set state enabled</span><br></pre></td></tr></table></figure><p><strong>测试 IPv6 连接</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping -6 ipv6.test-ipv6.com</span><br><span class="line">ping -6 [2001:470:1:18::125]</span><br></pre></td></tr></table></figure></p><p>连接成功：</p><p><img src="http://ww1.sinaimg.cn/large/006w4HKkly1g25z8qrt14j30is05c0te.jpg" alt=""></p><p>不需要每个包都收到了，只要有包成功发送接收，就表明连通了。</p><p><strong>重置 IPv6 配置（可选）</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 reset</span><br></pre></td></tr></table></figure></p><p><strong>检查</strong></p><p>通过命令 ipconfig /all 查看当前网络信息:</p><blockquote><p>若有2001:250:2003:为前缀的IPv6地址，说明已正常连接了我校IPv6网，</p><p>若是其他前缀的IPv6地址，如FE80：或2001：0:：等开头的，说明IPv6未连通或是连接的非我校IPv6网。</p></blockquote><p><strong>如果发现掉线了：</strong></p><p>执行这3条，全禁掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh interface teredo set state disabled</span><br><span class="line">netsh interface 6to4 set state disabled</span><br><span class="line">netsh interface ipv6 isatap set state disabled</span><br></pre></td></tr></table></figure></p><p>查看teredo状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 show teredo stat</span><br></pre></td></tr></table></figure></p><p>teredo状态如下：</p><p><img src="http://ww1.sinaimg.cn/large/006w4HKkly1g25z9q03ruj30gu0593yr.jpg" alt=""></p><p>最后再重复之前的设置过程就好了。</p><p>以下操作为非必须。如果按照上述提示操作以后仍无法正常访问 IPv6 站点，可以尝试：</p><ul><li>右键点击桌面“计算机”图标，选择“管理”，展开“服务和应用程序”，选择“服务”，确认“IP Helper”服务已开启；</li><li>确认 Teredo 隧道已经关闭（管理员模式在命令行运行 netsh int teredo set state disable）；</li><li>确认原生 IPv6 已经关闭（ Internet 协议版本 6 (TCP/IPv6)前的对勾取消，位置在控制面板→网络和 Internet→网络和共享中心→更改适配器设置→双击本地连接→属性）；<br>尝试重启系统。</li></ul><h3 id="IPv6常用资源"><a href="#IPv6常用资源" class="headerlink" title="IPv6常用资源"></a>IPv6常用资源</h3><p><strong>一、IPTV</strong></p><p>清华大学：<a href="http://iptv.tsinghua.edu.cn/" target="_blank" rel="noopener">http://iptv.tsinghua.edu.cn/</a></p><p>北京邮电大学 <a href="http://tv.byr.cn/show" target="_blank" rel="noopener">http://tv.byr.cn/show</a></p><p>中国科技大学：<a href="http://tv6.ustc.edu.cn/" target="_blank" rel="noopener">http://tv6.ustc.edu.cn/</a></p><p>东北大学：<a href="http://video.neu6.edu.cn/" target="_blank" rel="noopener">http://video.neu6.edu.cn/</a></p><p>沈阳航空航天：<a href="http://dh.sau6.com/" target="_blank" rel="noopener">http://dh.sau6.com/</a></p><p>安徽农业大学：<a href="http://itv.ahau.edu.cn/" target="_blank" rel="noopener">http://itv.ahau.edu.cn/</a></p><p><strong>二、BT</strong></p><p>六维空间：<a href="http://bt.neu6.edu.cn/" target="_blank" rel="noopener">http://bt.neu6.edu.cn/</a></p><p>北邮人：<a href="http://bt.byr.cn/" target="_blank" rel="noopener">http://bt.byr.cn/</a></p><p>上大乐乎：<a href="http://bt6.shu6.edu.cn/" target="_blank" rel="noopener">http://bt6.shu6.edu.cn/</a></p><p>品知人大：<a href="http://bt.ruc6.edu.cn/" target="_blank" rel="noopener">http://bt.ruc6.edu.cn/</a></p><p><strong>三、其他</strong></p><p>Google : <a href="https://ipv6.google.com/" target="_blank" rel="noopener">https://ipv6.google.com/</a></p><p>ipv6测试 ：<a href="http://result.ds.test-ipv6.com/" target="_blank" rel="noopener">http://result.ds.test-ipv6.com/</a></p><p>ipv6论坛：<a href="http://www.ipv6forum.com/" target="_blank" rel="noopener">http://www.ipv6forum.com/</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/tuna/ipv6.tsinghua.edu.cn/blob/master/isatap.md" target="_blank" rel="noopener">ISATAP隧道</a></p><p><a href="https://github.com/XX-net/XX-Net/wiki/IPv6-Win10" target="_blank" rel="noopener">IPv6 Win10</a></p><p><a href="http://imc.scu.edu.cn/info/1012/1089.htm" target="_blank" rel="noopener">CNGI驻地网开通及IPv6使用指南</a></p><p><a href="https://www.cnblogs.com/xuanmanstein/p/7675406.html" target="_blank" rel="noopener">ping找不到主机问题</a></p><p><br></p><div style="text-align: center"><br><img src="http://ww1.sinaimg.cn/large/006w4HKkly1g2bn7p1j6uj30up0dsmyt.jpg" width="50%" height="50%" align="center"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006w4HKkgy1g260sx6ajpj32220opkch.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前我一直是在 vps 上自搭梯子来科学上网（Do+ssr），虽说网速挺快，也能触达大部分网站。但还有一类网站无法访问，那就是 IPv6 网站。我曾经在 Ubuntu 下折腾了很久，都没有成功用上我的 ssr。最后看网上的教程，接入 IPv6 网络（开启 Teredo 隧道）
    
    </summary>
    
      <category term="技术" scheme="https://hongbosherlock.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IPv6" scheme="https://hongbosherlock.github.io/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>第n小的质数</title>
    <link href="https://hongbosherlock.github.io/2019/03/08/zhishu/"/>
    <id>https://hongbosherlock.github.io/2019/03/08/zhishu/</id>
    <published>2019-03-08T08:14:21.000Z</published>
    <updated>2021-01-18T10:33:17.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>输入一个正整数n，求第n小的质数。<br><strong>输入</strong><br>一个不超过10000的正整数n。<br><strong>输出</strong><br>第n小的质数。</p><a id="more"></a><p><strong>样例输入</strong></p><blockquote><p>10</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>29</p></blockquote><p><strong>方法一</strong><br>判断一个数n是不是素数，可以用2到$\sqrt{n}$之间的所有整数去除n，看能否整除，如果都不能则n是质数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;s</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">1</span>,i,t=<span class="number">2</span>,f;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">f=<span class="number">1</span>;</span><br><span class="line">m+=<span class="number">2</span>;    <span class="comment">//偶数不是质数，步长可以加大 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=<span class="built_in">sqrt</span>(m);i=i+<span class="number">2</span>)&#123;   <span class="comment">//m是奇数，当然不能被偶数整除，步长也可以加大。</span></span><br><span class="line"><span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">  f=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="built_in">sqrt</span>(m))</span><br><span class="line"> t++;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br>筛选法求质数：把2到n中所有的数都列出来，然后从2开始，先划掉n内所有2的倍数，然后每一次从下一个剩下的数（必然是素数）开始，划掉其n内的所有倍数。最后剩下的数，都是素数。<br>以空间换时间，加快了计算速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 1000000</span></span><br><span class="line"><span class="keyword">bool</span> isPrime[MAX_NUM+<span class="number">10</span>];  <span class="comment">//值为1表示i为素数 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)</span><br><span class="line">isPrime[i]=<span class="literal">true</span>;   <span class="comment">//开始假设所有数都是素数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)&#123;   <span class="comment">//每一次将一个素数的所有倍数标记为非素数 </span></span><br><span class="line"><span class="keyword">if</span>(isPrime[i])&#123;   <span class="comment">//仅标记素数的倍数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=MAX_NUM;j+=i)</span><br><span class="line">isPrime[j]=<span class="literal">false</span>;<span class="comment">//将素数i的倍数标记为非素数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(isPrime[i])</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span>(c==n)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;br&gt;输入一个正整数n，求第n小的质数。&lt;br&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;一个不超过10000的正整数n。&lt;br&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;第n小的质数。&lt;/p&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>菲波那契数列</title>
    <link href="https://hongbosherlock.github.io/2019/03/08/fib/"/>
    <id>https://hongbosherlock.github.io/2019/03/08/fib/</id>
    <published>2019-03-08T08:11:50.000Z</published>
    <updated>2021-01-17T15:08:50.216Z</updated>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。<br>给出一个正整数k，要求菲波那契数列中第k个数是多少。<br><a id="more"></a><strong>输入</strong><br>输入一行，包含一个正整数k。（1 &lt;= k &lt;= 46）<br><strong>输出</strong><br>输出一行，包含一个正整数，表示菲波那契数列中第k个数的大小</p><p><strong>样例输入</strong></p><blockquote><p>19</p></blockquote><p><strong>样例输出</strong> </p><blockquote><p>4181</p></blockquote><p>Code:</p><p><strong>解法一：递归</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib(n<span class="number">-2</span>)+Fib(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonac</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> Fibonac(a+b,a,n<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//第几个斐波那契数列</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="comment">//printf("%d\n",Fib(k));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//斐波那契数列的第一项  </span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>; <span class="comment">//第二项  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Fibonac(a,b,k));<span class="comment">//优化后的递归  ;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法二:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a1=<span class="number">1</span>,a2=<span class="number">1</span>,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>||k==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k<span class="number">-2</span>;i++)&#123;</span><br><span class="line">sum=a1+a2;</span><br><span class="line">a1=a2;</span><br><span class="line">a2=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;br&gt;菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。&lt;br&gt;给出一个正整数k，要求菲波那契数列中第k个数是多少。&lt;br&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="斐波那锲" scheme="https://hongbosherlock.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E9%94%B2/"/>
    
  </entry>
  
  <entry>
    <title>成绩排序（选择排序，结构体数组）</title>
    <link href="https://hongbosherlock.github.io/2019/01/23/sort1/"/>
    <id>https://hongbosherlock.github.io/2019/01/23/sort1/</id>
    <published>2019-01-23T03:24:47.000Z</published>
    <updated>2019-01-23T03:26:38.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="02-成绩排序"><a href="#02-成绩排序" class="headerlink" title="02:成绩排序"></a>02:成绩排序</h4><hr><p>总时间限制: 1000ms 内存限制: 65536kB</p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则<strong>名字字典序</strong>小的在前。<br><a id="more"></a></p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行为n (0 &lt; n &lt; 20)，表示班里的学生数目；<br>接下来的n行，每行为每个学生的名字和他的成绩, 中间用单个空格隔开。名字只包含字母且长度不超过20，成绩为一个不大于100的非负整数。</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>把成绩单按分数从高到低的顺序进行排序并输出，每行包含名字和分数两项，之间有一个空格。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><blockquote><p>4<br>Kitty 80<br>Hanmeimei 90<br>Joey 92<br>Tim 28</p><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><p>Joey 92<br>Hanmeimei 90<br>Kitty 80<br>Tim 28</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>简单的排序问题，每个待排序的对象包括两个元素，需要用二维数组或者结构体数组。<br>这里采用结构体数组的方法，采用选择排序实现。<br><strong>【注意】</strong>题目中说名字字典序，是整个字符串，并不代表首字母。</p><h6 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h6><p>简单的说就是，从原有的数组中选择最大/最小的数依次加入新的数组，并从原数组中删除这个值。 这里我们只用一个数组，前部是已排序的（新数组），后部是待排序的（旧数组）</p><h6 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h6><p>(1) 首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。<br>(2) 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>(3) 左右两边分别排序，直到各区间只有一个数。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line">Student stu[<span class="number">10001</span>]; <span class="comment">//定义Student类型的数组stu</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student* stu,<span class="keyword">int</span>  i,<span class="keyword">int</span>  j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student t;</span><br><span class="line">t=stu[i]; </span><br><span class="line">stu[i]=stu[j];</span><br><span class="line">stu[j]=t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选择排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(Student stu[<span class="number">1001</span>],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="comment">//double t1,t2;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序 </span></span><br><span class="line"><span class="keyword">if</span>(stu[j].grade&gt;stu[min].grade)</span><br><span class="line">    min=j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(stu[j].grade==stu[min].grade&amp;&amp;stu[j].name&lt;stu[min].name) </span><br><span class="line">    min=j; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(stu,i,min);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;stu[i].name&gt;&gt;stu[i].grade;</span><br><span class="line"></span><br><span class="line">selectionSort(stu,n);</span><br><span class="line"><span class="comment">//quickSort2(a,0,n-1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;stu[i].name&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[i].grade&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;02-成绩排序&quot;&gt;&lt;a href=&quot;#02-成绩排序&quot; class=&quot;headerlink&quot; title=&quot;02:成绩排序&quot;&gt;&lt;/a&gt;02:成绩排序&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;总时间限制: 1000ms 内存限制: 65536kB&lt;/p&gt;
&lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h5&gt;&lt;p&gt;给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则&lt;strong&gt;名字字典序&lt;/strong&gt;小的在前。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://hongbosherlock.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单排序算法-以“谁考了第K名”为例</title>
    <link href="https://hongbosherlock.github.io/2019/01/21/sort/"/>
    <id>https://hongbosherlock.github.io/2019/01/21/sort/</id>
    <published>2019-01-21T06:09:54.000Z</published>
    <updated>2019-01-21T06:17:27.074Z</updated>
    
    <content type="html"><![CDATA[<h4 id="01-谁考了第k名"><a href="#01-谁考了第k名" class="headerlink" title="01:谁考了第k名"></a>01:谁考了第k名</h4><p>总时间限制: 1000ms 内存限制: 65536kB</p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。<br><a id="more"></a></p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。<br>其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><blockquote><p>5 3<br>90788001 67.8<br>90788002 90.3<br>90788003 61<br>90788004 68.4<br>90788005 73.9</p><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><p>90788004 68.4</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>简单的排序问题，每个待排序的对象包括两个元素，需要用二维数组或者结构体数组。<br>这里采用二维数组的方法，采用两种排序方式：选择排序和快速排序实现。</p><h6 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h6><p>简单的说就是，从原有的数组中选择最大/最小的数依次加入新的数组，并从原数组中删除这个值。 这里我们只用一个数组，前部是已排序的（新数组），后部是待排序的（旧数组）</p><h6 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h6><p>(1) 首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。<br>(2) 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>(3) 左右两边分别排序，直到各区间只有一个数。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//g格式符，用来输出实数，</span></span><br><span class="line"><span class="comment">//它会根据数值的大小，自动选择f格式或者e格式（选择输出宽度较小的一种），</span></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">void swap(double (*a)[20],int  i,int  max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">t1=a[i][<span class="number">0</span>]; t2=a[i][<span class="number">1</span>];</span><br><span class="line">a[i][<span class="number">0</span>]=a[max][<span class="number">0</span>];</span><br><span class="line">a[i][<span class="number">1</span>]=a[max][<span class="number">1</span>];</span><br><span class="line">a[max][<span class="number">0</span>]=t1;</span><br><span class="line">a[max][<span class="number">1</span>]=t2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选择排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max;</span><br><span class="line"><span class="comment">//double t1,t2;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">max=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="comment">//从大到小排序 </span></span><br><span class="line"><span class="keyword">if</span>(a[j][<span class="number">0</span>]&gt;a[max][<span class="number">0</span>])</span><br><span class="line">    max=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(a,i,max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序1，交换前后元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>],<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=e)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> k=a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> i=s,j=e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;i&amp;&amp;a[j][<span class="number">0</span>]&lt;=k)</span><br><span class="line">--j;</span><br><span class="line">swap(a,j,i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;a[i][<span class="number">0</span>]&gt;=k)</span><br><span class="line">++i;</span><br><span class="line">swap(a,i,j);</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">//处理完后a[i] =k;</span></span><br><span class="line">quickSort1(a,s,i<span class="number">-1</span>);</span><br><span class="line">quickSort1(a,i+<span class="number">1</span>,e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序2，挖坑填数+分治 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">double</span> a[<span class="number">20</span>][<span class="number">20</span>],<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(s&gt;=e)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> k=a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> i=s,j=e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;i&amp;&amp;a[j][<span class="number">0</span>]&lt;=k)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span>(j&gt;i)&#123;</span><br><span class="line">a[i][<span class="number">0</span>]=a[j][<span class="number">0</span>];</span><br><span class="line">a[i++][<span class="number">1</span>]=a[j][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;a[i][<span class="number">0</span>]&gt;=k)</span><br><span class="line">++i;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">     a[j][<span class="number">0</span>]=a[i][<span class="number">0</span>];</span><br><span class="line">     a[j--][<span class="number">1</span>]=a[i][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">//处理完后a[i] =k;</span></span><br><span class="line">a[i][<span class="number">0</span>]=k;</span><br><span class="line">quickSort1(a,s,i<span class="number">-1</span>);</span><br><span class="line">quickSort1(a,i+<span class="number">1</span>,e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;a[i][<span class="number">1</span>],&amp;a[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//selectionSort(a,n);</span></span><br><span class="line">quickSort2(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld "</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)a[k<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%g\n"</span>,a[k<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;01-谁考了第k名&quot;&gt;&lt;a href=&quot;#01-谁考了第k名&quot; class=&quot;headerlink&quot; title=&quot;01:谁考了第k名&quot;&gt;&lt;/a&gt;01:谁考了第k名&lt;/h4&gt;&lt;p&gt;总时间限制: 1000ms 内存限制: 65536kB&lt;/p&gt;
&lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h5&gt;&lt;p&gt;在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://hongbosherlock.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Google Year In Search 2018</title>
    <link href="https://hongbosherlock.github.io/2018/12/12/google2018/"/>
    <id>https://hongbosherlock.github.io/2018/12/12/google2018/</id>
    <published>2018-12-12T11:36:05.000Z</published>
    <updated>2021-01-17T15:08:26.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong><font size="7" face="黑体" weight="">            “</font></strong>今天下午手机里场库推送了一条消息：“Google感人年度回顾【Year In Search 2018】”<a id="more"></a>， 我一边想着Google怎么这么快就退出年度总结了（我记得去年是二十几号啊），一边意识到今年真的快要结束了……</p></blockquote><p><br></p><h3 id="美好的事物，值得我们不断搜索"><a href="#美好的事物，值得我们不断搜索" class="headerlink" title="美好的事物，值得我们不断搜索"></a>美好的事物，值得我们不断搜索</h3><p><iframe height="480" width="854" src="http://player.youku.com/embed/XMzk2MTEwODg4NA==" frameborder="0" 'allowfullscreen'=""></iframe><br>In a year of ups and downs, the world searched for “good” more than ever before — according to Google Trends. From the epic headlines to the everyday moments, here’s to all the good that people discovered in 2018. Explore more trends from the year at <a href="https://google.com/2018" target="_blank" rel="noopener">https://google.com/2018</a> </p><blockquote><p><strong> <em> Hope is a good thing, maybe the best of things.</em> </strong><br> 在这个寒冷的冬日，Google的视频给我们带来了些许的温暖与感动。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;font size=&quot;7&quot; face=&quot;黑体&quot; weight=&quot;&quot;&gt;            “&lt;/font&gt;&lt;/strong&gt;今天下午手机里场库推送了一条消息：“Google感人年度回顾【Year In Search 2018】”
    
    </summary>
    
      <category term="生活" scheme="https://hongbosherlock.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Google" scheme="https://hongbosherlock.github.io/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-数字三角形</title>
    <link href="https://hongbosherlock.github.io/2018/05/08/Dg1/"/>
    <id>https://hongbosherlock.github.io/2018/05/08/Dg1/</id>
    <published>2018-05-08T07:10:09.000Z</published>
    <updated>2021-01-17T15:09:06.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><blockquote><p>例题一、数字三角形 (POJ1163)<br> 　　　　7<br>　　　3　 8　<br>　　8 　1　 0<br>　2 　7　 4 　 4<br>4 　5　 2　 6　 5<br>在上面的数字三角形中寻找一条从顶部到底边路径，使得 路径上所经过的数字之和最大。每一步都只能往左下或右下走。只需要求出这个最大和即可，不必给具体路径。<br>三角形的行数大于 1小于 等100 ，数字为 0 -99</p><a id="more"></a><p>输入格式：<br>5　// 三角形行数。下面是三角形<br>7<br>3 8<br>8 1 0<br>2 7 4 ４<br>4 5 2 6 5</p></blockquote><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><p>直接使用递归的话，因为重复计算，时间效率很低</p><h3 id="2-递推计算"><a href="#2-递推计算" class="headerlink" title="2. 递推计算"></a>2. 递推计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">   maxsum[n][j]=D[i][j]; <span class="comment">/*从最底层的点出发的最大值，就是本身*/</span></span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)   <span class="comment">/*从第n-1层倒推*/</span></span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">   maxsum[i][j]=D[i][j]+max(maxsum[i][j],maxsum[i][j+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="3-记忆化搜索"><a href="#3-记忆化搜索" class="headerlink" title="3. 记忆化搜索"></a>3. 记忆化搜索</h3><blockquote><p>D[i][j]的初始值设为-1，memset(D,-1,sizeof(D));<br>递归函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(maxsum[i][j]!=<span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">return</span> maxsum[i][j];</span><br><span class="line"><span class="keyword">if</span>(i==n)</span><br><span class="line"><span class="keyword">return</span> maxsum[i][j] = D[i][j]; <span class="comment">/*赋值语句本身有返回值*/</span></span><br><span class="line"><span class="keyword">return</span> maxsum[i][j]=D[i][j]+max(maxsum[i][j],maxsum[i][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4-空间优化"><a href="#4-空间优化" class="headerlink" title="4.  空间优化"></a>4.  空间优化</h3><h4 id="（1）方法一"><a href="#（1）方法一" class="headerlink" title="（1）方法一"></a>（1）方法一</h4><p>没必要用二维maxsum数组储存每一个MaxSum(i,j),只要从底层一行行向上递推，那么只要一维数组maxsum[100]即可，只要储存一行的MaxSum值就可以。<br>即计算第i行的MaxSum（i.j）时，在不影响计算的情况下，覆盖第i+1行的MaxSum(i,j)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         maxsum[i]=D[n][i]; </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">       maxsum[j]=D[i][j]+max(maxsum[j],maxsum[j+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><h4 id="2-方法二"><a href="#2-方法二" class="headerlink" title="(2)方法二"></a>(2)方法二</h4><p>不使用maxsum数组，直接用D[n]代替。<br><strong>完整代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 101</span></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* maxsum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;D[i][j];</span><br><span class="line">    maxsum = D[n]; <span class="comment">//maxsum指向第n行   </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)  <span class="comment">//从倒数第2行开始递推 </span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        maxsum[j]=D[i][j]+max(maxsum[j],maxsum[j+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxsum[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数字三角形&quot;&gt;&lt;a href=&quot;#数字三角形&quot; class=&quot;headerlink&quot; title=&quot;数字三角形&quot;&gt;&lt;/a&gt;数字三角形&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;例题一、数字三角形 (POJ1163)&lt;br&gt; 　　　　7&lt;br&gt;　　　3　 8　&lt;br&gt;　　8 　1　 0&lt;br&gt;　2 　7　 4 　 4&lt;br&gt;4 　5　 2　 6　 5&lt;br&gt;在上面的数字三角形中寻找一条从顶部到底边路径，使得 路径上所经过的数字之和最大。每一步都只能往左下或右下走。只需要求出这个最大和即可，不必给具体路径。&lt;br&gt;三角形的行数大于 1小于 等100 ，数字为 0 -99&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="https://hongbosherlock.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>近期的ToList</title>
    <link href="https://hongbosherlock.github.io/2018/04/23/ToList/"/>
    <id>https://hongbosherlock.github.io/2018/04/23/ToList/</id>
    <published>2018-04-23T14:45:57.000Z</published>
    <updated>2021-01-18T10:32:30.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>近期事情比较多，<strong>大创</strong>、<strong>研究开发实践</strong>、<strong>微信移动终端开发</strong>都要动手写项目。加上这学期还有<strong>操作系统</strong>和<strong>计算机组成原理</strong>这两门课。开学以来遇到了不少问题。觉得自己要学的还有很多。</p></blockquote><p>这学期参加的比赛结果也不尽人意（感觉自己真的好菜啊），数学竞赛省赛没有拿奖，蓝桥杯省赛也没能拿奖（交了300块报名费，而且题目其实不难），最近的英语竞赛也落榜了。算了下，只拿了校网页设计大赛的二等奖和校小挑的三等奖，而且奖状也没有着落。这样说感觉自己似乎有点功利和心浮气躁，但现实就是这样催人前进吧。<strong><em>你只有努力才能原地踏步。</em></strong></p><p>看到大佬们收割了一个又一个比赛的奖项，除了羡慕，自己心里也挺着急。不过，急能有什么用呢，只能潜心学习了。</p><p>根据自己的近期目标和个人情况，我简单列了下学习清单。</p><a id="more"></a><hr><h3 id="To-Do-List"><a href="#To-Do-List" class="headerlink" title="To  Do List"></a>To  Do List</h3><h4 id="算法"><a href="#算法" class="headerlink" title="- 算法"></a>- 算法</h4><p>算法是我比较薄弱的一项，想当初还想参加ACM呢，现在只是了解简单算法，思维能力也不强。这学期选了门<strong>算法设计</strong>的选修课，也在看刘汝佳的<a href="https://github.com/aoapc-book/aoapc-bac2nd/" target="_blank" rel="noopener"><strong>《算法竞赛：入门经典（第二版）》</strong></a>，目前觉得还是学到了一些，不过还是没有深入学，还是挤时间多敲代码练习吧。</p><h4 id="Android开发"><a href="#Android开发" class="headerlink" title="-  Android开发"></a>-  Android开发</h4><p>之所以学习Android开发，很大一部分原因是大创项目需要开发一款APP。其实我之前也想学Android开发的，觉得会写APP是一件很酷的事情，也很实用。目前我在看郭霖的<strong>《第一行代码（第2版）》</strong>进行学习，以Android Studio为开发工具。同时也在复习（应该说是从新学习）Java。</p><h4 id="Java-Web"><a href="#Java-Web" class="headerlink" title="- Java Web"></a>- Java Web</h4><p>首先，研究开发实践课我们小组选的是做移动课堂项目，用Java来实现，所以要用到Java Web的知识，还有数据库知识。目前Spring MVC什么的我还都不懂，可能这次项目也不会采用了。慢慢在学习了，看着<a href="https://www.imooc.com/learn/166" target="_blank" rel="noopener">慕课网</a>的教学视频，又从图书馆借了一本参考书：<a href="https://book.douban.com/subject/3351927/" target="_blank" rel="noopener"><strong>《Tomcat 与 Java Web开发技术详解》</strong></a>,刚开始着手学习。</p><h4 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="- 微信小程序开发"></a>- 微信小程序开发</h4><p>选了学院和腾讯合作开的<strong>微信移动终端开发</strong>这门课，网上有6个章节腾讯技术人员的讲解视频，是以微信移动开发为例讲移动开发的，只看视频的话学到的东西很少。老师是大三的辅导员方帅，他上课给我们拓展了不少内容，从小程序开发，到Java Servlet，前端和后端的知识都有提及。我们课程的<a href="https://github.com/fanmcgrady/MobileDevCourse" target="_blank" rel="noopener">GitHub项目</a>当然，老师只是引你进门，后面就需要自己深入学习了。</p><h4 id="Linux-学习"><a href="#Linux-学习" class="headerlink" title="- Linux 学习"></a>- Linux 学习</h4><p>这学期在上<strong>操作系统</strong>这门课，实验课上基本上就是在Linux系统下敲命令行运行程序，作为一名合格的程序员，学习Linux还是很重要的。打算五一假期折腾一下，装上双系统，以后熟悉使用Linux系统。准备买一本<strong>《鸟哥的Linux私房菜》</strong>当做参考书。</p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="- 机器学习"></a>- 机器学习</h4><p>现在人工智能很火，我这学期选了<strong>模式识别引论</strong>这门课，模式识别算是人工智能的一个分支，现在好像不怎么提了。我对人工智能领域还是挺感兴趣的，但目前也只是感兴趣的水平而已，一本相关的书也没有看过，代码也没敲过。我加入了学校的一个人工智能的社团，目前是由两位物理学院的大三学长来运营，他们在准备计算机的考研。社团主要是由已经毕业，目前在自主创业的袁霖学长来进行知识讲授，社团氛围很好，我也很喜欢，希望能努力学到一些知识。我们的<a href="https://github.com/tair-ai" target="_blank" rel="noopener">GitHub Group</a>.</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>想学习的知识很多，做的事情也很多，其实时间看也挺紧的。<br>好快，已经大二下学期了，感觉大家的竞争也越来越激烈了，明争暗斗的感觉。我目前还不用为找工作而担忧，去北京读研的目标早已经定下来了，当下要做的就是把专业必修课成绩搞好，多参加些比赛，争取保研，是在不行就考研。<br>不想那么多啦，<strong><em>纸上得来终觉浅，绝知此事要躬行。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;近期事情比较多，&lt;strong&gt;大创&lt;/strong&gt;、&lt;strong&gt;研究开发实践&lt;/strong&gt;、&lt;strong&gt;微信移动终端开发&lt;/strong&gt;都要动手写项目。加上这学期还有&lt;strong&gt;操作系统&lt;/strong&gt;和&lt;strong&gt;计算机组成原理&lt;/strong&gt;这两门课。开学以来遇到了不少问题。觉得自己要学的还有很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这学期参加的比赛结果也不尽人意（感觉自己真的好菜啊），数学竞赛省赛没有拿奖，蓝桥杯省赛也没能拿奖（交了300块报名费，而且题目其实不难），最近的英语竞赛也落榜了。算了下，只拿了校网页设计大赛的二等奖和校小挑的三等奖，而且奖状也没有着落。这样说感觉自己似乎有点功利和心浮气躁，但现实就是这样催人前进吧。&lt;strong&gt;&lt;em&gt;你只有努力才能原地踏步。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到大佬们收割了一个又一个比赛的奖项，除了羡慕，自己心里也挺着急。不过，急能有什么用呢，只能潜心学习了。&lt;/p&gt;
&lt;p&gt;根据自己的近期目标和个人情况，我简单列了下学习清单。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://hongbosherlock.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>马尔克斯</title>
    <link href="https://hongbosherlock.github.io/2018/03/06/%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"/>
    <id>https://hongbosherlock.github.io/2018/03/06/马尔克斯/</id>
    <published>2018-03-06T07:34:00.000Z</published>
    <updated>2021-01-17T15:03:40.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>这周二，在加夫列尔·加西亚·马尔克斯诞辰91周年这天，谷歌今天在搜索页以涂鸦来纪念这位著名作家传奇的一生和其杰出的作品。</p></blockquote><p><img src="http://wx3.sinaimg.cn/mw690/006w4HKkgy1fp35ct4sjfg30fw064tbq.gif" alt="Google doodle"></p><p>在亚马逊丛林深处，透过茂密的绿色树冠和色彩斑斓的热带雨林，仔细观察，你可能会瞥见一个镜子之城;一个被一大片水域与世界隔开的城市，但却反映了它的一切;这个城市是布恩蒂亚家族的所在地，也是奇怪的其他世俗事件的发生地。这里，用纯金做的小鱼令人眼花缭乱;黄色的大蝴蝶在花丛中飞舞;一辆火车在蓝月亮上飞驰而过;唯一的旅客就是那些全知的、神秘的还带着奇怪故事的吉普赛人。</p><hr><a id="more"></a><h2 id="加夫列尔·加西亚·马尔克斯"><a href="#加夫列尔·加西亚·马尔克斯" class="headerlink" title="加夫列尔·加西亚·马尔克斯"></a>加夫列尔·加西亚·马尔克斯</h2><p>在今天的涂鸦中描绘的是这个神奇的城市马孔多，由哥伦比亚作家、记者和诺贝尔奖得主加夫列尔·加西亚·马尔克斯(在拉丁美洲被亲切地称为加布)，在他的书《百年孤独》中被描绘出来。<br>马尔克斯出生在哥伦比亚的阿拉卡塔卡，被认为是20世纪最重要的作家之一。在他漫长的文学生涯中，他写了25本书，把读者带进一个魔幻现实主义的世界，在那里他们发现自己置身于郁郁葱郁、潮湿的热带地区——陷入孤独，或者被激情的痛苦所吞噬。<br> 他敏锐的政治能动性和勇气，也让他创作了许多非虚构作品，这些作品生动地记录了他所生活的时代，其中最著名的是绑架事件。<br>尽管如此，我们仍在庆祝一个文化偶像的91岁生日，这位偶像的明星继续在拉丁美洲和其他地区的文学和新闻世界闪耀光芒。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这周二，在加夫列尔·加西亚·马尔克斯诞辰91周年这天，谷歌今天在搜索页以涂鸦来纪念这位著名作家传奇的一生和其杰出的作品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw690/006w4HKkgy1fp35ct4sjfg30fw064tbq.gif&quot; alt=&quot;Google doodle&quot;&gt;&lt;/p&gt;
&lt;p&gt;在亚马逊丛林深处，透过茂密的绿色树冠和色彩斑斓的热带雨林，仔细观察，你可能会瞥见一个镜子之城;一个被一大片水域与世界隔开的城市，但却反映了它的一切;这个城市是布恩蒂亚家族的所在地，也是奇怪的其他世俗事件的发生地。这里，用纯金做的小鱼令人眼花缭乱;黄色的大蝴蝶在花丛中飞舞;一辆火车在蓝月亮上飞驰而过;唯一的旅客就是那些全知的、神秘的还带着奇怪故事的吉普赛人。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="文艺" scheme="https://hongbosherlock.github.io/categories/%E6%96%87%E8%89%BA/"/>
    
    
      <category term="马尔克斯" scheme="https://hongbosherlock.github.io/tags/%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>“钢铁侠”马斯克：他给上帝刷了火箭和跑车</title>
    <link href="https://hongbosherlock.github.io/2018/02/10/spacex/"/>
    <id>https://hongbosherlock.github.io/2018/02/10/spacex/</id>
    <published>2018-02-10T11:08:45.000Z</published>
    <updated>2021-01-17T15:11:31.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote><p>2018年2月7日北京时间04：45时许，几番推迟之后，在逾十万现场观众的注视下，佛罗里达肯尼迪航天中心 LC-39A 发射工位，这个曾经承载了“土星 5 号”火箭登月和“哥伦比亚”号航天飞机首飞的发射位再次为自己的光荣传统添上了传奇的一笔——人类现役运力最强的火箭重型猎鹰（Falcon Heavy）成功在这里完成了首飞并完成一级火箭回收！<br> 火箭目前工作一切正常，虽然火箭芯级回收似乎并不顺利，此外二级还需要5小时的长时间滑行测试，但是人类现役最强运载火箭的宝座已经易主的事实已经无可撼动。</p><p> 那家叫做 SpaceX 的公司和那个名为马斯克的男人再次成为万众瞩目的焦点。</p></blockquote><a id="more"></a><h2 id="“重装猎鹰”首飞大成功，SpaceX点燃人类航天新纪元"><a href="#“重装猎鹰”首飞大成功，SpaceX点燃人类航天新纪元" class="headerlink" title="“重装猎鹰”首飞大成功，SpaceX点燃人类航天新纪元"></a>“重装猎鹰”首飞大成功，SpaceX点燃人类航天新纪元</h2><h3 id="1·-历史性时刻"><a href="#1·-历史性时刻" class="headerlink" title="1· 历史性时刻"></a>1· 历史性时刻</h3><p>巨大的轰鸣声，人们激动万分的欢呼声。</p><p>一飞冲天的火箭，耀眼的火焰，滚滚浓烟</p><p>这科幻电影一般燃到炸裂的画面，在现实中真实上演</p><p><img src="http://www.lepoint.fr/images/2018/02/06/13201399lpw-13232143-article-jpg_4982304_1250x625.jpg" alt="重型猎鹰火箭升空! "></p><p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=r0547m1f8fx&tiny=0&auto=0" allowfullscreen></iframe><br>“猎鹰重型”第一级由三枚“猎鹰9”火箭芯捆绑而成。发射八分多钟后，两侧的火箭芯先降落在发射场附近的陆地回收地点。随后，按计划，中间的火箭芯应落回大西洋中的无人船上。</p><p><img src="http://cdn.jiasuhui.com/upload/images/content/2018/02/08/article24838pic5.jpg" alt="升空后2分33秒，助推火箭分离"></p><p><img src="http://cdn.jiasuhui.com/upload/images/content/2018/02/08/article24838pic6.jpg" alt="3分07秒，一二级分离。"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180207/5cc8cfc498864d6785bafd3e6fce3d21.jpeg" alt=" "><br><strong>依旧是排山倒海的欢呼声！致敬这些勇敢创新的工程师们！</strong></p><p>据悉，“猎鹰重型”火箭共有3枚一级火箭和27个引擎，发射时可产生约227万公斤的推力。</p><p>“猎鹰重型”的有效载荷，相当于将五辆伦敦双层巴士“安装”在太空中。</p><p>在报道中，许多外媒同时回忆了这枚火箭的起点：7年前，在华盛顿的一个会议室里，“猎鹰重型”的模型首次公开，当时只有一些记者，还有几张空椅子见证了这一刻。</p><p>埃隆·马斯克后来对记者说：“我曾想象过火箭在天空中爆炸的场面，但幸运的是，事情并没有发生。”</p><p>如今，它的发射成为了现实——尽管三枚火箭芯中的一枚没有按照计划被成功回收，但这毫不折损“猎鹰重型”带给人类的强烈冲击。</p><p><strong>当两枚助推火箭返回地球，同时垂直着落，那个画面，太震撼人心。</strong><br><img src="https://pic1.zhimg.com/80/v2-df15ec77dcd8bbd5e6fb9a2a3b12b289_hd.jpg" alt=" "></p><p>这既是一次火箭发射任务，也可以说是马斯克自导自演的一次“太空级”的大 Show。在火箭发射的前一天，马斯克的 Twitter 就开始不断“刷屏”。先是推出一支最新的重型猎鹰概念片，配以 David Bowie 的《Life on Mars？》可以说是十分应景。<br><a href="https://qiniu-video5.vmoviercdn.com/5a7a5d29e4e2b.mp4" target="_blank" rel="noopener">《重型猎鹰模拟动画》</a></p><h3 id="2·-豪华阵容"><a href="#2·-豪华阵容" class="headerlink" title="2· 豪华阵容"></a>2· 豪华阵容</h3><p>Musk当然没有让这枚火箭孤独上天，他把自家刚发布没多久的Tesla Roadster跑车装进了火箭里，<br>作为火箭的唯一负载。<br>是的，一辆樱桃红的够酷够骚气的跑车。这也是Musk的最爱，代表着他的速度与激情。<br><img src="http://5b0988e595225.cdn.sohucs.com/images/20180207/bacbc1d1b285408e80f31b13ca6050e9.jpeg" alt="@ Tesla Roadster跑车"></p><p>他要把这辆车送进太空，让它前往火星轨道，环绕太阳运动。</p><p>Musk为这辆跑车配备了一名“驾驶员”，一个穿着整套宇航服的假人。</p><p><img src="https://pic1.zhimg.com/50/v2-79dbad3904f86693304dc7b8bd4c8013_hd.gif" alt=" "></p><p>他们甚至为这个“驾驶员”取了一个浪漫的名字，Starman（David Bowie的一首歌）<br>Starman穿着太空探索公司的新宇航服，车里放着一本《银河系搭便车指南》，音响不间断地放着David Bowie的那首<a href="https://music.163.com/#/song?id=22224474" target="_blank" rel="noopener">《Space Oddity》</a></p><p><img src="https://forum.nasaspaceflight.com/index.php?action=dlattach;topic=44376.0;attach=1475982;image" alt=" "></p><p>马斯克在车上设置的彩蛋，Don’t panic！来自著名科幻小说《银河系漫游指南》。</p><p><img src="https://www.focus.it/site_stored/imgs/0005/045/ipa_10892791.jpg" alt=" "></p><p>在车上的一块电路板，印着这么一句话写着“Made on Earth by Human”，由地球上的人类制造。</p><p>根据SpaceX的计算，这辆Roadster在进入“地球-火星”转移轨道之后，将在太阳系内长时间飞行，如果没有任何意外的话（其他物体在轨道上撞击），这辆车将会在宇宙中飞行超过10亿年。马斯克甚至为此开了个玩笑——假如有一天外星人来了，他们也会看到这辆车在飞。</p><p>从“重型猎鹰”成功首飞这一刻起，它也已经成为了全球现役运载能力最强的火箭。事实上，这却不是最值得“标榜”的。因为人类上世纪70年代所打造的“土星5号”依旧保持着最大的运载能力记录：近地轨道（LEO）运载能力140吨。但“重型猎鹰”真正称霸火箭家族的东西，是连传奇“土星5号”也不能比的——经济性和环保。<br>一枚崭新的猎鹰 9 号（Falcon 9）火箭报价在 5500-6200 万美元之间，远低于同类的宇宙神 5（Atlas-5）和德尔塔 4（Delta-4）1-4 亿美元不等的报价。而猎鹰重型火箭价格也很感人，预计报价仅为 1 亿美元左右，甚至大大低于德尔塔 4 重型火箭的 4.35 亿美元的发射均价。要知道，猎鹰重型火箭的运力比它足足多出了 128%，价格却仅仅是它的 23%。</p><p><strong>同时，重型猎鹰火箭也是返月利器。</strong><br>马斯克也早在 2011 年就很有先见之明地提到了登月的项目，“理论上讲，你只需要两发重型猎鹰火箭就能实现登月——一枚将宇航员送上月球，另一枚运送返回载具。这样日积月累一段时间之后，我们完全有能力建立起一个理想中的月球基地。”</p><p>马斯克说SpaceX的终极目标是实现人类星际移民。马斯克说，当人工智能失控并与人类为敌的时候，火星就会成为人类最后的避难所。</p><h3 id="3·-跌宕起伏—–意志的胜利"><a href="#3·-跌宕起伏—–意志的胜利" class="headerlink" title="3· 跌宕起伏—–意志的胜利"></a>3· 跌宕起伏—–意志的胜利</h3><p>这次的幸运儿是Elon Musk（埃隆·马斯克），也就是我们俗称的“硅谷钢铁侠”。</p><p>在通过Paypal发家后，马斯克很快将大笔资金投入到了他更喜爱的科学技术领域，一边搞出了特斯拉电动汽车，一边则成立了今天成功发射了“猎鹰重型号”超级火箭的SpaceX宇航公司，开始实现他探索宇宙的梦想。</p><p>而且公开资料显示，马斯克起初并没有得到过任何美国官方机构的帮助，他从一开始走的就是纯粹的商业路线：起初先是想从欧洲和俄国人那里买个廉价火箭用，但后来发现对方要价都太高，于是他便成立了SpaceX公司自己做火箭，而且他还要做完全可以商业化推广、价格亲民、成本低廉的“火箭”，要让更多的人可以实现探索宇宙的梦想。</p><p>2002年，马斯克投入自己的一亿美元身家，创立 Space X，开始进军可回收火箭发射，要将太空飞船发射升空成本降低100倍，曾经求援俄罗斯，但不被重视，屡屡碰壁。而后愤而自行研发液体运载火箭，但研发的猎鹰1型火箭曾经三次试射，三次爆炸，几乎沦为业界笑柄。创始人马斯克同时又开办了另一家电动汽车公司“特斯拉”，两家公司同时陷入困境，曾经的亿万富翁差点儿一贫如洗到要住父亲家的地下室。</p><p>发射失败后，有人质疑他，火箭的本质是物理学，而不是什么创新经济模式。他毫不留情地反击说，要是听这种人的话，事情永远不会好，不会发生变化。有人问他：“你怎么会这么乐观？”他说：“去他妈的乐观，悲观，我只想要把事情做成”</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180208/e234cd40d854406c8cbdb18f09a98cb5.jpeg" alt=" 2012年6月22日，Tesla首次向市场投放Model S电动车，一位顾客将Model S驶出Tesla位于加州弗里蒙特的工厂"></p><p>SpaceX在2008年末正式获得了NASA的国际空间站商业补给服务合同（Commercial Resupply Services，简称CRS合同），采用公司全新研发的猎鹰9火箭向国际空间站运送共计12次货物，凭借NASA一纸订单的输血效应，SpaceX起死回生。<br>2011年4月，马斯克对外公布了猎鹰重型火箭的研发意图，但当时在外界看来，简直就是天方夜谭。<br><img src="https://cdn.arstechnica.net/wp-content/uploads/2018/01/GettyImages-111670706.jpg" alt=" 2011 年 4 月 5 日，马斯克在美国全国新闻俱乐部上首次宣布了重型猎鹰火箭的计划"></p><p>从2013年起，火箭年年都号称要首飞，结果年年推迟，设计改了又改，首飞推了又推。一些航天界人士甚至认为猎鹰重型火箭永远不会发射。</p><p><img src="https://t1.focus-img.cn/sh740wsh/bbs/p2/70f196d14f07efae3caa4b31568d175b.jpg" alt=" 马斯克客串 ironman 2 "><br>7年后，马斯克以钢铁般不屈不挠的意志，把不可能的事情变成了现实。本次发射，就连他自己也没有足够自信，悲观地预测称，“我甚至认为它不将发射台炸成碎片就是一种成功，毕竟这枚火箭相当于400万磅TNT炸药。”<br><img src="https://codexgalactic.com/wp-content/uploads/2015/06/screen-shot-2015-06-24-at-10-11-24-pm.png" alt=" 海上回收台“Of Course I Still Love You”"><br><strong>Of Course I Still Love You</strong></p><p>“重复使用”四个字，正是SpaceX创立15年来最大的梦想，虽然不能说SpaceX的道路一定会最终成功，但是SpaceX却一直在这条道路上不断前行，历经数不清的挑战、嘲笑和失败，却仍然初心不改。</p><p><a href="https://qiniu-video5.vmoviercdn.com/5a7acf8a30b80.mp4" target="_blank" rel="noopener">SpaceX 火箭回收失败自黑集锦</a></p><h4 id="Elon-Musk是我们这个时代的“科技魔法师”"><a href="#Elon-Musk是我们这个时代的“科技魔法师”" class="headerlink" title="Elon Musk是我们这个时代的“科技魔法师”"></a>Elon Musk是我们这个时代的“科技魔法师”</h4><p>将不可能变成可能，这可以说是最适合Elon Musk的一个口号。他就宛如一个“科技魔法师”，不断在自己努力的领域给观众以惊喜。<br><a href="https://qiniu-video3.vmoviercdn.com/5a7d54c6e5357.mp4" target="_blank" rel="noopener">Space X励志演讲《我们的选择》</a><br>但事实是，即便是Falcon 9，也经过了SpaceX长达9年多的不断实验、试生产、调整。这其中包含着Elon Musk对未来火箭运输领域的洞见和科学的路线制定、管理方法。这些技巧同样体现在他的另一家公司——Tesla中，不然后者也不可能在短短数年间，成为全球电动汽车的引领者。</p><p>长期以来，不少人对马斯克的火星移民、管道高铁、地下隧道等想法嗤之以鼻，甚至称他为骗子。</p><p>但粗略回顾马斯克的历史发现，他才是极少的真正负责任的创业者。</p><blockquote><p>如果汽车一直消耗石油，污染会越严重，石油会耗尽，抢夺石油的战争会一直不断，于是马斯克做了电动车。<br>如果电力一直依靠石油煤炭甚至核能这些自然资源，它们可能有枯竭的一天，并且地球在升温，臭氧层在变稀薄，于是马斯克做了太阳能电池。<br>如果人类的贪婪和科技一直缠在一起膨胀下去，最终把地球毁掉，人类必需在外太空生存，于是马斯克做了火箭发射。<br>如果人类作为一个文明要繁衍下去，必需有一个最低的规模比如100万人，于是马斯克实现了火箭的回收再用以及成本的数量级的下降，这样才可能把100万人送到火星。</p></blockquote><h3 id="4·-Point-of-view"><a href="#4·-Point-of-view" class="headerlink" title="4· Point of view"></a>4· Point of view</h3><p>在社交媒体上，有美国网友掩饰不住兴奋地庆祝：有了“猎鹰重型”，美国终于可以“打败”中国。<br>有中国媒体这样感慨：我国目前不仅没有这种量级的火箭，且距离实现这一技术还需10年，甚至更久……<br>“‘猎鹰重型’运载火箭之所以发展的那么快，是跟美国庞大的航天基础分不开的<br>“无需妄自菲薄，相信未来不久中国会赶超”。</p><p>高二时，偶然间在《参考消息》的科技前沿板块看到了Space X 火箭回收失败的新闻，心想原来火箭还可以回收，再细看竟然是一家私人公司。后来我了解到创始人是马斯克，同时也是特斯拉的创始人。<br>关于回收失败的新闻看到了几次了。终于，在高三的某一天，看到了Space X 的猎鹰火箭海上回收成功的报道。<br>关于电动汽车公司的名字为什么叫做“特斯拉”马斯克是在向尼古拉·特斯拉（Nikola Tesla）致敬。没错，就是高中物理课本上那位发现交流电的科学家。他一生成绩卓著，拥有700项专利，包括交流电系统、无线电、特斯拉感应线圈变压器，无线传输，和荧光灯等。<br>但是，世人对他知之甚少。爱迪生曾经在商业上暗算过他</p><p><strong>然而，今天的那些创业者和极客们并没有忘记他。</strong></p><blockquote><p>伊隆说，“将公司命名为‘特斯拉’，是为了向伟大的科学家和工程师致敬，这比‘马斯克汽车’的名字酷多了。我永远也不会拿我的名字命名任何公司。”</p><p>1985年，一个12岁的密歇根男孩阅读了特斯拉的传记之后哭了。<br>他就是谷歌创始人拉里·佩奇。<br>从那一刻起，佩奇认识到，仅仅构思出创新的科技未来是不够的，重大理念并不足够，它还需要商业化。如果佩奇想要成为一个发明家，他就必须创立一家成功的公司。<br>特斯拉的故事还教育佩奇要小心世界上托马斯·爱迪生这样的老板，他们会利用你实现梦想的愿望，去服务于自身的世俗目的.</p></blockquote><p>借用知乎上一位答主的回复：</p><blockquote><p>02年马斯克创立spaceX，当时有人说他是投机骗钱纸面功夫肯定见不到真火箭；<br>06年~08年猎鹰1号连炸三次，当时有人说私人航天毫不靠谱肯定成不了；<br>10年的时候推出猎鹰9号，当时有人说这九台并联N1再世不放炮仗你敢信；<br>12~14年的时候试验蚱蜢火箭，当时有人说不用降落伞狂风支筷子就是异想天开；<br>15年的时候回收失败两次爆炸一次，当时有人说回收无望路线错误得不偿失；<br>16年的时候海上回收继续失败两次，当时有人说就算陆上能成海上不行损失运力还是没意义；<br>16年中猎鹰9号海上回收受损，当时有人说这回收受损拆解大修成本不堪设想；<br>16年9月地面测试火箭爆炸，当时有人说新兴公司管理混乱扩张无序果然不行；<br>现在是17年中（回答该问题时），火箭回收成功第十三次，火箭复用成功第二次，48小时连续两发成功，12天内三发成功，他们开始质疑为何其他原本质疑spaceX的人不说话了。</p></blockquote><p><strong>历史告诉我们，先驱者从来都是孤独的。</strong><br><strong>对于我们来说，还是那句老话——耐心，是一种美</strong><br>以后，别再说什么“你的征途是星辰大海”了，今天重型猎鹰的发射，才是“一个人将全世界踩在脚下的航天征服”，是真正的星辰大海。仰望星空脚踏实地，就是马斯克本人。<br>“如果你没有偶像，Elon Musk（伊隆·马斯克）就是你的首选。”英国《每日电讯报》这样评价马斯克。让我们向这个带领人类奔向浩瀚无垠宇宙的钢铁男人，致以无限敬意。</p><p>图片来源：网络<br>在此感谢那些摄影作者</p><p>参考资料：（微信公众号）<br><a href="https://mp.weixin.qq.com/s?__biz=MTc5MTU3NTYyMQ==&amp;mid=2650648875&amp;idx=1&amp;sn=e27363321b0a3e5ac44f96167726379d&amp;chksm=5affa0016d8829175bb48968fa94ebfb4048b757f7490522eb99e96f5b3fca4f84220b957d9e&amp;mpshare=1&amp;scene=23&amp;srcid=02078yt6BGD8Y0fccKshIlVs#rd" target="_blank" rel="noopener">三联生活周刊（荐读）</a><br><a href="https://www.zhihu.com/question/266793958" target="_blank" rel="noopener">知乎（荐读</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTAzMjc4MA==&amp;mid=2650075380&amp;idx=1&amp;sn=fe1e63d7b95d6074f92fac59286e6c9d&amp;chksm=bec1f25789b67b411dad9bf2b8263aa47a6b8e64589d76b52b182c7dd23838bc7a01d9df85e5&amp;mpshare=1&amp;scene=23&amp;srcid=0207dnRpj3dIRySZqxN9VqRE#rd" target="_blank" rel="noopener">创业邦</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDA1Njg2MA==&amp;mid=2651987458&amp;idx=1&amp;sn=e3245fb46d5d2644f4e236d3e5d6e0a9&amp;chksm=bd6b21f18a1ca8e7eb832f05f809894779eeb066ea0c15bdaaa53154b760104bb53bac9e14c3&amp;mpshare=1&amp;scene=23&amp;srcid=0207dfQnKhYdOswVwHfOOxSH#rd" target="_blank" rel="noopener"> 环球科学ScientificAmerican</a><br><a href="http://daily.zhihu.com/story/9670272?utm_campaign=in_app_share&amp;utm_medium=Android&amp;utm_source=QQ" target="_blank" rel="noopener">知乎日报</a><br>雷锋网；航天爱好者；央视新闻；新华社；中国青年报······</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2018年2月7日北京时间04：45时许，几番推迟之后，在逾十万现场观众的注视下，佛罗里达肯尼迪航天中心 LC-39A 发射工位，这个曾经承载了“土星 5 号”火箭登月和“哥伦比亚”号航天飞机首飞的发射位再次为自己的光荣传统添上了传奇的一笔——人类现役运力最强的火箭重型猎鹰（Falcon Heavy）成功在这里完成了首飞并完成一级火箭回收！&lt;br&gt; 火箭目前工作一切正常，虽然火箭芯级回收似乎并不顺利，此外二级还需要5小时的长时间滑行测试，但是人类现役最强运载火箭的宝座已经易主的事实已经无可撼动。&lt;/p&gt;
&lt;p&gt; 那家叫做 SpaceX 的公司和那个名为马斯克的男人再次成为万众瞩目的焦点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="科技" scheme="https://hongbosherlock.github.io/categories/%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="SpaceX" scheme="https://hongbosherlock.github.io/tags/SpaceX/"/>
    
      <category term="马斯克" scheme="https://hongbosherlock.github.io/tags/%E9%A9%AC%E6%96%AF%E5%85%8B/"/>
    
  </entry>
  
</feed>
