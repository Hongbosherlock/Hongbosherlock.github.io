<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HongboSherlock&#39;blog</title>
  <icon>https://www.gravatar.com/avatar/01a6e634aaa732c8a71d6c3caae87072</icon>
  <subtitle>Stay Hungry, Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongbosherlock.github.io/"/>
  <updated>2022-08-31T12:46:56.752Z</updated>
  <id>https://hongbosherlock.github.io/</id>
  
  <author>
    <name>Xu Hongbo</name>
    <email>hongbosherlock@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 多线程编程示例</title>
    <link href="https://hongbosherlock.github.io/2022/08/20/pthread/"/>
    <id>https://hongbosherlock.github.io/2022/08/20/pthread/</id>
    <published>2022-08-20T12:17:22.000Z</published>
    <updated>2022-08-31T12:46:56.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">pthread_create (thread, attr, start_routine, arg)</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用 -lpthread 库编译下面的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><code>pthread_cond_wait</code> unlocks the mutex just before it sleeps，but then it reaquires the mutex (which may require waiting) when it is signalled, before it wakes up. </p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><blockquote><p>创建两个线程，其中一个输出1-52，另外一个输出A-Z。</p><p>输出格式要求：12A 34B 56C 78D …</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;  <span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;    <span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintNum</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">52</span>;i=i+<span class="number">2</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//函数用于等待目标条件变量。mutex参数是用于保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 函数用于唤醒一个等待目标条件变量的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策略。</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//结束线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintChar</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,i+<span class="string">'A'</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//结束线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>); <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>); <span class="comment">//初始化条件变量</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> indexs[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret1 = pthread_create(&amp;thread[<span class="number">0</span>],<span class="literal">NULL</span>,PrintNum,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"cread thread 1 error "</span>&lt;&lt;ret1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret2 = pthread_create(&amp;thread[<span class="number">1</span>],<span class="literal">NULL</span>,PrintChar,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"cread thread 2 error "</span>&lt;&lt;ret1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//结束线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例-2-死锁"><a href="#示例-2-死锁" class="headerlink" title="示例 2 死锁"></a>示例 2 死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">another</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock( &amp;mutex_b );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"in child thread, got mutex b, waiting for mutex a\n"</span> );</span><br><span class="line">    sleep( <span class="number">5</span> );</span><br><span class="line">    ++b;</span><br><span class="line">    pthread_mutex_lock( &amp;mutex_a );</span><br><span class="line">    b += a++;</span><br><span class="line">    pthread_mutex_unlock( &amp;mutex_a );</span><br><span class="line">    pthread_mutex_unlock( &amp;mutex_b );</span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> id;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init( &amp;mutex_a, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_mutex_init( &amp;mutex_b, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_create( &amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock( &amp;mutex_a );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"in parent thread, got mutex a, waiting for mutex b\n"</span> );</span><br><span class="line">    sleep( <span class="number">5</span> );</span><br><span class="line">    ++a;</span><br><span class="line">    pthread_mutex_lock( &amp;mutex_b );</span><br><span class="line">    a += b++;</span><br><span class="line">    pthread_mutex_unlock( &amp;mutex_b );</span><br><span class="line">    pthread_mutex_unlock( &amp;mutex_a );</span><br><span class="line"></span><br><span class="line">    pthread_join( id, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_mutex_destroy( &amp;mutex_a );</span><br><span class="line">    pthread_mutex_destroy( &amp;mutex_b );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>in parent thread, got mutex a, waiting for mutex b<br>in child thread, got mutex b, waiting for mutex a</p></blockquote><p>关键字</p><blockquote><p>noexcept  explicit</p></blockquote><p>std::ref   <a href="https://murphypei.github.io/blog/2019/04/cpp-std-ref" target="_blank" rel="noopener">C++11 的 std::ref 用法 | 拾荒志 (murphypei.github.io)</a></p><p>std::bind</p><p><a href="http://en.cppreference.com/w/cpp/utility/forward" target="_blank" rel="noopener">std::forward</a></p><p>auto&amp; </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h2&gt;&lt;p&gt;下面的程序，我们可以用它来创建一个 POSIX 线程：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pthread_create (thread, attr, start_routine, arg)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O多路复用：epoll</title>
    <link href="https://hongbosherlock.github.io/2021/08/12/epoll/"/>
    <id>https://hongbosherlock.github.io/2021/08/12/epoll/</id>
    <published>2021-08-12T14:59:19.000Z</published>
    <updated>2021-08-23T15:02:44.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阻塞-VS-非阻塞"><a href="#阻塞-VS-非阻塞" class="headerlink" title="阻塞 VS 非阻塞"></a>阻塞 VS 非阻塞</h3><p>阻塞 VS 非阻塞<br>当应用程序调用阻塞 I/O 完成某个操作时，应用程序会被挂起，等待内核完成操作，感觉上应用程序像是被“阻塞”了一样。实际上，内核所做的事情是将 CPU 时间切换给其他有需要的进程，网络应用程序在这种情况下就会得不到 CPU 时间做该做的事情。</p><p>非阻塞 I/O 则不然，当应用程序调用非阻塞 I/O 完成某个操作时，内核立即返回，不会把 CPU 时间切换给其他进程，应用程序在返回后，可以得到足够的 CPU 时间继续完成其他事情。</p><h3 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下 read 调用会立即返回，一般返回 EWOULDBLOCK 或 EAGAIN 出错信息。在这种情况下，出错信息是需要小心处理，比如后面再次调用 read 操作，而不是直接作为错误直接返回。</p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ul><li>在阻塞 I/O 情况下，write 函数返回的字节数，和输入的参数总是一样的。如果返回值总是和输入的数据大小一样。</li><li>在非阻塞 I/O 的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会尽最大可能从应用程序拷贝数据到发送缓冲区中，并立即从 write 等函数调用中返回。返回值可能为0。<a id="more"></a></li></ul><p>也就是说：</p><ul><li>阻塞 I/O 的流程：拷贝→直到所有数据拷贝至发送缓冲区完成→返回。</li><li>非阻塞 I/O 的流程：拷贝→返回→再拷贝→再返回。</li></ul><p>循环写入：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向文件描述符 fd 写入 n 字节数 */</span></span><br><span class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span>      nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span>     nwritten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ptr;</span><br><span class="line"> </span><br><span class="line">    ptr = data;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="comment">// 如果还有数据没被拷贝完成，就一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/* 这里 EINTR 是非阻塞 non-blocking 情况下，通知我们再次调用 write() */</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;      </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;         <span class="comment">/* 出错退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 指针增大，剩下字节数变小 */</span></span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr   += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下表总结了 read 和 write 在阻塞模式和非阻塞模式下的不同行为特性：<br><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/table823.png" alt="table823" style="zoom: 80%;"><br>阻塞模式下的 write 有个特例, 就是对方主动关闭了套接字，这个时候 write 调用会立即返回，并通过返回值告诉应用程序实际写入的字节数，如果再次对这样的套接字进行 write 操作，就会返回失败。失败是通过返回值 -1 来通知到应用程序的。</p><p><strong>accept</strong></p><p>有必要将监听套接字设置为非阻塞的，对于 accept 的返回值，需要正确地处理各种看似异常的错误，例如忽略 EWOULDBLOCK、EAGAIN 等。</p><p><strong>connect</strong></p><p>在非阻塞 TCP 套接字上调用 connect 函数，会立即返回一个 EINPROGRESS 错误。TCP 三次握手会正常进行，应用程序可以继续做其他初始化的事情。当该连接建立成功或者失败时，通过 I/O 多路复用 select、poll 等可以进行连接的状态检测。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>下面这张图来自 The Linux Programming Interface(No Starch Press)。这张图直观地为我们展示了 select、poll、epoll 几种不同的 I/O 复用技术在面对不同文件描述符大小时的表现差异。</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/epolltable.png" alt="epolltable"></p><p>epoll 的性能是最好的，而随着文件描述符的增大，常规的 select 和 poll 方法性能逐渐变得很差。</p><p>本质上 epoll 还是一种 I/O 多路复用技术， epoll 通过监控注册的多个描述字，来进行 I/O 事件的分发处理。不同于 poll 的是，epoll 不仅提供了默认的 level-triggered（条件触发）机制，还提供了性能更为强劲的 edge-triggered（边缘触发）机制。</p><p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 epoll_create，epoll_ctl 和 epoll_wait。</p><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size &gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值: 若成功返回一个大于 0 的值，表示 epoll 实例；若返回 -1 表示出错</span></span><br></pre></td></tr></table></figure><p>epoll_create() 方法创建了一个 epoll 实例,这个 epoll 实例被用来调用 epoll_ctl 和 epoll_wait，如果这个 epoll 实例不再需要，比如服务器正常关机，需要调用 close() 方法释放 epoll 实例，这样系统内核可以回收 epoll 实例所分配使用的内核资源。</p><p>在一开始的 epoll_create 实现中，<code>size</code>是用来告知内核期望监控的文件描述字大小，然后内核使用这部分的信息来初始化内核数据结构，在新的实现中，这个参数不再被需要，因为内核可以动态分配需要的内核数据结构。</p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值: 若成功返回 0；若返回 -1 表示出错</span></span><br></pre></td></tr></table></figure><p>在创建完 epoll 实例之后，可以通过调用 epoll_ctl 往这个 epoll 实例增加或删除监控的事件。函数 epll_ctl 有 4 个入口参数。</p><p>第一个参数 <code>epfd</code> 是刚刚调用 epoll_create 创建的 epoll 实例描述字，可以简单理解成是 epoll 句柄。</p><p>第二个参数 <code>op</code> 表示增加还是删除一个监控事件，它有三个选项可供选择：</p><ul><li>EPOLL_CTL_ADD： 向 epoll 实例注册 fd 对应的事件；</li><li>EPOLL_CTL_DEL：向 epoll 实例删除 fd 对应的事件；</li><li>EPOLL_CTL_MOD： 修改 fd 对应的事件。</li></ul><p>第三个参数 <code>fd</code> 是注册的事件的文件描述符，比如一个监听套接字。</p><p>第四个参数表示的是注册的事件类型，并且可以在这个结构体里设置用户需要的数据，其中最为常见的是使用联合结构里的 fd 字段，表示事件所对应的文件描述符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">     <span class="keyword">void</span>        *ptr;  <span class="comment">//指定与fd相关的用户数据。</span></span><br><span class="line">     <span class="keyword">int</span>          fd;    <span class="comment">//指定事件所从属的目标文件描述符。</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">     <span class="keyword">uint64_t</span>     u64;</span><br><span class="line"> &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>其中 events 成员描述事件类型。epoll 支持的事件类型和 poll 基本相同,都是基于 mask 的事件类型。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的数据可读事件是EPOLLIN。但epoll有两个额外的事件类型——EPOLLET和EPOLLONESHOT。</p><ul><li>EPOLLIN：表示对应的文件描述字可以读；</li><li>EPOLLOUT：表示对应的文件描述字可以写；</li><li>EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</li><li>EPOLLHUP：表示对应的文件描述字被挂起；</li><li>EPOLLET：设置为 edge-triggered，默认为 level-triggered。</li></ul><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line"></span><br><span class="line">//返回值: 成功返回的是一个大于 0 的数，表示事件的个数；返回 0 表示的是超时时间到；若出错返回 -1.</span><br></pre></td></tr></table></figure><p>epoll_wait() 函数与 poll 和 select 函数类似，调用者进程被挂起，在等待内核 I/O 事件的分发。</p><p>第一个参数是 epoll 实例描述字，也就是 epoll 句柄。</p><p>第二个参数返回给用户空间需要处理的 I/O 事件，这是一个数组，数组的大小由 epoll_wait 的返回值决定，这个数组的每个元素都是一个需要待处理的 I/O 事件，其中 events 表示具体的事件类型，事件类型取值和 epoll_ctl 可设置的值一样，这个 epoll_event 结构体里的 data 值就是在 epoll_ctl 那里设置的 data，也就是用户空间和内核空间调用时需要的数据。</p><p>epoll_wait 函数如果检测到事件，就将所有就绪的事件从内核事件表（由 epfd 参数指定）中复制到它的第二个参数 <code>events</code> 指向的数组中。这个数组只用于输出 epoll_wait 检测到的就绪事件，而不像 select 和 poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。</p><p>第三个参数 <code>maxevents</code> 是一个大于 0 的整数，指定最多监听多少个事件，表示 epoll_wait 可以返回的最大事件值。</p><p>第四个参数 <code>timeout</code> 是 epoll_wait 阻塞调用的超时值，如果这个值设置为 -1，表示不超时；如果设置为 0 则立即返回，即使没有任何 I/O 事件发生。</p><p><strong>poll 和 epoll在使用上的差别</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何索引 poll 返回的就绪文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> ret=poll(fds,MAX_EVENT_NUMBER,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_EVENT_NUMBER;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fds[i].revents＆POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd=fds[i].fd;</span><br><span class="line">        <span class="comment">/*处理sockfd*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何索引epoll返回的就绪文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> ret=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ret;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd=events[i].data.fd;</span><br><span class="line">    <span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h3><p>edge-triggered :边缘触发</p><blockquote><p>边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p></blockquote><p>level-triggered:条件触发</p><blockquote><p>条件触发的意思是只要满足事件的条件，比如有数据需要读，就一直不断地把这个事件传递给用户。</p></blockquote><p>一般我们认为，<strong>边缘触发的效率比条件触发的效率要高。</strong></p><p>epoll 通过改进的接口设计，避免了用户态 - 内核态频繁的数据拷贝，大大提高了系统性能。在使用 epoll 的时候，我们一定要理解条件触发和边缘触发两种模式。条件触发的意思是只要满足事件的条件，比如有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;阻塞-VS-非阻塞&quot;&gt;&lt;a href=&quot;#阻塞-VS-非阻塞&quot; class=&quot;headerlink&quot; title=&quot;阻塞 VS 非阻塞&quot;&gt;&lt;/a&gt;阻塞 VS 非阻塞&lt;/h3&gt;&lt;p&gt;阻塞 VS 非阻塞&lt;br&gt;当应用程序调用阻塞 I/O 完成某个操作时，应用程序会被挂起，等待内核完成操作，感觉上应用程序像是被“阻塞”了一样。实际上，内核所做的事情是将 CPU 时间切换给其他有需要的进程，网络应用程序在这种情况下就会得不到 CPU 时间做该做的事情。&lt;/p&gt;
&lt;p&gt;非阻塞 I/O 则不然，当应用程序调用非阻塞 I/O 完成某个操作时，内核立即返回，不会把 CPU 时间切换给其他进程，应用程序在返回后，可以得到足够的 CPU 时间继续完成其他事情。&lt;/p&gt;
&lt;h3 id=&quot;非阻塞-I-O&quot;&gt;&lt;a href=&quot;#非阻塞-I-O&quot; class=&quot;headerlink&quot; title=&quot;非阻塞 I/O&quot;&gt;&lt;/a&gt;非阻塞 I/O&lt;/h3&gt;&lt;h4 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; class=&quot;headerlink&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h4&gt;&lt;p&gt;如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下 read 调用会立即返回，一般返回 EWOULDBLOCK 或 EAGAIN 出错信息。在这种情况下，出错信息是需要小心处理，比如后面再次调用 read 操作，而不是直接作为错误直接返回。&lt;/p&gt;
&lt;h4 id=&quot;写操作&quot;&gt;&lt;a href=&quot;#写操作&quot; class=&quot;headerlink&quot; title=&quot;写操作&quot;&gt;&lt;/a&gt;写操作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在阻塞 I/O 情况下，write 函数返回的字节数，和输入的参数总是一样的。如果返回值总是和输入的数据大小一样。&lt;/li&gt;
&lt;li&gt;在非阻塞 I/O 的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会尽最大可能从应用程序拷贝数据到发送缓冲区中，并立即从 write 等函数调用中返回。返回值可能为0。
    
    </summary>
    
      <category term="网络编程" scheme="https://hongbosherlock.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O多路复用：select 和 poll</title>
    <link href="https://hongbosherlock.github.io/2021/08/08/select-poll/"/>
    <id>https://hongbosherlock.github.io/2021/08/08/select-poll/</id>
    <published>2021-08-08T14:44:50.000Z</published>
    <updated>2021-08-23T15:02:51.124Z</updated>
    
    <content type="html"><![CDATA[<ul><li>我们可以使用 fgets 方法等待标准输入，但无法同时在套接字有数据的时候读出数据；</li><li>我们也可以使用 read 方法等待套接字有数据返回，但无法同时在标准输入有数据的情况下，读入数据并发送给对方。</li></ul><p>I/O 多路复用的设计初衷就是解决这样的场景。我们可以把标准输入、套接字等都看做 I/O 的一路，多路复用的意思，就是在任何一路 I/O 有“事件”发生的情况下，通知应用程序去处理相应的 I/O 事件，这样我们的程序在同一时刻就仿佛可以处理多个 I/O 事件。</p><h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p><strong>函数声明</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回：若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1</span></span><br></pre></td></tr></table></figure></p><p>n 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。比如现在的 select 待测试的描述符集合是{0,1,4}，那么 maxfd 就是 5。<a id="more"></a></p><p>三个描述符集合：</p><ul><li>读描述符集合 readset ，通知内核，在哪些描述符上检测数据可以读。</li><li>写描述符集合 writeset ，哪些描述符可以写。</li><li>异常描述符集合 exceptse，哪些描述符有异常发生。</li></ul><p>使用下面的宏设置描述符集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set *fdset);　　　　　　</span><br><span class="line">void FD_SET(int fd, fd_set *fdset);　　</span><br><span class="line">void FD_CLR(int fd, fd_set *fdset);　　　</span><br><span class="line">int  FD_ISSET(int fd, fd_set *fdset);</span><br></pre></td></tr></table></figure></p><p>下面一个向量代表了一个描述符集合，其中，这个向量的每个元素都是二机制数中的 0 或者 1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[maxfd-1], ..., a[1], a[0]</span><br></pre></td></tr></table></figure></p><ul><li>FD_ZERO 用来将这个向量的所有元素都设置成 0；</li><li>FD_SET 用来把对应套接字 fd 的元素，a[fd] 设置成 1；</li><li>FD_CLR 用来把对应套接字 fd 的元素，a[fd] 设置成 0；</li><li>FD_ISSET 对这个向量进行检测，判断出对应套接字的元素 a[fd] 是 0 还是 1。</li></ul><p>其中 0 代表不需要处理，1 代表需要处理。三个描述符集合中的每一个都可以设置成空，这样就表示不需要内核进行相关的检测。</p><p> timeval 结构体时间：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> struct timeval &#123;</span><br><span class="line">  long   tv_sec; /* seconds */</span><br><span class="line">  long   tv_usec; /* microseconds */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>设置成空 (NULL)，表示如果没有 I/O 事件发生，则 select 一直等待下去。</li><li>设置一个非零的值，这个表示等待固定的一段时间后从 select 阻塞调用中返回，</li></ul><p><strong>socket_fd 可读的几种情况</strong></p><ul><li>第一种情况是套接字接收缓冲区有数据可以读，如果我们使用 read 函数去执行读操作，肯定不会被阻塞，而是会直接读到这部分数据。</li><li>第二种情况是对方发送了 FIN，使用 read 函数执行读操作，不会被阻塞，直接返回 0。</li><li>第三种情况是针对一个监听套接字而言的，有已经完成的连接建立，此时使用 accept 函数去执行不会阻塞，直接返回已经完成的连接。</li><li>第四种情况是套接字有错误待处理，使用 read 函数去执行读操作，不阻塞，且返回 -1。</li></ul><p>select 检测套接字可写，完全是基于套接字本身的特性来说的，具体来说有以下几种情况:</p><ul><li>第一种是套接字发送缓冲区足够大，如果我们使用非阻塞套接字进行 write 操作，将不会被阻塞，直接返回。</li><li>第二种是连接的写半边已经关闭，如果继续进行写操作将会产生 SIGPIPE 信号。</li><li>第三种是套接字上有错误待处理，使用 write 函数去执行读操作，不阻塞，且返回 -1。</li></ul><p>总结成一句话就是，内核通知我们套接字可以往里写了，使用 write 函数就不会阻塞。</p><p><strong>select 缺点</strong>：支持的文件描述符的个数是有限的。在 Linux 系统中，select 的默认最大值为 1024。</p><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假裝我們此時已經都連線到 server 了</span></span><br><span class="line">    <span class="comment">//s1 = socket(...);</span></span><br><span class="line">    <span class="comment">//connect(s1, ...)...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> recv_line[MAXLINE], send_line[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="comment">// 在 timeout 以前會一直等待，看是否已經有資料可以接收的 socket（timeout 時間是 10.5 秒）</span></span><br><span class="line">    tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">    fd_set readmask;</span><br><span class="line">    fd_set allreads;</span><br><span class="line">    FD_ZERO(&amp;allreads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;allreads);</span><br><span class="line">    FD_SET(socket_fd, &amp;allreads);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        readmask = allreads;</span><br><span class="line">        <span class="keyword">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;readmask, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">"select failed"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Timeout occurred!  No data after 10.5 seconds.\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;readmask)) &#123;</span><br><span class="line">                n = read(socket_fd, recv_line, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">"read error"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"server terminated \n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                recv_line[n] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">fputs</span>(recv_line, <span class="built_in">stdout</span>);</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">"\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readmask)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fgets(send_line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="built_in">strlen</span>(send_line);</span><br><span class="line">                    <span class="keyword">if</span> (send_line[i - <span class="number">1</span>] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                        send_line[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">     </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"now sending %s\n"</span>, send_line);</span><br><span class="line">                    <span class="keyword">size_t</span> rt = write(socket_fd, send_line, <span class="built_in">strlen</span>(send_line));</span><br><span class="line">                    <span class="keyword">if</span> (rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">"write failed "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"send bytes: %zu \n"</span>, rt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h3><p>poll 函数的原型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>; </span><br><span class="line">　　　</span><br><span class="line"><span class="comment">//返回值：“returned events”中非 0 的描述符个数，若超时则为 0，若出错则为 -1</span></span><br></pre></td></tr></table></figure></p><p>第一个参数是一个 pollfd 的数组。其中 pollfd 的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int    fd;       /* file descriptor */</span><br><span class="line">    short  events;   /* events to look for */</span><br><span class="line">    short  revents;  /* events returned */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>描述符上待检测的事件类型 events 可以表示多个不同的事件，具体的实现可以通过使用二进制掩码位操作来完成。</p><p>events 类型的事件包括可读事件、可写事件和错误事件。</p><p><code>POLLIN</code>和 <code>POLLOUT</code> 可以表示读和写事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define    POLLIN    0x0001    /* any readable data available */</span><br><span class="line">#define    POLLPRI   0x0002    /* OOB/Urgent readable data */</span><br><span class="line">#define    POLLOUT   0x0004    /* file descriptor is writeable */</span><br></pre></td></tr></table></figure></p><p>和 select 非常不同的地方在于，<strong>poll 每次检测之后的结果不会修改原来的传入值，而是将结果保留在 revents 字段中</strong>，这样就不需要每次检测完都得重置待检测的描述字和感兴趣的事件。我们可以把 revents 理解成“returned events”。</p><p>events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。</p><p>第二个参数 <code>nfds</code> 描述的是数组 fds 的大小，简单说，就是向 poll 申请的事件检测的个数。</p><p>第三个参数 <code>timeout</code>，描述了 poll 的行为。</p><blockquote><p>timeout<0 表示在有事件发生之前永远等待；timeout="0，表示不阻塞进程，立即返回；timeout">0 表示 poll 调用方等待指定的毫秒数后返回。</0></p></blockquote><p>如果我们不想对某个 pollfd 结构进行事件检测，可以把它对应的 pollfd 结构的 fd 成员设置成一个负值。这样，poll 函数将忽略这样的 events 事件，检测完成以后，所对应的“returned events”的成员值也将设置为 0。</p><ul><li>在 select 里，文件描述符的个数已经随着 fd_set 的实现而固定，没有办法对此进行配置；</li><li>在 poll 里，我们可以控制 pollfd 结构的数组大小，即突破原来 select 函数最大描述符的限制，在这种情况下，应用程序调用者需要分配 pollfd 数组并通知 poll 函数该数组的大小。</li></ul><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;我们可以使用 fgets 方法等待标准输入，但无法同时在套接字有数据的时候读出数据；&lt;/li&gt;
&lt;li&gt;我们也可以使用 read 方法等待套接字有数据返回，但无法同时在标准输入有数据的情况下，读入数据并发送给对方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I/O 多路复用的设计初衷就是解决这样的场景。我们可以把标准输入、套接字等都看做 I/O 的一路，多路复用的意思，就是在任何一路 I/O 有“事件”发生的情况下，通知应用程序去处理相应的 I/O 事件，这样我们的程序在同一时刻就仿佛可以处理多个 I/O 事件。&lt;/p&gt;
&lt;h3 id=&quot;select-函数&quot;&gt;&lt;a href=&quot;#select-函数&quot; class=&quot;headerlink&quot; title=&quot;select 函数&quot;&gt;&lt;/a&gt;select 函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; struct timeval *timeout)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//返回：若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;n 表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1。比如现在的 select 待测试的描述符集合是{0,1,4}，那么 maxfd 就是 5。
    
    </summary>
    
      <category term="网络编程" scheme="https://hongbosherlock.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程基础：socket</title>
    <link href="https://hongbosherlock.github.io/2021/08/06/socket/"/>
    <id>https://hongbosherlock.github.io/2021/08/06/socket/</id>
    <published>2021-08-06T14:28:12.000Z</published>
    <updated>2021-08-23T15:06:23.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="socket-API"><a href="#socket-API" class="headerlink" title="socket API"></a>socket API</h3><p>socket 的主要API都定义在<code>sys/socket.h</code>头文件中</p><p>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。</p><blockquote><p>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p></blockquote><p>发送端总是把要发送的数据转化成大端字节序数据后再发送,因此<strong>大端字节序也称为网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。(JAVA虚拟机采用大端字节序)<br>为了保证网络字节序一致，POSIX 标准提供了如下的转换函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> htons (<span class="keyword">uint16_t</span> hostshort)</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs (<span class="keyword">uint16_t</span> netshort)</span><br><span class="line"><span class="keyword">uint32_t</span> htonl (<span class="keyword">uint32_t</span> hostlong)</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl (<span class="keyword">uint32_t</span> netlong)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数中的 n 代表的就是 network，h 代表的是 host</span></span><br><span class="line"><span class="comment">// s 表示的是 short，l 表示的是 long，分别表示 16 位和 32 位的整数。</span></span><br></pre></td></tr></table></figure><ul><li>AF_LOCAL：表示的是本地地址，对应的是 Unix 套接字，这种情况一般用于本地 socket 通信，很多情况下也可以写成 AF_UNIX、AF_FILE；</li><li>AF_INET：因特网使用的 IPv4 地址；</li><li>AF_INET6：因特网使用的 IPv6 地址。<a id="more"></a></li></ul><p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IPV4 套接字地址，32bit 值.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 描述 IPV4 的套接字地址格式  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 16-bit */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;     <span class="comment">/* 端口口  16-bit*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* Internet address. 32-bit */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 这里仅仅用作占位符，不做实际用处  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。</p><h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>我们一般用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>*src,<span class="keyword">void</span>*dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>*src,<span class="keyword">char</span>*dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中，af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno。</li><li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</li></ul><h3 id="TCP三次握手：怎么使用套接字格式建立连接？"><a href="#TCP三次握手：怎么使用套接字格式建立连接？" class="headerlink" title="TCP三次握手：怎么使用套接字格式建立连接？"></a>TCP三次握手：怎么使用套接字格式建立连接？</h3><h4 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h4><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure></p><p>domain 就是指 <code>PF_INET、PF_INET6</code> 以及 <code>PF_LOCAL</code> 等，表示什么样的套接字。</p><p>type 可用的值是：</p><ul><li><code>SOCK_STREAM</code>: 表示的是字节流，对应 TCP；</li><li><code>SOCK_DGRAM</code>： 表示的是数据报，对应 UDP；<br>-<code>SOCK_RAW</code>: 表示的是原始套接字。</li></ul><p>protocol 目前一般写成 0 即可。</p><p><strong>socket系统调用成功时返回一个socket文件描述符</strong>，失败则返回-1并设置errno。</p><h4 id="命名-socket"><a href="#命名-socket" class="headerlink" title="命名 socket"></a>命名 socket</h4><p>将一个socket与socket地址绑定称为给socket命名。<br>命名socket的系统调用是bind，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr* my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure></p><p>bind将<code>my_addr</code>所指的socket地址分配给未命名的<code>sockfd</code>文件描述符，<code>addrlen</code>参数指出该socket地址的长度。</p><p>初始化例子;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_socket</span> <span class="params">(<span class="keyword">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 创建字节流类型的 IPV4 socket. */</span></span><br><span class="line">  sock = socket (PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror (<span class="string">"socket"</span>);</span><br><span class="line">      <span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 绑定到 port 和 ip. */</span></span><br><span class="line">  name.sin_family = AF_INET; <span class="comment">/* IPV4 */</span></span><br><span class="line">  name.sin_port = htons (port);  <span class="comment">/* 指定端口 */</span></span><br><span class="line">  name.sin_addr.s_addr = htonl (INADDR_ANY); <span class="comment">/* 通配地址 */</span></span><br><span class="line">  <span class="comment">/* 把 IPV4 地址转换成通用地址格式，同时传递长度 */</span></span><br><span class="line">  <span class="keyword">if</span> (bind (sock, (struct sockaddr *) &amp;name, <span class="keyword">sizeof</span> (name)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror (<span class="string">"bind"</span>);</span><br><span class="line">      <span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="监听-socket"><a href="#监听-socket" class="headerlink" title="监听 socket"></a>监听 socket</h4><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure></p><p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。</p><h4 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h4><p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这个时候操作系统内核需要把这个事件通知到应用程序，并让应用程序感知到这个连接。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr*addr,<span class="keyword">socklen_t</span>*addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>sockfd</code>参数是执行过 listen 系统调用的监听 socket 。<code>addr</code>参数用来获取被接受连接的远端 socket 地址，该 socket 地址的长度由<code>addrlen</code>参数指出。 accept 成功时返回<strong>一个新的连接 socket</strong>，该 socket 唯一地标识了被接受的这个连接，服务器可通过读写该 socket 来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。</p><blockquote><p>accept只是从监听队列中取出连接，而不论连接处于何种状态（如<code>ESTABLISHED</code>状态和<code>CLOSE_WAIT</code>状态），更不关心任何网络状况的变化。</p></blockquote><p>监听socket字一直都存在，它是要为成千上万的客户来服务的，直到这个监听socket关闭；而一旦一个客户和服务器连接成功，完成了 TCP 三次握手，操作系统内核就为这个客户生成一个已连接socket，让应用服务器使用这个已连接socket和客户进行通信处理。如果应用服务器完成了对这个客户的服务，比如一次网购下单，一次付款成功，那么关闭的就是已连接socket，这样就完成了 TCP 连接的释放。请注意，这个时候释放的只是这一个客户连接，其它被服务的客户连接可能还存在。最重要的是，监听socket一直都处于“监听”状态，等待新的客户请求到达并服务。</p><h4 id="客户端发起连接-connect"><a href="#客户端发起连接-connect" class="headerlink" title="客户端发起连接 connect"></a>客户端发起连接 connect</h4><p>客户端和服务器端的连接建立，是通过 connect 函数完成的。这是 connect 的构建函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr*serv_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>sockfd</code>参数由 socket 系统调用返回一个 socket。<code>serv_addr</code>参数是服务器监听的 socket 地址，<code>addrlen</code>参数则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和ETIMEDOUT。</p><p><strong>如果不开启服务端，TCP 客户端的 connect 函数会直接返回“Connection refused”报错信息。</strong></p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/tcp_hands.png" alt="tcp_hands"></p><blockquote><p>服务器端通过 socket，bind 和 listen 完成了被动套接字的准备工作，被动的意思就是等着别人来连接，然后调用 accept，就会阻塞在这里，等待客户端的连接来临；客户端通过调用 socket 和 connect 函数之后，也会阻塞。</p></blockquote><ol><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，客户端进入 SYNC_SENT 状态；</li><li>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 k，服务器端进入 SYNC_RCVD 状态；</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ol><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>发送数据时常用的有三个函数，分别是 write、send 和 sendmsg。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write (<span class="keyword">int</span> socketfd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> send (<span class="keyword">int</span> socketfd, <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span><br><span class="line"><span class="comment">/*send 往 socketfd 上写入数据，buffer 和 size 参数分别指定写缓冲区的位置和大小。</span></span><br><span class="line"><span class="comment">send成功时返回实际写入的数据的长度，失败则返回-1并设置errno*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure></p><ul><li>第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。</li><li>如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。</li><li>如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。</li></ul><p><strong>发送缓冲区：</strong></p><p>发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。</p><p>内核会按照 TCP/IP 的语义，将缓冲区里的数据封装成 TCP 的 MSS 包，以及 IP 的 MTU 包，最后走数据链路层将数据发送出去。</p><p>当应用程序的数据完全放置到发送缓冲区里时，write 阻塞调用返回。注意返回的时刻，应用程序数据并没有全部被发送出去，发送缓冲区里还有部分数据，这部分数据会在稍后由操作系统内核通过网络发送出去。</p><blockquote><p>发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据。至于什么时候发送到对端的接收缓冲区，或者更进一步说，什么时候被对方应用程序缓冲所接收，对我们而言完全都是透明的。</p></blockquote><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/sendbuf.png" alt="sendbuf" style="zoom:80%;"></p><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>recv 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd,<span class="keyword">void</span>*buf,<span class="keyword">size_t</span> size,<span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure></p><p>recv 读取 sockfd 上的数据，buf 和 size 参数分别指定读缓冲区的位置和大小。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度size。因此我们可能要多次调用recv，才能读取到完整的数据。<br>recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p><blockquote><p>每次调用 recv 函数都是一次系统调用，需要从用户空间切换到内核空间，上下文切换的开销对于高性能来说最好是能省则省。</p></blockquote><p>read 函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read (<span class="keyword">int</span> socketfd, <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size)</span><br></pre></td></tr></table></figure></p><p>read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；如果返回值为 -1，表示出错。</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>关闭一个连接实际上就是关闭该连接对应的 socket，这可以通过如下关闭普通文件描述符的系统调用来完成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//若成功则为 0，若出错则为 -1。</span></span><br></pre></td></tr></table></figure></p><p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1。只有当fd的引用计数为0时，会对套接字进行彻底释放，并且会关闭 <strong>TCP 两个方向的数据流</strong>。多进程程序中，<strong>一次fork系统调用默认将使父进程中打开的socket的引用计数加1</strong>，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p><p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure></p><p>howto 是这个函数的设置选项，它的设置有三个主要选项：</p><ul><li>SHUT_RD(0)：关闭连接的“读”这个方向，对该套接字进行读操作直接返回 EOF。从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。</li><li>SHUT_WR(1)：关闭连接的“写”这个方向，这就是常被称为”半关闭“的连接。此时，不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端。应用程序如果对该套接字进行写操作会报错。</li><li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向。</li></ul><p><strong>close 和 shutdown 的差别:</strong></p><ul><li><p>第一个差别：close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源。</p></li><li><p>第二个差别：close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响。</p></li><li><p>第三个差别：close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文，这在我们打算关闭连接通知对端的时候，是非常重要的</p></li></ul><h4 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h4><p>服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。</p><p>服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</p><p>I/O模型有多种，图中，服务器使用的是I/O复用技术之一的select系统调用。当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。</p><p>如果客户端主动关闭连接，则服务器执行被动关闭连接。至此，双方的通信结束。需要注意的是，服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客户的请求，才能继续处理下一个客户请求）。图中，服务器同时监听多个客户请求是通过select系统调用实现的。</p><p>TCP服务器和TCP客户端的工作流程：</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/cs_socket.jpg" alt="cs_socket"></p><h3 id="UDP-编程"><a href="#UDP-编程" class="headerlink" title="UDP 编程"></a>UDP 编程</h3><p>UDP 是一种“数据报”协议，而 TCP 是一种面向连接的“数据流”协议。<br>下面这张图是 UDP 程序设计时的主要过程。</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/udp.png" alt="udp" style="zoom: 25%;"></p><ul><li>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 recvfrom 函数等待客户端的报文发送；</li><li>客户端创建套接字之后，调用 sendto 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程。</li></ul><p>recvfrom 和 sendto 是 UDP 用来接收和发送报文的两个主要函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, </span><br><span class="line">　　　　　　　　　　struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure></p><p><strong>recvfrom</strong>读取本地创建的套接字<code>sockfd</code>上的数据，<code>buff</code>和<code>len</code>参数分别指定读缓冲区的位置和大小。因为 UDP 通信没有连接的概念，所以我们每次读取数据都需要获取发送端的 socket 地址，即参数<code>src_addr</code>所指的内容，<code>addrlen</code>参数则指定该地址的长度。返回值是实际接收的字节数。</p><p><strong>sendto</strong>往<code>sockfd</code>上写入数据，<code>buff</code>和<code>len</code>参数分别指定写缓冲区的位置和大小。<code>dest_addr</code>参数指定接收端的 socket 地址，<code>addrlen</code>参数则指定该地址的长度。返回值是实际发送的字节数。</p><p>TCP 断联之后必须重新连接才可以发送报文信息。但是 UDP 报文的”无连接“的特点，可以在 UDP 服务器重启之后，继续进行报文的发送，这就是 UDP 报文“无上下文”的最好说明。</p><h4 id="UDP的连接"><a href="#UDP的连接" class="headerlink" title="UDP的连接"></a>UDP的连接</h4><p>我们可以对 UDP 套接字调用 connect 函数，将 UDP 套接字和 IPv4 地址进行“绑定”。但是和 TCP connect 调用引起 TCP 三次握手，建立 TCP 有效连接不同，UDP connect 函数的调用，并不会引起和服务器目标端的网络交互。</p><ul><li>UDP 无 connect 时，在服务器端不开启的情况下，客户端程序是不会报错的，程序只会阻塞在 recvfrom 上，等待返回（或者超时）。</li><li>通过对 UDP 套接字进行 connect 操作，将 UDP 套接字建立了”上下文“，该套接字和服务器端的地址和端口产生了联系，正是这种绑定关系给了操作系统内核必要的信息，能够将操作系统内核收到的信息和对应的套接字进行关联。</li></ul><p>当调用 sendto 或者 send 操作函数时，应用程序报文被发送，我们的应用程序返回，操作系统内核接管了该报文，之后操作系统开始尝试往对应的地址和端口发送，因为对应的地址和端口不可达，一个 ICMP 报文会返回给操作系统内核，该 ICMP 报文含有目的地址和端口等信息。</p><p>操作系统内核可以从映射表中找出是哪个 UDP 套接字拥有该目的地址和端口，以快速返回异步错误的信息。</p><p>连接套接字是需要一定开销的，比如需要查找路由表信息。所以，UDP 客户端程序通过 connect 可以获得一定的性能提升。</p><h3 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h3><p>本地套接字一般也叫做 UNIX 域套接字，最新的规范已经改叫本地套接字。本地套接字是本地进程间通信（IPC）的一种实现方式。利用本地套接字可以完成可靠字节流和数据报两种协议。</p><p>本地套接字是一种特殊类型的套接字，和 TCP/UDP 套接字不同。TCP/UDP 即使在本地地址通信，也要走系统网络协议栈，而本地套接字，严格意义上说提供了一种<strong>单主机跨进程间调用的手段</strong>，减少了协议栈实现的复杂度，效率比 TCP/UDP 套接字都要高许多。类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等。</p><p>UNIX本地域协议族使用如下专用socket地址结构体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_UNIX*/</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];<span class="comment">/*文件路径名*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用 netstat 查看本地 socket 连接状况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -a -p -A unix</span><br></pre></td></tr></table></figure></p><ul><li>本地套接字本质还是进程间通信，只是借助了套接字的编程语义，比如stream和datagram，最下面肯定不走IP协议的。</li><li>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议。</li><li>本地套接字的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报套接字实现。</li></ul><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;socket-API&quot;&gt;&lt;a href=&quot;#socket-API&quot; class=&quot;headerlink&quot; title=&quot;socket API&quot;&gt;&lt;/a&gt;socket API&lt;/h3&gt;&lt;p&gt;socket 的主要API都定义在&lt;code&gt;sys/socket.h&lt;/code&gt;头文件中&lt;/p&gt;
&lt;p&gt;现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发送端总是把要发送的数据转化成大端字节序数据后再发送,因此&lt;strong&gt;大端字节序也称为网络字节序&lt;/strong&gt;，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。(JAVA虚拟机采用大端字节序)&lt;br&gt;为了保证网络字节序一致，POSIX 标准提供了如下的转换函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; htons (&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; hostshort)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; ntohs (&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; netshort)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; htonl (&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; hostlong)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; ntohl (&lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; netlong)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里函数中的 n 代表的就是 network，h 代表的是 host&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// s 表示的是 short，l 表示的是 long，分别表示 16 位和 32 位的整数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;AF_LOCAL：表示的是本地地址，对应的是 Unix 套接字，这种情况一般用于本地 socket 通信，很多情况下也可以写成 AF_UNIX、AF_FILE；&lt;/li&gt;
&lt;li&gt;AF_INET：因特网使用的 IPv4 地址；&lt;/li&gt;
&lt;li&gt;AF_INET6：因特网使用的 IPv6 地址。
    
    </summary>
    
      <category term="网络编程" scheme="https://hongbosherlock.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>一点关于“朋友”的感想</title>
    <link href="https://hongbosherlock.github.io/2021/07/12/friend/"/>
    <id>https://hongbosherlock.github.io/2021/07/12/friend/</id>
    <published>2021-07-12T13:20:39.000Z</published>
    <updated>2021-08-23T15:05:13.839Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/02.jpg" alt="02"></p><p>上周六下午我们三个人给别的学院拍照，最后出了点意外。在操场上他们把队形好不容易摆好了，但是无人机出了问题，最后这个场景就拍不了了。</p><p>虽然挺尴尬的，但我有了一点感想，这件事算是个引子吧。</p><p>看到过网上有讨论，自己也想过：什么才算朋友呢？<a id="more"></a></p><ul><li>一起拍过照/一起玩过/一起吃过饭 ，这些可能只是刚开始。</li><li>一起吃同一块东西/一起睡过觉，这算更近了一步。</li></ul><p>我今天想到的是一起共事，既包括把事情做成功，也包括失败。（有些事情一个人很难carry住）</p><p>成功可能是大家实力都可以，或者是运气好。失败的原因可能会有很多，重要的是如何面对失败，面对自己，对待队友。</p><p><strong>在互相进步的过程中，友谊可能就得到了升华。</strong></p><p>关于友谊，芝加哥大学心理系教授米哈里·契克森米哈赖的《当下的幸福》中这样说：</p><p>如果友谊只是消除自我不安全感的手段，那么它虽然还是能给人快乐，却不具有乐趣的作用，也无法帮助成长。例如，酒肉朋友在全世界的小社区中都很常见，成年男性聚在一起嘻嘻哈哈，在酒店、小酒馆、餐厅、茶艺馆、咖啡厅、啤酒屋的欢乐气氛下，借打牌、掷飞镖、下棋消磨时间，或一边拌嘴、互相嘲弄。每个人都对别人的观念和癖好付出注意力，并由此互相肯定自我存在的价值。</p><p>这种社交方式只是模拟友谊，并不能提供真正的友谊。每个人偶尔花一天嚼舌根，都会觉得有趣，但很多人却变得极端依赖每天肤浅的接触。</p><p>与同侪为伴的经验跟所有其他活动一样，可分成不同的层次：最低的层次最简单，但只是暂时摒除混沌、制造快乐的一种方法；最高层次则能带来高度的乐趣与成长。</p><p>最强烈的体验也是在亲密友谊之中产生的。亚里士多德曾说：“纵使拥有世上所有的宝物，如果没有友谊，也没有人能活得下去。”指的就是这样的关系。从一对一的友谊中得到乐趣，需要心流活动的全部条件。不但要有共同的目标、相互的回馈（这些在一般酒吧或鸡尾酒会上的互动也能提供），更需要从共处中发掘新的挑战。这也许只是一天比一天更了解朋友，发现他与众不同的地方，同时也渐渐崭露自己的独特之处。</p><p>跟另一个人分享自己的秘密和思想，可谓是人间至乐。这些条件虽然乍看很普通，事实上却需要大量的注意力、开放的态度和敏锐的感觉。现实生活中，在友谊上投注这么多精神能量的实例却少得可怜，因为很少有人愿意付出这么多精力和时间。</p><p>愿你也能遇到可以交心的朋友，享受快乐的同时，也能一起成长。</p><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/02.jpg&quot; alt=&quot;02&quot;&gt;&lt;/p&gt;
&lt;p&gt;上周六下午我们三个人给别的学院拍照，最后出了点意外。在操场上他们把队形好不容易摆好了，但是无人机出了问题，最后这个场景就拍不了了。&lt;/p&gt;
&lt;p&gt;虽然挺尴尬的，但我有了一点感想，这件事算是个引子吧。&lt;/p&gt;
&lt;p&gt;看到过网上有讨论，自己也想过：什么才算朋友呢？
    
    </summary>
    
      <category term="随想" scheme="https://hongbosherlock.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>我们都渴望安全与正义</title>
    <link href="https://hongbosherlock.github.io/2021/05/30/safe-and-justice/"/>
    <id>https://hongbosherlock.github.io/2021/05/30/safe-and-justice/</id>
    <published>2021-05-30T13:38:31.000Z</published>
    <updated>2021-08-23T15:05:44.882Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/0.jpg" alt="0" style="text-align: center"></p><h3 id="Skynet"><a href="#Skynet" class="headerlink" title="Skynet"></a>Skynet</h3><blockquote><p>如果你认为《发条橙》《少数派报告》之类作品所表达的观点是非常重要、必须坚守的，那么在这类文明框架下，无论采取什么措施，恶性犯罪都不可能减少到你我期望的样子。我们只能接受，并认为这是文明的必要之代价。</p><p>这就是为什么我一直觉得可期的解决方案只有 Skynet Rising</p><p>—— tombkeeper</p></blockquote><p><a id="more"></a>2016 年 年11月，一篇“看脸识罪犯”的论文令学术界和舆论界炸开了锅。这篇论文题为《基于面部图像的自动犯罪概率推断》。在实验中，作者选取了1856张中国成年男子的面部照片，其中730张是已经定罪的罪犯身份证照片，其余1126张是在网络上抓取的普通人照片。经过机器学习，算法鉴别出犯罪嫌疑人的准确率达到89%。详细信息请看澎湃新闻的报道[1]。</p><p>这篇文章引起了国内外的一些批评和质疑，有美国学者指责其研究在搞“科学种族主义”。这件事情也涉及到人工智能伦理方面的问题，由于人类司法系统中存在一些歧视（譬如美国司法对白人和黑人存在量刑歧视），用这些带有歧视的人类数据训练机器，机器得到的结果也会是歧视性的。而若将这些内嵌歧视的算法用作司法工具，那么就会形成一个歧视性的反馈循环，让歧视在社会中更为巩固。</p><p>论文作者说他们在论文中声明了“我们无意也无学术资质去讨论社会偏见问题”，却“被”解读了。而且文中也一再声明了他们的纯学术，纯技术初衷，再次强调他们的研究无意也无法用于司法实践。</p><p>顺风车也是这个问题。前几年滴滴的顺风车安全事件曾经处于舆论的风头浪尖，导致初衷是为了方便大家出行的顺风车业务被关闭。TK 说他曾经非常仔细地推演过，无解。在顺风车问题上，安全、廉价、政治正确三者无法同时达成。</p><h3 id="丛林能力"><a href="#丛林能力" class="headerlink" title="丛林能力"></a>丛林能力</h3><blockquote><p>一杯水，用温度计量一下，是 20 度。但这杯水里一定有些局部的分子运动水平只相当于 0 度。</p><p>文明社会也只是一个宏观的、统计学意义上的概念。作为整体，不能放弃追求程序正义。作为个体，不能放弃建设丛林能力。</p><p>—— tombkeeper</p></blockquote><p>既然国家有责任维持治安，那为什么还要提醒女性自己重视人身安全？因为社会安全也是一个宏观的概念，仍然不可避免地有部分人做出极端危险的事情。</p><p>电影《教父》的开头，殡仪店的老板过来请柯里昂帮忙，他也是意大利人。他说他相信美国，在美国发了财，还以美国方式教养女儿。可是自己视如珍宝的女儿被交往不久的社会青年给毁了，他像一个守法的美国人一样去报了警，两个男孩受到了审判，但却是缓刑，他们当天就自由了，而他像个傻瓜似的站在法庭中，那两个混蛋还朝着他笑。于是他对太太说：“为求公道，我们必须去找柯里昂阁下。”</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/23.jpg" alt="23" style="zoom:80%;"></p><p>2017 年英国发生了一场入室抢劫杀人案[2]，一个华裔老太太被歹徒打伤，最终因为伤势过重去世。警方费尽心机抓住了三名嫌疑犯，而令许多人无奈的是，最终因为证据不足，只能让嫌疑人在拘留期满后无罪释放…  当地有的华人在接受媒体采访时表示：自己家几乎每年都会被抢劫，他们已经完全不信任和指望警察能干什么了。</p><p>2012 年西班牙华人酒吧曾发生一场命案[3]。在西班牙巴塞罗那近郊SABADELL市，一对开酒吧的华人夫妇杀死了一个吉普赛人。四名吉普赛青年酒后在酒吧闹事，妻子报警时被他们抢砸手机，推到在地受伤。丈夫为了保护妻子与四个吉普赛青年扭打了起来。寡不敌众，他顺手拿了起来了一把切面包的长刀，在搏斗中，一刀刺进了一名吉普赛青年的颈部，被刺的青年不久就倒下了。</p><p>被杀的吉普赛人在当地小有名气，但是社会舆论偏向华人。在西班牙人眼里，华人是忍耐力极强的族群，如果不是真的“忍无可忍”，他们决不会反抗。虽然是吉普赛人先惹的麻烦，但这对华人夫妇是不幸的，保护自己却无意伤了人命，他们最终还是要面对当地法律。</p><p>据说老板坐了一段时间牢就出来了，后来那个区域的吉普赛人就再也不敢惹那边的华人商铺。</p><p>“作为整体，不能放弃追求程序正义”，也就是说遇到问题，我们还是要首先诉诸法律，相信法律正义。当不得以时再使用个体的智慧和丛林能力。</p><h3 id="少数派报告"><a href="#少数派报告" class="headerlink" title="少数派报告"></a>少数派报告</h3><blockquote><p>挪威那个杀了七八十个人的布雷维克还记得吗？在人均收入全球第二的国家，社会应该怎么关爱他来避免他杀人？</p><p>人们既不喜欢一切《少数派报告》式的犯罪预防措施，又幻想不需要这样的措施也有办法避免暴力犯罪。</p><p>———tombkeeper</p></blockquote><p>机器之心报道[4]，去年在一份长长的公开信中，数千名 AI 研究人员呼吁科学出版商 Springer Nature 不要发表一篇论文。该研究提出了一种面部识别系统，能够预测一个人是否为犯罪分子。论文中研究人员称该技术没有种族偏见，根据照片中人的面部特征预测是否为罪犯的准确性达到了 80％，这一深度学习方法是面向执法机构开发的。</p><p>公开信的组织者之一 Audrey Beard 在一份邮件声明中表示：「根本无法开发出不存在种族偏见的犯罪预测系统，因为刑事司法数据本身就是存在种族偏见的。」</p><p>无论是大连轿车撞人逃逸还是南京新街口驾车撞人、持刀捅人事件，我们在因现场的情况惊心动魄时，也对这些施暴者深恶痛绝。</p><p>世界各地每年都会有类似的事情发生，我们有一天会像《少数派报告》那样去预防犯罪事件吗？人们愿意为了安全出卖自己的隐私吗？这不仅是技术问题，也是伦理问题。</p><p>我们可以通过教育和法治还有社会保障来减少犯罪率，但是很难完全根绝这类犯罪的发生。所幸的是，恶人是少数，正义的力量总是大多数的，就像昨晚南京那位拍打车窗喊叫的小哥，那位义无反顾冲上去与施暴者搏斗的胖大哥。</p><p><strong>“在野蛮的屠宰场上，还是些有文明的微光浮现，那就是人性所在。”</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]澎湃新闻的报道: <em><a href="https://m.thepaper.cn/newsDetail_forward_1685972" target="_blank" rel="noopener">https://m.thepaper.cn/newsDetail_forward_1685972</a></em></p><p>[2]抢劫杀人案: <em><a href="https://weibo.com/2549228714/GgOrLgv90?type=comment#_rnd1622339737788" target="_blank" rel="noopener">https://weibo.com/2549228714/GgOrLgv90?type=comment#_rnd1622339737788</a></em></p><p>[3]一场命案: <em><a href="http://www.chinanews.com/hr/2012/09-24/4206327.shtml" target="_blank" rel="noopener">http://www.chinanews.com/hr/2012/09-24/4206327.shtml</a></em></p><p>[4]机器之心报道: <em><a href="https://tech.sina.com.cn/roll/2020-06-24/doc-iirczymk8741934.shtml" target="_blank" rel="noopener">https://tech.sina.com.cn/roll/2020-06-24/doc-iirczymk8741934.shtml</a></em></p><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/0.jpg&quot; alt=&quot;0&quot; style=&quot;text-align: center&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Skynet&quot;&gt;&lt;a href=&quot;#Skynet&quot; class=&quot;headerlink&quot; title=&quot;Skynet&quot;&gt;&lt;/a&gt;Skynet&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果你认为《发条橙》《少数派报告》之类作品所表达的观点是非常重要、必须坚守的，那么在这类文明框架下，无论采取什么措施，恶性犯罪都不可能减少到你我期望的样子。我们只能接受，并认为这是文明的必要之代价。&lt;/p&gt;
&lt;p&gt;这就是为什么我一直觉得可期的解决方案只有 Skynet Rising&lt;/p&gt;
&lt;p&gt;—— tombkeeper&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="随想" scheme="https://hongbosherlock.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么写博客和微博</title>
    <link href="https://hongbosherlock.github.io/2021/05/13/why-blog/"/>
    <id>https://hongbosherlock.github.io/2021/05/13/why-blog/</id>
    <published>2021-05-13T13:25:52.000Z</published>
    <updated>2021-08-23T14:42:21.649Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/123.jpg" alt="123" style="zoom: 67%;"></p><p>最近在web archive上发现了远古互联网时期TK教主在百度空间写的博客，同时也发现了caoz的博客。后面准备每发一篇文章，附带转载一篇TK或者caoz的博客，谨此记录。<a id="more"></a></p><h3 id="我为什么写Blog"><a href="#我为什么写Blog" class="headerlink" title="我为什么写Blog"></a>我为什么写Blog</h3><blockquote><p>2010-01-17 14:23 by tombkeeper</p></blockquote><p>前阵子benjurry再一次提醒我：有好几个月没有真正写一篇Blog了。他不知道的是，我正在又一次戒Blog。</p><p>就像很多人戒烟戒酒一样，我也多次戒Blog。从现在仍在写来看，显然暂时是都失败了。</p><p>我为什么要戒Blog呢？在一个有两千年文字狱传统的国家，写字是一件风险不确定的事。那些清洁摩天大楼的工人，虽然整天都在冒险，然而为了挣钱养家，不得已而为之。而我并不指望Blog挣钱吃饭，并无不得已之处。从利害算计上说，戒Blog是一个理性的选择。</p><p>我为什么要写Blog呢？每年都有很多人去登山攀岩，这并不能挣钱养家，甚至还要花不少钱，然而人们仍然愿意以身犯险。这是因为有些人觉得，人生应当如此，生活需要吃饱了撑的。刘勰说“蚌病成珠”，韩愈说“物不平则鸣”，大概就是我写Blog的原因。</p><p>我从事的并不是“越多人知道我越好”的那些类工作。Blog对我而言，非但不能赚钱，甚至都不是一个赚钱的辅助工具。所以我也没有尽可能扩大读者群的强烈愿望。事实上，我有时候还会刻意避免这种情况发生。譬如，经常使用一些过于书面化的语言，大段引用文言，使用一些晦涩的表述方法，以使文章产生选择性的可读性降低。</p><p>我写Blog更不指望说服别人，让原本有着另一想法的人接受我的观点。事实上，如果一个成年人的思想仍能轻易被一篇文章所改变，读了A便赞同A，读了B便赞同B，那么，这样的思想，也是不值得去改变的。对于持不同意见的朋友，如果能够放开思想，把我的观点作为一种可能性加以思考，我就很高兴了。</p><p>每当我犹豫要不要就某事写篇Blog的时候，常常会想：世上能访问互联网，又能阅读中文的数亿人中，必有人也是如我这般想的，这些人若能凑巧看到这篇Blog，该是多么欣慰。</p><h3 id="我为什么写微博"><a href="#我为什么写微博" class="headerlink" title="我为什么写微博"></a>我为什么写微博</h3><blockquote><p>来自tombkeeper 的 微博</p></blockquote><ul><li><p>我写过一篇Blog，叫《我为什么写Blog》。但我写微博的原因略有不同。微博不是坐而论道的理想载体，它最大的作用是为和我们观点类似，但语言能力稍逊的朋友提供与人谈论问题用的弹药。</p></li><li><p>我在《我为什么写Blog》中说过：“如果一个成年人的思想仍能轻易被一篇文章所改变，读了A便赞同A，读了B便赞同B，那么，这样的思想，也是不值得去改变的。对于持不同意见的朋友，如果能够放开思想，把我的观点作为一种可能性加以思考，我就很高兴了”。对微博来说，更是这样。</p></li><li><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/640.jpg" alt="640" style="zoom: 67%;"></p></li></ul><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>我为什么写blog呢，也有一些原因。可能是因为自己性格内向的原因，我时常会沉浸在自己的思考里，对于看到的听到的时常会冒出一些想法。当然据我观察，应该不止我一个人这样，不少人都有自己的思考和表达的欲望。但是我决定把这些想法写下来，一是总结和记录，因为在脑子里想和写出来讲明白确实是两码事。第二点，茫茫互联网中如果有人碰巧看到了我的blog，引起了共鸣，那是多么有趣的一件事。而如果能帮助到别人，那就更是我的荣幸了。</p><blockquote><p>在二十多岁的时候尽量把自己的想法写下来，到三十多岁的时候读一读，如果不觉得有什么大问题，那这就是你的思想。以此作为基准，要是有一天你开始反对这些，说明你开始衰老了，或者你的期权快能兑现了。</p><p>——tombkeeper</p></blockquote><p>现在互联网的问题不是信息太少，而是信息太多，大部分信息是垃圾信息。一种错觉是互联网的信息大爆炸缩小了信息差。但是垃圾信息太多，难以辨别，而有用的信息并没有那么容易获取，事实上反而扩大了信息差。还有推荐算法造成的信息茧房的问题，这里不再探讨过多。</p><p>依赖于我自认为比较优秀的信息搜索和筛选能力，我觉得我的信息源还是不错的，有博客、公众号、微博、Twitter等等。这些信息让我了解了更广阔的世界，有些也引领了我的思考，尤其是TK教主的微博。但是我也意识到了一个问题，这些信息是碎片，我也许可以凭借记忆力将有关联的信息联系起来，但终究是不完整的。 </p><p>孔子说：“吾尝终日不食，终夜不寝，以思，无益，不如学也”。荀子说：“吾尝终日而思矣，不如须臾之所学也”。杨绛曾对一个给她写信的年轻人说：“你的问题主要在于读书不多而想得太多”。我知道我肚子里的墨水有限，没有知识沉积的思考，就如地基不牢的大厦，是站不住的。</p><p>还是要读书，多读书，读好书。</p><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/123.jpg&quot; alt=&quot;123&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在web archive上发现了远古互联网时期TK教主在百度空间写的博客，同时也发现了caoz的博客。后面准备每发一篇文章，附带转载一篇TK或者caoz的博客，谨此记录。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——链表 (更新中)</title>
    <link href="https://hongbosherlock.github.io/2021/02/26/linkedlist/"/>
    <id>https://hongbosherlock.github.io/2021/02/26/linkedlist/</id>
    <published>2021-02-26T15:02:11.000Z</published>
    <updated>2021-02-26T15:11:04.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h3><p>定义一个单链表:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p> <strong>为了统一删除操作，可以手动给链表加一个空的头结点</strong><br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* start = sas;</span><br></pre></td></tr></table></figure></p><p>让我们从一个经典问题开始：</p><blockquote><p>给定一个链表，判断链表中是否有环。</p></blockquote><a id="more"></a><p>可以使用哈希表解决。但是，使用双指针技巧有一个更有效的解决方案。。</p><p>我们在链表中使用两个速度不同的指针时会遇到的情况：</p><ul><li>如果没有环，快指针将停在链表的末尾。</li><li>如果有环，快指针最终将与慢指针相遇。</li></ul><p>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。</p><h3 id="problem-141-环形链表"><a href="#problem-141-环形链表" class="headerlink" title="problem 141 环形链表"></a>problem 141 环形链表</h3><p>双指针</p><p>算法</p><p>通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><ul><li>如果链表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</li><li>如果链表中存在环，则</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-142-环形链表-II"><a href="#problem-142-环形链表-II" class="headerlink" title="problem 142 环形链表 II"></a>problem 142 环形链表 II</h3><p>To understand this solution, you just need to ask yourself these question.</p><p>Assume the distance from head to the start of the loop is x1<br>the distance from the start of the loop to the point fast and slow meet is x2</p><p>the distance from the point fast and slow meet to the start of the loop is x3</p><p>What is the distance fast moved? What is the distance slow moved? And their relationship?</p><ul><li>x1 + x2 + x3 + x2</li><li>x1 + x2</li><li>x1 + x2 + x3 + x2 = 2 (x1 + x2)</li></ul><p>Thus <code>x1 = x3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *detectCycle(struct ListNode *head) &#123;</span><br><span class="line">    if(head==NULL||head-&gt;next==NULL)</span><br><span class="line">return NULL;</span><br><span class="line">// 快慢结点起始点一样</span><br><span class="line">struct ListNode* slow=head;</span><br><span class="line">struct ListNode* fast=head;</span><br><span class="line">int f=0;</span><br><span class="line">while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">if(slow==fast)&#123;</span><br><span class="line">            f=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">if(f)&#123;</span><br><span class="line">slow = head;</span><br><span class="line">while(slow!=fast)&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-707-设计链表"><a href="#problem-707-设计链表" class="headerlink" title="problem 707 设计链表"></a>problem 707 设计链表</h3><p>有一个空的头结点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyLinkedList* <span class="title">myLinkedListCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyLinkedList *head = (MyLinkedList *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">MyLinkedList* p=obj-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123; </span><br><span class="line"><span class="keyword">if</span>(i==index)</span><br><span class="line"><span class="keyword">return</span> p-&gt;val;</span><br><span class="line"></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line">newnode-&gt;next = obj-&gt;next;</span><br><span class="line">obj-&gt;next = newnode;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(obj-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">obj = obj-&gt;next;</span><br><span class="line"></span><br><span class="line">obj-&gt;next = newnode;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>) <span class="keyword">return</span> myLinkedListAddAtHead(obj, val); ;</span><br><span class="line">MyLinkedList* newnode;</span><br><span class="line">newnode = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">newnode-&gt;val = val;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">MyLinkedList* p;</span><br><span class="line">p=obj; </span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">newnode-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = newnode;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">MyLinkedList *p,*q;</span><br><span class="line">p=obj;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> </span>&#123;</span><br><span class="line">MyLinkedList* p;</span><br><span class="line"><span class="keyword">while</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">p=obj;</span><br><span class="line">obj=obj-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = myLinkedListCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = myLinkedListGet(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtHead(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtTail(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtIndex(obj, index, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListDeleteAtIndex(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="problem-160-相交链表"><a href="#problem-160-相交链表" class="headerlink" title="problem 160 相交链表"></a>problem 160 相交链表</h3><p><strong>注意对相交的理解：</strong><br>相交不是看值相不相等，而是看两个链表是否公用一个地址。就是指向同一块内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(headA == <span class="literal">NULL</span>||headB == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span> = <span class="title">headA</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">b</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(a!= b)&#123;</span><br><span class="line">    a = a == <span class="literal">NULL</span>? headB : a-&gt;next;</span><br><span class="line">        b = b == <span class="literal">NULL</span>? headA : b-&gt;next;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkgy1g4h3qm3ob0j312e0i23zj.jpg" alt=""></p><p>如上图所示，初始时，a 和 b分别指向两个链表 A、B 的头结点，a 比 b 离尾结点快了一个结点，当 a 到达尾结点后指向链表 B 的头结点，当 b 到达尾结点后指向链表 A 的头结点，此时 a 和 b 离尾结点同样距离，两者会在两个链表的相交结点相遇。</p><ul><li>若没有相交节点，当两指针值都为 NULL 时，跳出循环。</li></ul><h3 id="problem-19-删除链表的倒数第-N-个结点"><a href="#problem-19-删除链表的倒数第-N-个结点" class="headerlink" title="problem 19 删除链表的倒数第 N 个结点"></a>problem 19 删除链表的倒数第 N 个结点</h3><p>为了使所有情况的删除操作一致，添加头结点指向原来的第一个结点，头指针指向头结点</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkgy1g4h5zlqoqwj31910f1abi.jpg" alt=""></p><p><strong>方法一：二次遍历</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">start = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode)); </span><br><span class="line">start-&gt;next=head;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">length++;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">length = length-n;</span><br><span class="line">first=start;</span><br><span class="line"><span class="keyword">while</span>(length)&#123;</span><br><span class="line">length--;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>=<span class="title">first</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">first-&gt;next=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> start-&gt;next;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L−n 步，时间复杂度为 O(L)。</li><li>空间复杂度：O(1)，我们只用了常量级的额外空间。</li></ul><p><strong>方法二：一次遍历</strong></p><p>我们可以使用两个指针而不是一个指针。</p><p>第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">if(head==NULL||head-&gt;next==NULL)</span><br><span class="line">return NULL;</span><br><span class="line">struct ListNode* start;</span><br><span class="line">start = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">start-&gt;next=head;  // 添加空的头结点，使得删除操作一致。</span><br><span class="line">struct ListNode* slow = start;</span><br><span class="line">struct ListNode* fast = start;</span><br><span class="line"></span><br><span class="line">n+=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">while(fast!=NULL)&#123;</span><br><span class="line">fast = fast -&gt; next;</span><br><span class="line">slow = slow-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">struct ListNode* p=slow-&gt;next;</span><br><span class="line">slow-&gt;next=p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">return start-&gt;next;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。</li><li>空间复杂度：O(1)，我们只用了常量级的额外空间。</li></ul><h3 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize slow &amp; fast pointers</span></span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Change this condition to fit specific problem.</span></span><br><span class="line"><span class="comment"> * Attention: remember to avoid null-pointer error</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">    slow = slow-&gt;next;          <span class="comment">// move slow pointer one step each time</span></span><br><span class="line">    fast = fast-&gt;next-&gt;next;    <span class="comment">// move fast pointer two steps each time</span></span><br><span class="line">    <span class="keyword">if</span> (slow == fast) &#123;         <span class="comment">// change this condition to fit specific problem</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// change return value to fit specific problem</span></span><br></pre></td></tr></table></figure><ul><li>在调用 next 字段之前，始终检查节点是否为空。</li><li>仔细定义循环的结束条件。</li></ul><h3 id="problem-206-反转链表"><a href="#problem-206-反转链表" class="headerlink" title="problem 206 反转链表"></a>problem 206 反转链表</h3><p><strong>方法一：迭代</strong></p><p>假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。</p><p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。</li><li>空间复杂度：O(1)。</li></ul><p><strong>方法二：递归</strong></p><p>递归版本关键在于反向工作。假设列表的其余部分已经被反转，现在该如何反转它前面的部分？</p><p>假设列表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 → ··· →n_&#123;k-1&#125; →n_k → n_&#123;k+1&#125;→ ...→n_m → \varnothing</span><br></pre></td></tr></table></figure></p><p>若从节点 $n_{k+1}$ 到 $n<em>m$已经被反转，而我们正处于 $n</em>{k}$ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 → ··· →n_&#123;k-1&#125; →n_k → n_&#123;k+1&#125; ← ... ←n_m</span><br></pre></td></tr></table></figure><p>我们希望 $n_{k+1$的下一个节点指向$n_k$。<br>所以，$n_k.next.next=n_k$</p><p>要小心的是 $n_{1}$ 的下一个必须指向$\varnothing$ 。如果忽略了这一点，链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><p><strong>递归方法一</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newhead</span> = <span class="title">reverseList</span>(<span class="title">head</span>-&gt;<span class="title">next</span>);</span></span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。</li><li>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</li></ul><p><strong>递归方法二</strong></p><p>从头结点开始，从左到右，两两反转，同时记录相邻的两个结点，head在前，nextnode在后。直到尾结点终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseListInt(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseListInt</span><span class="params">(ListNode* head, ListNode* newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextNode</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    head-&gt;next = newHead;</span><br><span class="line">    <span class="comment">//尾递归</span></span><br><span class="line">    <span class="keyword">return</span> reverseListInt(nextNode, head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为是尾递归，系统可以重用栈中的固定空间，所以空间复杂度较小。</p><h3 id="problem-203-移除链表元素"><a href="#problem-203-移除链表元素" class="headerlink" title="problem 203 移除链表元素"></a>problem 203 移除链表元素</h3><p><strong>方法一</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        start-&gt;next = head;</span><br><span class="line">        ListNode* first = start;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;next-&gt;val==val)&#123;</span><br><span class="line">    ListNode* p=first-&gt;next;</span><br><span class="line">    first-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    first=first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>方法二：递归</strong></p><p>Using a recursive method needs more space/memory since it need to build much more stacks on frame.</p><p>方法有弊端，没有 free 被删除的结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeElements</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-328-奇偶链表"><a href="#problem-328-奇偶链表" class="headerlink" title="problem 328 奇偶链表"></a>problem 328 奇偶链表</h3><p>维护两个指针 <code>odd</code> 和 <code>even</code> 分别指向奇数节点和偶数节点，初始时 <code>odd = head，even = evenHead。</code>通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p><p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="image"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* odd = head;  <span class="comment">//奇数结点</span></span><br><span class="line">        ListNode* even = head-&gt;next; <span class="comment">//偶数结点</span></span><br><span class="line">        ListNode* tmp = even;</span><br><span class="line">        <span class="keyword">while</span>(even&amp;&amp;even-&gt;next)&#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="problem-234-回文链表"><a href="#problem-234-回文链表" class="headerlink" title="problem 234 回文链表"></a>problem 234 回文链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">curr</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">curr-&gt;next = pre;</span><br><span class="line">pre=curr;</span><br><span class="line">curr=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>=<span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (fast != <span class="literal">NULL</span>) &#123; <span class="comment">// odd nodes: let right half smaller</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow=reverseList(slow);</span><br><span class="line">    fast=head;</span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(slow-&gt;val!=fast-&gt;val)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    slow=slow-&gt;next;</span><br><span class="line">    fast=fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们无法追溯单链表中的前一个结点。因此，我们不仅要存储当前结点，还要存储前一个结点。</li></ul><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表在单链表的基础上增加了一个“prev”指针，用来指向前一个结点。<br><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/17/screen-shot-2018-04-17-at-161130.png" alt="image"></p><p>下面是双链表中结点结构的典型定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for doubly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoublyListNode *next, *prev;</span><br><span class="line">    DoublyListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>), prev(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="双链表操作实现"><a href="#双链表操作实现" class="headerlink" title="双链表操作实现"></a>双链表操作实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoublyListNode *next, *prev;</span><br><span class="line">    DoublyListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>), prev(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="keyword">new</span>  DoublyListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--&amp;&amp;p)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(index&amp;&amp;p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        new_node-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            head-&gt;next-&gt;prev = new_node;</span><br><span class="line">        new_node-&gt;prev = head;</span><br><span class="line">        head-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        DoublyListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        p-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        new_node-&gt;prev = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* new_node = <span class="keyword">new</span> DoublyListNode(val);</span><br><span class="line">        DoublyListNode* p =head;</span><br><span class="line">        <span class="keyword">while</span>(index&amp;&amp;p)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span> &amp;&amp; p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            new_node-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                p-&gt;next-&gt;prev = new_node;</span><br><span class="line">            p-&gt;next = new_node;</span><br><span class="line">            new_node-&gt;prev = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        DoublyListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(index&amp;&amp;p)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span> &amp;&amp; p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            DoublyListNode* tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next)</span><br><span class="line">                tmp-&gt;next-&gt;prev = p;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode* head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="problem-21-合并两个有序链表"><a href="#problem-21-合并两个有序链表" class="headerlink" title="problem 21  合并两个有序链表"></a>problem 21  合并两个有序链表</h3><p><strong>方法 1：递归</strong></p><p>我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125; </span><br><span class="line">list1[0]+merge(list1[1:],list2) &amp; \text &#123;list1[0]&lt;list2[0]&#125; </span><br><span class="line">\\list2[0]+merge(list1,list2[1:]) &amp; \text&#123;otherwise&#125;</span><br><span class="line"> \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* headA, struct ListNode* headB)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (headA == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (headB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (headA-&gt;val &lt; headB-&gt;val) &#123;</span><br><span class="line">            headA-&gt;next = mergeTwoLists(headA-&gt;next, headB);</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            headB-&gt;next = mergeTwoLists(headA, headB-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(n + m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。</li><li>空间复杂度：O(n + m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n +m 个栈帧会消耗 O(n + m) 的空间。</li></ul><p><strong>方法2：迭代</strong></p><p>设置一个 prehead 结点（虚节点），帮助我们轻松返回合并后新链表的头结点。</p><p>循环终止后，l1 和 l2 中最多有一个是非空的。 因此（因为输入列表是按有序的），如果其中一个列表是非空的，那么它包含的元素一定大于所有先前合并的元素。 这意味着我们可以直接将非空列表连接到已合并列表并返回它。</p><p>c 版本<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* headA, struct ListNode* headB)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prehead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> = <span class="title">prehead</span>;</span></span><br><span class="line"><span class="keyword">while</span>(headA!=<span class="literal">NULL</span> &amp;&amp; headB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(headA-&gt;val &lt; headB-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;next = headA;</span><br><span class="line">headA = headA-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">prev-&gt;next = headB;</span><br><span class="line">headB = headB-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">// exactly one of l1 and l2 can be non-null at this point, so connect</span></span><br><span class="line">        <span class="comment">// the non-null list to the end of the merged list.</span></span><br><span class="line">        prev-&gt;next = headA == <span class="literal">NULL</span> ? headB : headA;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>c++ 版本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* prehead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* pre = prehead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(n + m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。</li><li>空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。<br>。</li></ul><h3 id="problem-876-链表的中间结点"><a href="#problem-876-链表的中间结点" class="headerlink" title="problem 876. 链表的中间结点"></a>problem 876. 链表的中间结点</h3><p>当用慢指针 slow 遍历列表时，让另一个指针 fast 的速度是它的两倍。</p><p>当 fast 到达列表的末尾时，slow 必然位于中间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复杂度分析</p><ul><li>时间复杂度：O(N)，其中 N 是给定列表的结点数目。</li><li>空间复杂度：O(1)，slow 和 fast 用去的空间。</li></ul><h3 id="problem-2-两数相加"><a href="#problem-2-两数相加" class="headerlink" title="problem  2. 两数相加"></a>problem  2. 两数相加</h3><p>两个链表同时从头开始遍历，注意保留进位。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            sum = n1+n2+tmp;</span><br><span class="line">            tmp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sum/<span class="number">10</span>);</span><br><span class="line">            ListNode* new_node = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            head-&gt;next = new_node;</span><br><span class="line">            <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">            ListNode* new_node = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            head-&gt;next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="problem-61-旋转链表"><a href="#problem-61-旋转链表" class="headerlink" title="problem 61 旋转链表"></a>problem 61 旋转链表</h3><p>先找到最后一个结点与头部连成环，然后找到非旋转与旋转部分的分界点，断开环。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="number">1</span>;</span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        k = n-k%n;</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a>146. LRU 缓存机制</h3><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol><ul><li>这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</li><li>引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h2&gt;&lt;h3 id=&quot;链表定义&quot;&gt;&lt;a href=&quot;#链表定义&quot; class=&quot;headerlink&quot; title=&quot;链表定义&quot;&gt;&lt;/a&gt;链表定义&lt;/h3&gt;&lt;p&gt;定义一个单链表:&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) : val(x), next(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;为了统一删除操作，可以手动给链表加一个空的头结点&lt;/strong&gt;&lt;br&gt; &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ListNode* start = sas;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;让我们从一个经典问题开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="https://hongbosherlock.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer [第 7 章类]</title>
    <link href="https://hongbosherlock.github.io/2021/02/10/c++_class/"/>
    <id>https://hongbosherlock.github.io/2021/02/10/c++_class/</id>
    <published>2021-02-10T12:37:24.000Z</published>
    <updated>2021-02-11T09:16:08.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章主要关注数据抽象的主要性，数据抽象能帮我们将对象的具体实现与对象所能执行的操作分离开来。</p></blockquote><p>Classes 之间的关系</p><ul><li>继承(inheritance)</li><li>复合(composition)</li><li>委托(delegation)</li></ul><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><ul><li><strong>类的基本思想</strong>：<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）。</li><li>数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程技术。</li></ul><h3 id="类成员-（Member）"><a href="#类成员-（Member）" class="headerlink" title="类成员 （Member）"></a>类成员 （Member）</h3><ul><li>必须在类的内部声明，不能在其他地方增加成员。</li><li><p>成员可以是数据，函数，类型别名。</p><a id="more"></a><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3></li><li><p>成员函数的<strong>声明</strong>必须在类的内部。</p></li><li>成员函数的<strong>定义</strong>既可以在类的内部也可以在外部。</li><li>使用点运算符 <code>.</code> 调用成员函数。实际上是在替<code>.</code>前面的对象调用它。</li><li>必须对任何<code>const</code>或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</li><li><code>ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }</code></li><li>默认实参： <code>Sales_item(const std::string &amp;book): isbn(book), units_sold(0), revenue(0.0) { }</code></li><li><code>*this</code>：<ul><li>每个成员函数都有一个额外的，隐含的形参<code>this</code>。</li><li><code>this</code>总是指向当前对象，因此<code>this</code>是一个<strong>常量指针</strong>。</li><li>形参表后面的<code>const</code>，改变了隐含的<code>this</code>形参的类型，如 <code>bool same_isbn(const Sales_item &amp;obj) const</code>，这种函数称为 <strong>常量成员函数</strong>（<code>this</code>指向的当前对象是常量）。</li><li><code>return *this;</code>返回调用该函数的对象。</li><li>普通的非<code>const</code>成员函数：<code>this</code>是指向类类型的<code>const</code>指针（可以改变<code>this</code>所指向的值，不能改变<code>this</code>保存的地址）。</li><li><code>const</code>成员函数：<code>this</code>是指向const类类型的<code>const</code>指针（既不能改变<code>this</code>所指向的值，也不能改变<code>this</code>保存的地址）。</li></ul></li><li>常量对象只能调用常量成员函数(避免普通成员函数修改常量对象成员的值)。<ul><li>常量对象的 this 指针的类型：<code>const Sales_data *const</code>,与普通成员函数接收的 <code>this</code>指针类型不匹配。</li><li>常量成员函数：<code>string isbn() const</code></li></ul></li><li>普通对象既可以调用常量成员函数也可以调用普通成员函数。</li></ul><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><ul><li>和类相关的非成员函数，定义和声明都应该在类的外部。</li><li>声明与类在同一个头文件中。</li></ul><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><ul><li>类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</li><li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。</li><li>构造函数是特殊的成员函数。</li><li>构造函数放在类的<code>public</code>部分。</li><li>与类同名的成员函数。</li><li><code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li><li><code>=default</code>要求编译器合成默认的构造函数。(<code>C++11</code>)</li><li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li></ul><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><ul><li><strong>访问说明符</strong>（access specifiers）：<ul><li><code>public</code>：定义在 <code>public</code>后面的成员在整个程序内可以被访问； <code>public</code>成员<strong>定义类的接口。</strong></li><li><code>private</code>：定义在 <code>private</code>后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； <code>private</code><strong>隐藏类的实现细节。</strong></li></ul></li><li>使用 <code>class</code>或者 <code>struct</code>：都可以被用于定义一个类,唯一的区别在于<strong>访问权限</strong>。<ul><li>使用 <code>class</code>：在第一个访问说明符之前的成员是 <code>priavte</code>的。</li><li>使用 <code>struct</code>：在第一个访问说明符之前的成员是 <code>public</code>的。</li></ul></li></ul><h3 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元(friend)"></a>友元(friend)</h3><ul><li>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>.</li><li>友元的声明以关键字 <code>friend</code>开始。 <code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</li><li>通常将友元声明放在<strong>类定义的开始或者结尾</strong>。<ul><li>在类外也要为友元函数提供独立的声明。 </li></ul></li><li>类之间的友元：<ul><li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</li><li>如果仅指定其它类的成员函数为友元函数，须指明成员函数属于哪个类。</li></ul></li><li>友元函数能定义在类的内部，这样的函数是隐式内联的。</li><li>相同 class 的各个 objects 互为 friends（友元）。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是实现与接口的分离。它隐藏了类型的实现细节。 （在C ++中，通过将实现放在类的私有部分中来实现封装）</p><ul><li>确保用户的代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ul><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><ul><li>成员函数作为内联函数 <code>inline</code>：<ul><li>在类的内部，常有一些规模较小的函数适合于被声明成内联函数。</li><li><strong>定义</strong>在类内部的函数是<strong>自动内联</strong>的。</li><li>在类外部定义的成员函数，也可以在声明时显式地加上 <code>inline</code>。</li><li>inline 成员函数应该与相应的类定义在同一个头文件中。</li></ul></li><li><strong>可变数据成员</strong> （mutable data member）：<ul><li><code>mutable int count;</code></li><li>永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。</li></ul></li><li><strong>类类型</strong>：<ul><li>每个类定义了唯一的类型。</li></ul></li><li>一个 const 成员函数如果以引用的形式返回 *this ，那么它的返回类型将是常量引用。</li><li><code>class Screen</code> 仅声明类，而暂时不定义它。 </li></ul><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul><li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li><li>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</li><li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li><li>类中的<strong>类型名定义</strong>都要放在一开始。</li></ul><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><blockquote><p>单例模式中构造函数在 private 区域。</p></blockquote><ul><li>构造函数初始值列表：<ul><li>如<code>const</code>或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）</li><li>如果成员是<code>const</code> 、引用，或者是某种未提供默认构造函数的类类型，我们必须同感<strong>构造函数初始值列表</strong>为这些成员提供初值。<ul><li>初始化列表是初始化。</li><li>{ } 内是赋值操作。</li></ul></li><li>最好让构造函数初始值的顺序和成员声明的顺序保持一致。</li><li>如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认的构造函数。<ul><li>不能有多个提供了所有实参的构造函数，会导致默认构造函数不明确。 </li></ul></li></ul></li><li>如果定义了其它构造函数，那么最好也提供一个默认构造函数。</li></ul><h3 id="委托构造函数-（delegating-constructor-C-11）"><a href="#委托构造函数-（delegating-constructor-C-11）" class="headerlink" title="委托构造函数 （delegating constructor, C++11）"></a>委托构造函数 （delegating constructor, <code>C++11</code>）</h3><ul><li>委托构造函数将自己的职责委托给了类内想其他构造函数。</li><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</li><li><code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) {}</code></li></ul><h3 id="隐式的类型转换"><a href="#隐式的类型转换" class="headerlink" title="隐式的类型转换"></a>隐式的类型转换</h3><ul><li>如果构造函数<strong>只接受一个实参</strong>，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>。这种构造函数又叫<strong>转换构造函数</strong>（converting constructor）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">// constructs a temporary Sales_data object</span></span><br><span class="line"><span class="comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span></span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure><ul><li>编译器只会自动地执行 <strong>仅一步</strong> 类型转换。</li><li>抑制构造函数定义的隐式转换：<ul><li>将构造函数声明为<code>explicit</code>加以阻止。</li><li>只能在类内声明构造函数时使用 <code>explicit</code> 关键字。</li><li><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化。</li></ul></li></ul><h3 id="聚合类-（aggregate-class）"><a href="#聚合类-（aggregate-class）" class="headerlink" title="聚合类 （aggregate class）"></a>聚合类 （aggregate class）</h3><ul><li>满足以下所有条件：<ul><li>所有成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有<code>virtual</code>函数。</li></ul></li><li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li></ul><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><ul><li><code>constexpr</code>函数的参数和返回值必须是字面值。</li><li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li><li>数据成员都是字面值类型的聚合类是字面值常量类。</li><li>如果不是聚合类，则必须满足下面所有条件：<ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个<code>constexpr</code>构造函数。</li><li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul></li><li>构造函数不能是<code>const</code>的，但是字面值常量类的构造函数可以是<code>constexpr</code>。</li></ul><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ul><li>非<code>static</code>数据成员存在于类类型的每个对象中。</li><li><code>static</code>数据成员独立于该类的任意对象而存在。</li><li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li><li>声明：<ul><li>声明之前加上关键词<code>static</code>，只出现在类内。</li></ul></li><li>使用：<ul><li>使用<strong>作用域运算符</strong><code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li><li>也可以使用对象访问：<code>r = ac.rate();</code></li></ul></li><li>定义：<ul><li>在类外部定义时不用加<code>static</code>。也可在类内定义。</li></ul></li><li>初始化：<ul><li>通常不在类的内部初始化，而是在类外定义和初始化<ul><li><code>double Account::interestRate = initRate();</code></li></ul></li><li>如果一定要在类内部定义，则要求静态成员必须是字面值常量类型的<code>constexpr</code>。<ul><li><code>static constexptr int period = 30</code></li></ul></li></ul></li><li>静态成员函数不包含 this 指针，也不能声明为 const 的。</li><li>静态数据成员可以作为默认实参。</li><li>静态数据成员的类型可以就是它所属的类类型：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1; <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2; <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3; <span class="comment">// error: data members must have complete type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章主要关注数据抽象的主要性，数据抽象能帮我们将对象的具体实现与对象所能执行的操作分离开来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Classes 之间的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承(inheritance)&lt;/li&gt;
&lt;li&gt;复合(composition)&lt;/li&gt;
&lt;li&gt;委托(delegation)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义抽象数据类型&quot;&gt;&lt;a href=&quot;#定义抽象数据类型&quot; class=&quot;headerlink&quot; title=&quot;定义抽象数据类型&quot;&gt;&lt;/a&gt;定义抽象数据类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类的基本思想&lt;/strong&gt;：&lt;strong&gt;数据抽象&lt;/strong&gt;（data abstraction）和&lt;strong&gt;封装&lt;/strong&gt;（encapsulation）。&lt;/li&gt;
&lt;li&gt;数据抽象是一种依赖于&lt;strong&gt;接口&lt;/strong&gt;（interface）和&lt;strong&gt;实现&lt;/strong&gt;（implementation）分离的编程技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类成员-（Member）&quot;&gt;&lt;a href=&quot;#类成员-（Member）&quot; class=&quot;headerlink&quot; title=&quot;类成员 （Member）&quot;&gt;&lt;/a&gt;类成员 （Member）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;必须在类的内部声明，不能在其他地方增加成员。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成员可以是数据，函数，类型别名。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Primer [第 6 章函数]</title>
    <link href="https://hongbosherlock.github.io/2021/01/25/c-func/"/>
    <id>https://hongbosherlock.github.io/2021/01/25/c-func/</id>
    <published>2021-01-25T04:58:49.000Z</published>
    <updated>2021-01-28T15:03:46.765Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h3 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h3><p><strong>1. 实参和形参的区别</strong></p><ul><li>形参：在函数参数列表中声明的局部变量。 它们由每次调用函数时提供的实参初始化。</li><li><p>实参：在函数调用中提供的值，用于初始化函数的形参。</p><p><strong>2. 局部对象</strong></p></li></ul><p>（1）局部静态对象</p><p>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，在函数结束时还存在，直到程序终止才被销毁。</p><ul><li>局部静态对象只被初始化一次。</li></ul><p>(2) 函数应该在头文件中声明，在源文件中定义</p><a id="more"></a><p> <strong>3.分离式编译</strong></p><h3 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h3><p><strong>1. 使用引用避免拷贝</strong></p><p>string 对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare the length of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽量使用常量引用。</li><li>如果函数无需改变引用形参的值，最好将其声明为<strong>常量引用</strong>。</li></ul><p><strong>2. const 形参和实参</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能读取 i，但是不能向 i 写值 */</span>&#125;</span><br></pre></td></tr></table></figure><p>调用 fcn 函数时，既可以传入 const int，也可以传入 int。</p><p><strong>3. 数组引用形参</strong></p><p>形参也可以是数组的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: parameter is a reference to an array; the dimension is part of the type</span></span><br><span class="line">void print(int (&amp;arr)[10])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(&amp;arr)</code> 两端的括号不可少</li><li>这一用法无形中限制了只能将函数作用于大小为 10 的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">printf(k);</span><br></pre></td></tr></table></figure><p><strong>4. 传递多维数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix 指向数组的首元素，该数组的元素是又 10 个整数构成的数组</span></span><br><span class="line">void printf(int (*matrix)[10], int size)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p><strong>5. main 处理命令行选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, int *argv[])</span><br></pre></td></tr></table></figure><ul><li>第二个形参 argv是一个数组，它的元素是指向 C 风格字符串的指针。</li><li>第一个形参 argc 表示数组中字符串的数量。<blockquote><p>argv[0] = “prog”; // or argv[0] might point to an empty string<br>argv[1] = “-d”;<br>argv[2] = “-o”;<br>argv[3] = “ofile”;<br>argv[4] = “data0”;<br>argv[5] = 0;</p></blockquote></li></ul><p>当使用 argv 中的实参时，可选的实参要从 argv[1] 开始，argv[0]保存程序的名字，而非用户输入。</p><p><strong>6. initializer_list 形参</strong></p><p>initializer_list 是一种标准库类型，用于表示某种特定类型的值的数组。</p><p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>initializer_list&lt;T&gt; lst;</code></td><td>默认初始化；<code>T</code>类型元素的空列表</td></tr><tr><td><code>initializer_list&lt;T&gt; lst{a,b,c...};</code></td><td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td></tr><tr><td><code>lst2(lst)</code></td><td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td></tr><tr><td><code>lst2 = lst</code></td><td>同上</td></tr><tr><td><code>lst.size()</code></td><td>列表中的元素数量</td></tr><tr><td><code>lst.begin()</code></td><td>返回指向<code>lst</code>中首元素的指针</td></tr><tr><td><code>lst.end()</code></td><td>返回指向<code>lst</code>中微元素下一位置的指针</td></tr></tbody></table><p><code>initializer_list</code>使用 demo：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_msg</span><span class="params">(ErrCode e, <span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.begin(); beg != il.end(); ++ beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err_msg(ErrCode(<span class="number">0</span>), &#123;<span class="string">"functionX"</span>, <span class="string">"okay&#125;);</span></span><br></pre></td></tr></table></figure><ul><li><code>initializer_list</code> 对象中的元素永远是常量值。</li><li>所有实参类型相同，可以使用 <code>initializer_list</code>的标准库类型。</li><li>实参类型不同，可以使用<code>可变参数模板</code>。</li><li>省略形参符： <code>...</code>，便于<code>C++</code>访问某些 C 代码，这些 C 代码使用了 <code>varargs</code>的 C 标准功能。</li></ul><h3 id="6-3-返回类型和-return-语句"><a href="#6-3-返回类型和-return-语句" class="headerlink" title="6.3 返回类型和 return 语句"></a>6.3 返回类型和 return 语句</h3><p><strong>1. 无返回值函数</strong></p><p>没有返回值的 <code>return</code>语句只能用在返回类型是 <code>void</code>的函数中，返回 <code>void</code>的函数不要求非得有 <code>return</code>语句。</p><p><strong>2.有返回值函数</strong></p><ul><li><code>return</code>语句的返回值的类型必须和函数的返回类型相同，或者能够<strong>隐式地</strong>转换成函数的返回类型。</li><li>值是如何返回的：返回的值用于初始化调用点的一个<strong>临时量</strong>，该临时量就是函数调用的结果。</li><li><strong>不要返回局部对象的引用或指针</strong>。</li><li><strong>引用返回左值</strong>：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix]; <span class="comment">// get_val assumes the given index is valid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">get_val(s, <span class="number">0</span>) = <span class="string">'A'</span>; <span class="comment">// changes s[0] to A</span></span><br></pre></td></tr></table></figure><ul><li><strong>列表初始化返回值</strong>：函数可以返回花括号包围的值的列表。（<code>C++11</code>）</li><li><strong>主函数main的返回值</strong>：如果结尾没有<code>return</code>，编译器将隐式地插入一条返回0的<code>return</code>语句。返回0代表执行成功。</li></ul><p><strong>3. 返回数组指针</strong></p><ul><li><p><code>Type (*function (parameter_list))[dimension]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int (*func(int i))[10];</span><br><span class="line"></span><br><span class="line">- func(int i)表示调用 func 函数时需要一个 int 类型的实参。</span><br><span class="line">- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用的操作</span><br><span class="line">- (*func(int i))[10] 表示解引用 func 的调用将得到一个大小是 10 的数组</span><br><span class="line">- int (*func(int i))[10] 表示数组中的元素是 int 类型。</span><br></pre></td></tr></table></figure></li><li><p>使用类型别名：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];  <span class="comment">// arrT 是一个类型别名，它表示的类型是含有 10 个整数的数组。</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>;];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">()</span> </span>&#123;...&#125;;  <span class="comment">// func 返回一个指向含有 10 个整数的数组的指针。</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>decltype</code>： <code>decltype(odd) *arrPtr(int i) {...}</code></li><li><strong>尾置返回类型</strong>： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在形参列表后面以一个`-&gt;`开始：</span><br><span class="line">auto func(int i) -&gt; int(*)[10]（C++11）</span><br><span class="line">// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组。</span><br></pre></td></tr></table></figure><h3 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h3><ul><li><strong>重载</strong>：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。<blockquote><p>必须要形参数量或者形参类型不同，不能仅仅返回类型不同。</p></blockquote></li><li><code>main</code>函数不能重载。</li><li><strong>重载和const形参</strong>：<ul><li>一个有顶层const的形参和没有它的函数无法区分。 <code>Record lookup(Phone* const)</code>和 <code>Record lookup(Phone*)</code>无法区分。</li><li>相反，是否有某个底层const形参可以区分。 <code>Record lookup(Account*)</code>和 <code>Record lookup(const Account*)</code>可以区分。</li></ul></li><li><strong>重载和作用域</strong>：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。</li></ul><h3 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h3><h4 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h4><ul><li><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></li><li>一旦某个形参被赋予了默认值，那么它<strong>后面</strong>的形参都必须要有默认值。</li><li>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</li></ul><h4 id="内联（inline）函数"><a href="#内联（inline）函数" class="headerlink" title="内联（inline）函数"></a>内联（inline）函数</h4><ul><li>普通函数的缺点：调用函数比求解等价表达式要慢得多。</li><li><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</li><li>适用于规模小，流程直接，频繁调用的函数。</li><li><code>inline</code>函数应该在头文件中定义。</li></ul><h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><ul><li>指能用于常量表达式的函数。</li><li><code>constexpr int new_sz() {return 42;}</code></li><li>函数的返回类型及所有形参类型都要是字面值类型。</li><li>只有一个 return 语句。</li><li><code>constexpr</code>函数应该在头文件中定义。</li></ul><h4 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h4><ul><li><code>assert</code>是一种<strong>预处理宏</strong>（preprocessor macro）</li><li><code>assert(expr);</code> expr 为真时，assert 输出信息并终止程序执行。</li><li>预处理名字由预处理器而非编译器管理。</li></ul><p>开关调试状态：</p><p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        <span class="comment">// 如果 NDEBUG 未定义，则执行这段代码</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">"..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h3><ul><li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li><li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li><li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。</li><li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li></ul><h3 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h3><p><strong>函数指针</strong>：是指向函数的指针。函数的类型由它的<strong>返回类型</strong>和<strong>形参类型</strong>共同决定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">//该函数类型是 bool(const string &amp;, const string &amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数指针 pf，pf 两端的括号必不可少</span></span><br><span class="line"><span class="comment">// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br><span class="line"></span><br><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// equivalent call</span></span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>); <span class="comment">// equivalent call</span></span><br></pre></td></tr></table></figure></p><ul><li><strong>函数指针形参</strong>：<ul><li>形参中使用函数定义或者函数指针定义效果一样。</li><li>使用类型别名或者<code>decltype</code>。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line">void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line">void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;));</span><br></pre></td></tr></table></figure><p>直接使用函数指针冗长而繁琐：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Func and Func2 have function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>; <span class="comment">// equivalent type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FuncP and FuncP2 have pointer to function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>; <span class="comment">// equivalent type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent declarations of useBigger using type aliases</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, Func)</span></span>; <span class="comment">//编译器自动地将 Func 表示的函数类型转换为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li><strong>返回指向函数的指针</strong>：<ul><li>1.类型别名；<ul><li><code>using F = int(int*, int); // F is a function type, not a pointer</code></li><li><code>using PF = int(*)(int*, int); // PF is a pointer type</code></li></ul></li><li>2.尾置返回类型。<ul><li>decltype 作用于某个函数时，它返回函数类型而不是指针，需要显式地加上 <code>*</code></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 实参和形参的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形参：在函数参数列表中声明的局部变量。 它们由每次调用函数时提供的实参初始化。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实参：在函数调用中提供的值，用于初始化函数的形参。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 局部对象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）局部静态对象&lt;/p&gt;
&lt;p&gt;局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，在函数结束时还存在，直到程序终止才被销毁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部静态对象只被初始化一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) 函数应该在头文件中声明，在源文件中定义&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——二叉树 (更新中)</title>
    <link href="https://hongbosherlock.github.io/2021/01/10/binary-tree/"/>
    <id>https://hongbosherlock.github.io/2021/01/10/binary-tree/</id>
    <published>2021-01-10T09:45:25.000Z</published>
    <updated>2021-02-26T15:06:01.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何遍历一棵树"><a href="#如何遍历一棵树" class="headerlink" title="如何遍历一棵树"></a>如何遍历一棵树</h3><p><strong>1. 前序遍历</strong></p><blockquote><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p></blockquote><p><strong>2. 中序遍历</strong></p><blockquote><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p></blockquote><p>通常来说，对于<strong>二叉搜索树</strong>，我们可以通过中序遍历得到一个<strong>递增</strong>的有序序列。 </p><p><strong>3. 后序遍历</strong></p><blockquote><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p></blockquote><p>当删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。</p><ul><li>前、中、后遍历用到了 <strong>栈</strong>，层序遍历用到了 <strong>队列</strong>。<br><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymmjeuu8j317w0l6gof.jpg" alt=""><a id="more"></a><br><strong>后缀表达式</strong></li></ul><p>编写程序来解析后缀表示法更为容易。 这里是一个例子：</p><p><img src="https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/2/traverse-a-tree/Figures/binary_tree/mathematical_expression.png" alt="image"></p><ul><li><p>可以使用<strong>中序遍历</strong>轻松找出原始表达式。 注意检查操作的优先级。</p></li><li><p><strong>后序遍历</strong>，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p></li></ul><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144  二叉树的前序遍历"></a>144  二叉树的前序遍历</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        preorderTraversal(root-&gt;left);</span><br><span class="line">        preorderTraversal(r</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        oot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用 <strong>深度优先搜索</strong> 的思想</p><p>在 A 的两棵子树中，遍历完左子树后，再遍历右子树。</p><p>从根节点开始，每次迭代弹出当前栈顶元素，并将其孩子节点压入栈中，先压右孩子再压左孩子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="comment">// 注意 stack 的类型是 TreeNode*</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            output.push_back(node-&gt;val);</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;<span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。</li><li>空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</li></ul><h3 id="94-二叉树中序遍历"><a href="#94-二叉树中序遍历" class="headerlink" title="94  二叉树中序遍历"></a>94  二叉树中序遍历</h3><h4 id="基于栈的遍历"><a href="#基于栈的遍历" class="headerlink" title="基于栈的遍历"></a>基于栈的遍历</h4><p><strong>思路</strong>：</p><ul><li>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。</li><li>在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        TreeNode* curr=root;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(curr);</span><br><span class="line">                curr= curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            v.push_back(curr-&gt;val);</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="145-二叉树后序遍历"><a href="#145-二叉树后序遍历" class="headerlink" title="145 二叉树后序遍历"></a>145 二叉树后序遍历</h3><p>从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从右至右左顺序依次压入栈中。</p><p>因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            v.insert(v.begin(),node-&gt;val);</span><br><span class="line">            <span class="comment">// 在头部插入新元素</span></span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* last = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* node = s.top();</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; right &amp;&amp; last != node -&gt; right) &#123;</span><br><span class="line">                    root = node -&gt; right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v.push_back(node -&gt; val);</span><br><span class="line">                    last = node;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102 二叉树的层序遍历"></a>102 二叉树的层序遍历</h3><p>当我们在树中进行 <strong>广度优先搜索</strong> 时，我们访问的节点的顺序是按照层序遍历顺序的。</p><p>使用 <strong>队列</strong> 来实现广度优先搜索</p><p><strong>方法一：递归</strong></p><ul><li>输出列表称为 res，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 res.size() 的大小，如果前者更大就向 res 添加一个空列表。</li><li>将当前节点插入到对应层的列表 res[level] 中。</li><li>递归非空的孩子节点：helper(node-&gt;left / node-&gt;right, level + 1)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==level)       </span><br><span class="line">            res.resize(level+<span class="number">1</span>);    <span class="comment">//level表示层数，也对应二维数组的第一层索引，</span></span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            helper(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：迭代</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> n=q.size();<span class="comment">//计算当前层有多少个元素：等于队列的长度。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//当前队列中的结点都是同一层的</span></span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                v.push_back(node-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="运用递归"><a href="#运用递归" class="headerlink" title="运用递归"></a>运用递归</h3><p>许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。</p><h4 id="“自顶向下”-的解决方案"><a href="#“自顶向下”-的解决方案" class="headerlink" title="“自顶向下” 的解决方案"></a>“自顶向下” 的解决方案</h4><p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种 <strong>前序遍历</strong>。</p><blockquote><ol><li>return specific value for null node</li><li>update the answer if needed                      // anwer &lt;– params</li><li>left_ans = top_down(root.left, left_params)      // left_params &lt;– root.val, params</li><li>right_ans = top_down(root.right, right_params)   &gt;// right_params &lt;– root.val, params</li><li>return the answer if needed                      &gt;// answer &lt;– left_ans, right_ans</li></ol></blockquote><p><strong>二叉树的最大深度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用“自顶向下”方案的情况</strong></p><ul><li>可以确定一些参数，从该节点自身解决出发寻找答案。</li><li>可以使用这些参数和节点本身的值来决定什么应该是 <strong>传递给它子节点</strong> 的参数。</li></ul><h4 id="“自底向上”-的解决方案"><a href="#“自底向上”-的解决方案" class="headerlink" title="“自底向上” 的解决方案"></a>“自底向上” 的解决方案</h4><p>在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是 <strong>后序遍历</strong> 的一种。</p><blockquote><ol><li>return specific value for null node</li><li>left_ans = bottom_up(root.left)          // call function recursively for left child</li><li>right_ans = bottom_up(root.right)        // call function recursively for right child</li><li>return answers                           // answer &lt;– left_ans, right_ans, root.val</li></ol></blockquote><p><strong>二叉树的最大深度</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>;  <span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用“自底向上”方案的情况</strong></p><ul><li>对于树中的任意一个节点，如果知道它 <strong>子节点</strong> 的答案，我们能计算出该节点的答案。</li></ul><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h3><p><strong>方法一：BFS</strong></p><ul><li>层序遍历二叉树，最大层数就是二叉树的深度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,n;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        n=q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p -&gt; left != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(p -&gt; right != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二：DFS</strong></p><p>双栈法：</p><ul><li>一个栈存储结点</li><li>一个栈存储当前深度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        res.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> dep=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">int</span> temp=res.top();</span><br><span class="line">            dep=max(dep,temp);</span><br><span class="line">            res.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">                res.push(temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">                res.push(temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>如果同时满足下面的条件，两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ul><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymos6v6qj30zk0k0tat.jpg" alt=""></p><p><strong>递归</strong></p><p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，pp 指针和 qq 指针一开始都指向这棵树的根，随后 pp 右移时，qq 左移，pp 左移时，qq 右移。每次检查当前 pp 和 qq 节点的值是否相等，如果相等再判断左右子树是否对称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* p ,TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p||!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> (q-&gt;val==p-&gt;val)&amp;&amp;check(p-&gt;left,q-&gt;right)&amp;&amp;check(p-&gt;right,q-&gt;left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>引入一个<strong>队列</strong>，这是把递归程序改写成迭代程序的常用方法。<br>初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u); q.push(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            u = q.front(); q.pop();</span><br><span class="line">            v = q.front(); q.pop();</span><br><span class="line">            <span class="comment">//注意下面条件的判断</span></span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;left); </span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.push(u-&gt;right); </span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h3><p><strong>递归</strong></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> sum==root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val)||hasPathSum(root-&gt;right,sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>广度优先搜索</strong></p><p>使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p><p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qval;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        qval.push(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            TreeNode* node=q.front();</span><br><span class="line">            <span class="keyword">int</span> val=qval.front();</span><br><span class="line">            q.pop(); qval.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum==val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                qval.push(val+node-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">                qval.push(val+node-&gt;right-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106  从中序与后序遍历序列构造二叉树"></a>106  从中序与后序遍历序列构造二叉树</h3><p>我们可以发现后序遍历的数组最后一个元素代表的即为根节点。知道这个性质后，我们可以利用已知的根节点信息在中序遍历的数组中找到根节点所在的下标，然后根据其将中序遍历的数组分成左右两部分，左边部分即左子树，右边部分为右子树，针对每个部分可以用同样的方法继续递归下去构造。</p><p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymr2itr5j31jk0v9dn2.jpg" alt=""></p><ul><li>为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（元素，下标）键值对的哈希表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> post_end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootval=postorder[post_end];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line">        post_end--;</span><br><span class="line">        <span class="keyword">int</span> mid=m[rootval];</span><br><span class="line">        </span><br><span class="line">        root-&gt;right=helper(mid+<span class="number">1</span>,right,inorder,postorder);</span><br><span class="line">        root-&gt;left=helper(left,mid<span class="number">-1</span>,inorder,postorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(!inorder.size()||!postorder.size())</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        post_end=(<span class="keyword">int</span>)postorder.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)inorder.size();</span><br><span class="line">        <span class="keyword">int</span> in_start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[inorder[i]]=in_start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,n<span class="number">-1</span>,inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p>对于任意一颗树而言，前序遍历的形式总是</p><blockquote><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p></blockquote><p>而中序遍历的形式总是:</p><blockquote><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p></blockquote><p>初始时左子树的</p><ul><li>左子树的根节点是前序遍历中当前根节点的下一个元素。</li><li>右子树的根节点是前序遍历中当前根节点加上左子树的元素个数再加一。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pre_start,<span class="keyword">int</span> in_start,<span class="keyword">int</span> in_end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_start&gt;preorder.size()||in_start&gt;in_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[pre_start];</span><br><span class="line">        <span class="keyword">int</span> mid = m[root_val];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        root-&gt;left=helper(pre_start+<span class="number">1</span>,in_start,mid<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">        root-&gt;right=helper(pre_start+mid-in_start+<span class="number">1</span>,mid+<span class="number">1</span>,in_end,preorder,inorder);</span><br><span class="line">        <span class="comment">//先构建左子树或者右子树都行</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=inorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            m[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何遍历一棵树&quot;&gt;&lt;a href=&quot;#如何遍历一棵树&quot; class=&quot;headerlink&quot; title=&quot;如何遍历一棵树&quot;&gt;&lt;/a&gt;如何遍历一棵树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 前序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. 中序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常来说，对于&lt;strong&gt;二叉搜索树&lt;/strong&gt;，我们可以通过中序遍历得到一个&lt;strong&gt;递增&lt;/strong&gt;的有序序列。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 后序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前、中、后遍历用到了 &lt;strong&gt;栈&lt;/strong&gt;，层序遍历用到了 &lt;strong&gt;队列&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gmymmjeuu8j317w0l6gof.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://hongbosherlock.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>智能陷阱：愿者上钩</title>
    <link href="https://hongbosherlock.github.io/2020/11/17/social-dilemma/"/>
    <id>https://hongbosherlock.github.io/2020/11/17/social-dilemma/</id>
    <published>2020-11-17T09:54:42.000Z</published>
    <updated>2021-08-23T15:06:18.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg" alt=""></p><p>回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。<a id="more"></a></p><p>前一阵子看了一部 Netflix 的纪录片——《监视资本主义：智能陷阱 The Social Dilemma》。特里斯坦·哈里斯是谷歌前设计道德伦理专家，他呼吁技术产业在产品中引进被他称为“道德伦理设计”的要素。硅谷之前的商业模式是公司通过销售硬件、软件这样的产品来盈利。而过去十年硅谷则一直在通过“出售”用户来盈利。</p><p>二十多年前，雅虎的杨致远和费罗首创了免费的互联网服务，并且找到了广告这种商业模式，这才让互联网成为一个开放免费的工具。如今网上已经有了很多免费产品，如果我们不用为使用这些产品付钱，那谁来付钱呢？广告商为我们使用的产品付钱。换句话说，广告商是顾客，我们是被销售的商品。</p><p><strong>“如果你没有花钱买产品，那你就是被卖的产品。”</strong>所谓的免费并不是真正的免费，而是广告商在为用户的注意力付钱，我们付出的是自己的时间。手机上各种应用，每天不断推送着通知，都在竞争用户的注意力，想办法增加日活，向广告商出售更多用户的时间。大部分应用会记录用户的浏览记录，甚至在哪张图片或视频上停留了多久。（这是真的）</p><p>我们在互联网上的数据被偷偷共享（还记得在QQ空间看到的京东广告吗），即使使用协议在某个地方注明了这一点，我们也并没有被着重通知。同时我们的数据被公司用来构建更精确的模型，来预判用户行为进而迎合用户：让我们不停滑动屏幕，沉浸其中。</p><p>那些精明的产品经理一般都比较了解心理学，深谙人性的弱点。他们黑入人们的心理，利用这一点一点点来慢慢操纵用户的使用习惯，而用户往往不知不觉地深陷其中。无论是“对方正在输入中”还是“下拉刷新内容”都是对我们心理上的某种操纵。每次下拉刷新都会出现新的内容，这在心理学上叫做“正积极强化”，给用户反馈和激励，有点像赌城的老虎机。</p><p>“我们想在心理学上弄清楚，怎么样以最快的速度操纵你。然后返回给让你产生兴奋的事物。”一位脸书的前用户增长负责人曾经说道。无论是点赞，还是粉丝数增加（有不少是僵尸粉），都是在实践这一点。这就是在利用人们心理的脆弱来赚钱。</p><p>社交媒体就像是毒品。我们都有着基本的欲望去和别人联系，需要和别人有社会性联系，需要得到认可。但我们不需要得到一万人的认可，也不需要每隔五分钟就获得一次社交认可。没有手机，我们能独处吗，可以处理自己的情绪吗？那些不自在、孤独、害怕的情绪很多时候都在指尖麻木地滑动屏幕之时被忽视了。</p><center><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0go8bt5j30zk0k00uk.jpg" alt=""></center><p>如摩尔定律所预测的那样，技术在快速进步，但是人脑却进化缓慢。我们一直在担忧人工智能发展带来的负面影响：人工智能会超过人类的智慧，最终觉醒然后统治人类吗？无论是《终结者》还是《我，机器人》都在传达这种担忧。虽然未来还不太明了，但事实上人工智能已经在碾压人性的弱点了。那些算法在促进人们的两极分化，使我们上瘾，变得激进化，激化我们的虚荣心……</p><p>纪录片中提到，Google 会基于人们的地理位置来进行搜索提示和展示搜索结果排序。这也使得人们变得两极分化，因为一个人看到的往往都是自己感兴趣的内容。Facebook可以说是一个强大的操纵工具，甚至可以对大选产生影响。互联网和社交媒体不断在动摇和侵蚀社会结构。问题不仅仅是观点的对立，而是极端的两极分化，各方丝毫不听取对方的观点，拒绝沟通。</p><p>人工智能并不知道什么是真理，只是被数据训练奔着某个最优的目标，算法是冰冷无情的。AI无法解决谣言和人们之间的对立。在互联网上谣言的传播是真相的6倍。虚假信息往往比较符合大众的口味，会吸引人们的兴趣。而真相和事实相比往往比较枯燥，所以人们会自发转发虚假信息，AI算法也会根据人们的”兴趣”不停地推荐虚假信息。新冠时期传播得快的不止是新冠，还有谣言。美国甚至有”新冠无害，5G有害”的谣言，人们冲上街上推倒5G信号杆，无不荒唐。</p><p>可以说，某种程度上人工智能算法技术在方便我们生活的同时，也把社会中最坏的东西带出来了，并通过网络放大传播，而这些东西是人类社会的威胁。</p><p>什么是「工具」？什么是「产品」？你在使用产品还是你是产品的一部分？这也许是我们每个人都应该思考的。</p><p>要终止现在的这一切很难，平台越做越大，雪球也越滚越大，很难停下来。而且互联网公司有自己营收和股东的压力，仅靠公司的自觉并不够，因此这些公司需要被监管，也急需数据隐私方面的立法。</p><p>推荐算法建造了信息茧房，也弱化了人们的主动思考。我们与之对抗的手段之一是不看推荐的内容，而是主动思考自己想要什么，搜索自己想要的内容。同时建造我们自己的信息茧房也同样重要，关键是选择可靠的信源，这样我们可以尽可能地屏蔽垃圾信息，获取更有价值的信息。</p><p>纪录片中提到，也可以通过下面这些方法减少社交网络的影响：关掉所有通知；分享之前，查找事实，思考信息来源，不要被情绪煽动；减少屏幕使用时间，减少社交媒体时间。不带电子设备进卧室；很多年轻人容易沉迷网络，也许比较好的做法是不要让16岁之前的孩子使用社交媒体。</p><center><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0h1efpoj30zk0ij75i.jpg" alt="你会选择哪一个"><br><div style="font-size:16px;color:#C0C0C0;text-decoration:underline">你会选择哪一个</div></center> <p>Elon musk做过一个访谈 提到了一些社交媒体的负面影响。其中有一点就是，很多人在朋友圈里分享的都是自己最快乐精彩的片段。这样的片段让很多人看到了会抑郁，因为自己的生活并没这么快乐精彩。其实上大部分人99%的时间都是不那么精彩的，大家只是有选择性的分享一些最好的时光。</p><p>我在过去一个月的时间里，周一到周五关闭朋友圈，周末两天打开。因为我平时总会时不时刷朋友圈，这样做确实减少一些了我看手机的时间，感觉效果还不错。但这样做的缺点就是，我不能及时和朋友互动：可能会错过最近发生的事情、少了给别人的点赞和评论。（有意思的是，设计 Facebook 点赞按钮的工程师的初衷是想通过“点赞”传递爱，现在我们却越来越在意点赞了。）</p><p>总之，在是否使用社交网络上需要做一些 Trade-off。但同时我们可以改变自己的一些不好的习惯，吃饭、睡觉、上厕所一直盯着手机，或者学习时被不断打扰。否则这样下去我们只会变成成天盯着屏幕看、把注意力都贡献成广告商的僵尸，从而错过自己本可以拥有的美好人生。</p><p>不妨放下手机，去外面走走，陪一陪自己爱的人和朋友吧。</p><p>推荐阅读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNTQ4ODg4OA==&amp;mid=2247486326&amp;idx=1&amp;sn=fb2b4998bb6a817d4fe08d658ce0384e&amp;chksm=e8e71861df909177e1f602b9f77df389f702e97b250270588b1d716ab5ad67194afe601910c1&amp;scene=21&amp;token=1554957162&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">「黑客帝国」和「楚门的世界」 </a></p><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/HongboSherlock/blog-image/raw/master/img/006w4HKkly1gms0g03vitj30zk0k0mzz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;回想一下我们是不是经常习惯性的拿起手机。无论是晚上睡觉前，还是早上一睁开眼，都会查看一下手机——是否有新的消息。随着互联网的快速发展和人工智能算法的应用，许多问题慢慢浮现：个人数据隐私、技术成瘾、虚假新闻、两极分化，这些都是当前信息社会不可忽视的问题。
    
    </summary>
    
      <category term="科技" scheme="https://hongbosherlock.github.io/categories/%E7%A7%91%E6%8A%80/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://hongbosherlock.github.io/2020/03/29/queue/"/>
    <id>https://hongbosherlock.github.io/2020/03/29/queue/</id>
    <published>2020-03-29T09:41:19.000Z</published>
    <updated>2021-01-23T02:44:09.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><p>队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在 <strong>队列的末尾</strong>。 删除（delete）操作也被称为出队（dequeue)。 你只能移除 <strong>第一个元素</strong>。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png" alt="image"><br><a id="more"></a></p><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><p>为了实现队列，我们可以使用 <strong>动态数组</strong> 和 <strong>指向队列头部的索引</strong>。</p><p>如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// store elements</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">        <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyQueue() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.push_back(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">//出队时注意判断队列是否为空</span></span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.enQueue(<span class="number">5</span>);</span><br><span class="line">    q.enQueue(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.Front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>C++ STL</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line">q.front(); <span class="comment">//访问队列的队首元素</span></span><br><span class="line">q.back();  <span class="comment">//访问队列的队尾元素</span></span><br><span class="line">q.size();  <span class="comment">//队列的元素个数</span></span><br><span class="line">q.pop();   <span class="comment">//移除队列的队首元素</span></span><br></pre></td></tr></table></figure></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>我们可以使用 <strong>固定大小的数组</strong> 和 <strong>两个指针</strong> 来指示起始位置和结束位置。 目的是 <strong>重用</strong> 我们之前提到的被浪费的存储。</p><ul><li>队首指head针和队尾指针tail重合时，队列为空</li><li>tail+1 = head 时，队列满</li></ul><h2 id="队列和广度优先搜索"><a href="#队列和广度优先搜索" class="headerlink" title="队列和广度优先搜索"></a>队列和广度优先搜索</h2><h4 id="1-结点的处理顺序是什么？"><a href="#1-结点的处理顺序是什么？" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h4><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p><p>与树的层序遍历类似，<strong>越是接近根结点的结点将越早地遍历。</strong></p><p>如果在第 <strong>k</strong> 轮中将结点 <strong>X</strong> 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 <strong>k</strong>。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p><h4 id="2-队列的入队和出队顺序是什么？"><a href="#2-队列的入队和出队顺序是什么？" class="headerlink" title="2. 队列的入队和出队顺序是什么？"></a>2. 队列的入队和出队顺序是什么？</h4><p>如上面的动画所示，我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点 <strong>不会</strong> 立即遍历，而是在下一轮中处理。</p><p>结点的处理顺序与它们 <strong>添加</strong> 到队列的顺序是 <strong>完全相同的顺序</strong>，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p><p><strong>伪代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>如代码所示，在每一轮中，队列中的结点是 <strong>等待处理的结点。</strong></li><li>在每个更外一层的 <strong>while</strong> 循环之后，我们 <strong>距离根结点更远一步</strong>。变量 <strong>step</strong> 指示从根结点到我们正在访问的当前结点的距离。</li></ol><p>有两种情况不需要使用哈希集：</p><ol><li>代码中没有循环，例如，在树遍历中；</li><li>希望多次将结点添加到队列中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先进先出&quot;&gt;&lt;a href=&quot;#先进先出&quot; class=&quot;headerlink&quot; title=&quot;先进先出&quot;&gt;&lt;/a&gt;先进先出&lt;/h2&gt;&lt;p&gt;队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在 &lt;strong&gt;队列的末尾&lt;/strong&gt;。 删除（delete）操作也被称为出队（dequeue)。 你只能移除 &lt;strong&gt;第一个元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="队列" scheme="https://hongbosherlock.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://hongbosherlock.github.io/2020/03/23/stack/"/>
    <id>https://hongbosherlock.github.io/2020/03/23/stack/</id>
    <published>2020-03-23T02:41:10.000Z</published>
    <updated>2021-01-23T02:43:03.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先进后出"><a href="#先进后出" class="headerlink" title="先进后出"></a>先进后出</h2><p>栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 <strong>push</strong> 。与队列类似，总是在堆栈的 <strong>末尾添加一个新元素</strong>。但是，删除操作，退栈 <strong>pop</strong> ，将始终删除队列中相对于它的最后一个元素。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png" alt="image"><br><a id="more"></a></p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p><strong>动态数组</strong> 实现栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;               <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** Insert an element into the stack. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Get the top item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.pop_back();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStack s;</span><br><span class="line">    s.push(<span class="number">1</span>);</span><br><span class="line">    s.push(<span class="number">2</span>);</span><br><span class="line">    s.push(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (s.pop() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="栈和深度优先搜索"><a href="#栈和深度优先搜索" class="headerlink" title="栈和深度优先搜索"></a>栈和深度优先搜索</h2><p>在我们到达<strong>最深的结点</strong>之后，我们<strong>只会回溯</strong>并尝试另一条路径。</p><p>当到达终点时，并不一定是最短路径。</p><p>我们首先将根结点推入到栈中；当我们回溯时，我们将从栈中 <strong>弹出最深的结点</strong>，这实际上是推入到栈中的最后一个结点。</p><h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的 <strong>隐式栈</strong>，也称为调用栈（Call Stack）。</p><p>每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。<strong>在计算空间复杂度时，永远不要忘记考虑系统栈</strong>。 </p><h3 id="2-栈实现"><a href="#2-栈实现" class="headerlink" title="2. 栈实现"></a>2. 栈实现</h3><p>如果递归的深度太高，会产生堆栈溢出。 在这种情况下，可以使用 BFS，或使用显式栈实现 DFS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; s;</span><br><span class="line">    add root to s;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to s;</span><br><span class="line">                add next to visited;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove cur from s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该逻辑与递归解决方案完全相同。 但我们使用 <strong>while</strong> 循环和 <strong>栈</strong> 来模拟递归期间的 <strong>系统调用栈</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先进后出&quot;&gt;&lt;a href=&quot;#先进后出&quot; class=&quot;headerlink&quot; title=&quot;先进后出&quot;&gt;&lt;/a&gt;先进后出&lt;/h2&gt;&lt;p&gt;栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 &lt;strong&gt;push&lt;/strong&gt; 。与队列类似，总是在堆栈的 &lt;strong&gt;末尾添加一个新元素&lt;/strong&gt;。但是，删除操作，退栈 &lt;strong&gt;pop&lt;/strong&gt; ，将始终删除队列中相对于它的最后一个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://hongbosherlock.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="https://hongbosherlock.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>初识递归</title>
    <link href="https://hongbosherlock.github.io/2019/12/20/recursion/"/>
    <id>https://hongbosherlock.github.io/2019/12/20/recursion/</id>
    <published>2019-12-20T10:43:08.000Z</published>
    <updated>2021-01-18T10:31:08.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>一个函数调用本身就是递归。<br>递归和普通函数调用一样，是通过栈实现的。</p><h3 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h3><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h3 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h3><ul><li>代替多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解为规模更小的子问题进行求解</li></ul><blockquote><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。</p></blockquote><p>不要试图想清楚整个递和归的过程，这样容易被绕进去。</p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。</strong></p><a id="more"></a><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="递归代码要警惕栈溢出"><a href="#递归代码要警惕栈溢出" class="headerlink" title="递归代码要警惕栈溢出"></a>递归代码要警惕栈溢出</h4><p>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有栈溢出的风险。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p>重复计算就是 f(k) 被计算多次，影响效率。<br>可以用数据结构（比如散列表），来保存已经求解过的 f(k)。</p><p>在计算斐波那契函数 F(n) 的过程中， 我们可以使用 <strong>哈希表</strong> 来跟踪每个以 n 为键的 F(n) 的结果。 <strong>散列表</strong> 作为一个缓存，可以避免重复计算。 <strong>记忆化技术</strong> 是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。</p><h4 id="函数可能会有多个位置进行自我调用"><a href="#函数可能会有多个位置进行自我调用" class="headerlink" title="函数可能会有多个位置进行自我调用"></a>函数可能会有多个位置进行自我调用</h4><h3 id="递归的复杂度"><a href="#递归的复杂度" class="headerlink" title="递归的复杂度"></a>递归的复杂度</h3><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 递归中函数调用较多，执行所需时间也比较多。<br>给出一个递归算法，其时间复杂度 O ( T ) 通常是 <strong>递归调用的数量</strong> (记作 R) 和单次计算的时间复杂度 (表示为 O ( S ) )的乘积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(T)=R∗O(s)</span><br></pre></td></tr></table></figure></p><p>一般情况下单次计算的时间复杂度为 O ( 1 )</p><p><strong>执行树</strong></p><blockquote><p><strong>执行树</strong> 是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p></blockquote><p>归函数的执行树将形成 n 叉树，其中 n 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 f(4) 的执行树。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/01/fibonacci.png" alt="image"></p><p>在 n 层的完全二叉树中，节点的总数为 2^n -1 。因此 f(n) 中递归数目的上限（尽管不严格）也是 2^n -1。那么我们可以估计 f(n) 的时间复杂度为 O(2^n)。</p><p>通过使用 <strong>记忆化技术</strong> 计算 f(n) 的递归将被调用 n-1 次以计算它所依赖的所有先验数字。</p><p>此时时间复杂度为: O ( 1 ) * n = O ( n )。记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><blockquote><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：<strong>递归相关空间</strong>（recursion related space）和 <strong>非递归相关空间</strong>（non-recursion related space）。</p></blockquote><h5 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h5><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。<br>因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要首先考虑这部分的开销。<br><img src="https://assets.leetcode.com/uploads/2019/01/25/card_recursion_stack.png" alt="image"></p><p>如果递归规模较大，可以自己模拟一个栈，用非递归的方法实现。因为递归借助的是我们看不到的系统栈，调用过多时系统栈会溢出。</p><h5 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h5><p>通常包括为全局变量分配的空间（通常在堆中）。<br>还可能包括使用 <strong>记忆化技术</strong> 时，保存递归调用的中间结果分配的空间。</p><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>一般递归调用会在系统调用栈上产生的隐式额外空间。有一种然而，你应该学习识别一种称为尾递归的特殊递归情况，它不受此空间开销的影响。</p><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p></blockquote><p>下面的<strong>打印字符串</strong>就是尾递归的一种情况，即递归调用之后就没有额外的计算语句了。</p><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。<br><img src="https://assets.leetcode.com/uploads/2019/01/26/card_recursion_tail.png" alt="image"></p><p>请注意，在尾递归的情况下，一旦从递归调用返回，我们也会立即返回，因此我们可以跳过整个递归调用返回链，直接返回到原始调用方。这意味着我们根本不需要所有递归调用的调用栈，这为我们节省了空间。</p><p>例如，在步骤（1）中，栈中的一个空间将被分配给 f(x1)，以便调用 f(x2)。然后，在步骤（2）中，函数 f(x2) 能够递归地调用 f(x3)，但是，系统不需要在栈上分配新的空间，而是可以简单地重用先前分配给第二次递归调用的空间。最后，在函数 f(x3) 中，我们达到了基本情况，<strong>该函数可以简单地将结果返回给原始调用方，而不会返回到之前的函数调用中。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、当我们面对一个问题，不清楚是否可以使用递归时，我们可以尝试写下递推关系式，利用数学公式来推导某些关系。</p><p>2、尽可能使用记忆化技术，减少重复计算</p><p>3、担心可能因为递归次数太多，而导致堆栈溢出时，可以使用尾递归。</p><h3 id="一些帮助理解的题目"><a href="#一些帮助理解的题目" class="headerlink" title="一些帮助理解的题目"></a>一些帮助理解的题目</h3><p><strong>一、以相反的顺序打印字符串</strong><br>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><p>首先，我们可以将所需的函数定义为 printReverse(str[0…n-1])，其中 str[0] 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：</p><ul><li>printReverse(str[1…n-1])：以相反的顺序打印子字符串 str[1…n-1] 。</li><li>print(str[0])：打印字符串中的第一个字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//函数首次传入的是 str 的首地址，也就是 &amp;str[0]</span></span><br><span class="line">  <span class="keyword">if</span> (!*str)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//在 str[n-1] = '\0' 时终止</span></span><br><span class="line">  printReverse(str + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>汉诺塔可以看做递归问题<br>N 皇后问题其实是回溯问题</p><p><strong>N皇后问题</strong><br>每行只能放置一个皇后、每列也只能放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出结果里的每一行都代表一种摆法。</span></span><br><span class="line"><span class="comment"> 行里的第i个数字如果是n，就代表第i行的数字应该放在第n列。</span></span><br><span class="line"><span class="comment"> 皇后的行、列编号都是从 1开始算。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> queenPos[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//用来存放算好的皇后位置。最左上角是 (0,0) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//在 0~k-1行已经摆好的情况下，摆第k行及其后面的元素</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==N)&#123;</span><br><span class="line"><span class="comment">//N个皇后已经摆好</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;queenPos[i]+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="comment">//逐尝试第k个皇后的位置</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++) &#123;</span><br><span class="line"><span class="comment">//和已经摆好的 k 个皇后的位置比较，看是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(queenPos[j] == i|| <span class="built_in">abs</span>(queenPos[j]-i)==<span class="built_in">abs</span>(k-j))</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="comment">//第一个条件表示第 i 列已经有皇后了</span></span><br><span class="line"><span class="comment">//第二个条件表示两个皇后是否在同一条对角斜线上 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j==k)&#123;</span><br><span class="line"><span class="comment">//当前选的位置 i 不冲突</span></span><br><span class="line">queenPos[k] = i;</span><br><span class="line"><span class="comment">//queenPos[k] 在第一次赋值后，回溯时值是可能会改变的。</span></span><br><span class="line">NQueen(k+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个for循环中的递归，称作回溯。</span></span><br><span class="line">&#125;<span class="comment">//for循环终止</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">NQueen(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">//从第0行开始摆皇后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全排列</strong></p><p>求 1~n 的全排列。可以分为若干个子问题：以 1 开头的全排列；以 2 开头的全排列；以 3 开头的全排列…</p><ul><li>数组 P 用来存放当前排列</li><li>散列数组 hashTable[x] 当整数 x 已经在数组 P 中时为 true。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// P为当前排列，hashTable 记录整数 x 是否已经在 P 中 </span></span><br><span class="line"><span class="keyword">int</span> n,P[maxn],hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 当前处理排列的第 index 位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123; <span class="comment">//递归边界,已经处理完排列的 n+1 位 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123; <span class="comment">//枚举 1~n，试图将 j 填入P[index]</span></span><br><span class="line"><span class="keyword">if</span>(hashTable[j]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 x 不在 P[0]~P[index-1]中 </span></span><br><span class="line">P[index]=j;           <span class="comment">// 把 x 加入当前排列 </span></span><br><span class="line">hashTable[j]=<span class="literal">true</span>;    <span class="comment">// 记 x 已在 P 中</span></span><br><span class="line">generate(index+<span class="number">1</span>);   <span class="comment">// 处理排列的第 index+1 位</span></span><br><span class="line">hashTable[j] = <span class="literal">false</span>; <span class="comment">// 已处理完 P[index] 为 j 的子问题，还原状态 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="number">3</span>;   </span><br><span class="line">generate(<span class="number">1</span>);  <span class="comment">// 从 P [1] 开始填</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回溯法实现 N 皇后</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">generate</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;  <span class="comment">//递归边界 </span></span><br><span class="line">count++; <span class="comment">//能达到这里的一定是合法的</span></span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;  <span class="comment">//第 x 行 </span></span><br><span class="line"><span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123; <span class="comment">//第 x 行还没有皇后 </span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123; <span class="comment">//遍历之前的皇后 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre) == <span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123; <span class="comment">//可以把皇后放在第 n 行 </span></span><br><span class="line">P[index]=x;</span><br><span class="line">hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">generate(index+<span class="number">1</span>); <span class="comment">//递归处理第 index+1 行皇后</span></span><br><span class="line">hashTable[x]=<span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h3&gt;&lt;p&gt;一个函数调用本身就是递归。&lt;br&gt;递归和普通函数调用一样，是通过栈实现的。&lt;/p&gt;
&lt;h3 id=&quot;递归的条件&quot;&gt;&lt;a href=&quot;#递归的条件&quot; class=&quot;headerlink&quot; title=&quot;递归的条件&quot;&gt;&lt;/a&gt;递归的条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个问题的解可以分解为几个子问题的解&lt;/li&gt;
&lt;li&gt;这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/li&gt;
&lt;li&gt;存在递归终止条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;递归的作用&quot;&gt;&lt;a href=&quot;#递归的作用&quot; class=&quot;headerlink&quot; title=&quot;递归的作用&quot;&gt;&lt;/a&gt;递归的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代替多重循环&lt;/li&gt;
&lt;li&gt;解决本来就是用递归形式定义的问题&lt;/li&gt;
&lt;li&gt;将问题分解为规模更小的子问题进行求解&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，再推敲出终止条件，最后将递推公式和终止条件翻译成代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要试图想清楚整个递和归的过程，这样容易被绕进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式, 不用想一层层的调用关系，不要试图用人脑去分解递归的整个步骤。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hongbosherlock.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="https://hongbosherlock.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>vector 用法总结</title>
    <link href="https://hongbosherlock.github.io/2019/09/04/vector/"/>
    <id>https://hongbosherlock.github.io/2019/09/04/vector/</id>
    <published>2019-09-04T02:36:34.000Z</published>
    <updated>2021-01-18T10:33:04.929Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vector-介绍"><a href="#vector-介绍" class="headerlink" title="vector 介绍"></a>vector 介绍</h4><p>vector 是表示可以改变大小的数组的序列容器。</p><p>vector 能够容纳许多其他类型相同的元素,因此又被称为<strong>容器</strong>。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够<strong>存放任意类型的动态数组</strong>，能够增加和压缩数据。</p><p>与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。</p><p><strong>容器特性</strong></p><p>1.顺序序列</p><blockquote><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p></blockquote><p>2.动态数组</p><blockquote><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p></blockquote><p>3.能够感知内存分配器的（Allocator-aware）</p><blockquote><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p></blockquote><a id="more"></a><h4 id="声明及初始化"><a href="#声明及初始化" class="headerlink" title="声明及初始化"></a>声明及初始化</h4><p><strong>头文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>vector 是一个模板类，所以需要用 vector<typename> arry 这样的方式来声明一个 vector。<br>vector 型变量的声明以及初始化的形式也有许多, 常用的有以下几种形式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;             <span class="comment">//声明一个 int 型向量 a</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);         <span class="comment">//声明一个初始大小为 10 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>, <span class="number">1</span>);      <span class="comment">//声明一个初始大小为 10 且初始值都为 1 的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a);          <span class="comment">//声明并用向量 a 初始化向量 b </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.begin(), a.begin()+<span class="number">3</span>); <span class="comment">//将a向量中从第0个到第2个(共3个)作为向量b的初始值</span></span><br></pre></td></tr></table></figure></typename></p><p>除此之外, 还可以直接使用数组来初始化向量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n, n+<span class="number">5</span>) ;      <span class="comment">//将数组 n 的前 5 个元素作为向量 a 的初值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n+<span class="number">1</span>, n+<span class="number">4</span>) ;    <span class="comment">//将 n[1]-n[4] 范围内的元素作为向量 a 的初值</span></span><br></pre></td></tr></table></figure></p><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const T&amp; x);   //向量尾部增加一个元素X</span><br><span class="line">void pop_back();   //删除向量中最后一个元素</span><br><span class="line"></span><br><span class="line">插入 - insert</span><br><span class="line">iterator insert(iterator it,const T&amp; x);     //向量中迭代器指向元素前增加一个元素x</span><br><span class="line">// vec.insert(vec.begin()+i,a);     在第i+1个元素前面插入a;</span><br><span class="line">vec.insert(a.begin(), 1000);            //将1000插入到向量a的起始位置前</span><br><span class="line">vec.insert(a.begin(), 3, 1000) ;        //将1000分别插入到向量元素位置的0-2处(共3个元素)</span><br><span class="line">b.insert(b.begin(), a.begin(), a.end()) ;   //将a.begin(), a.end()之间的全部元素插入到b.begin()前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除 - erase</span><br><span class="line">iterator erase(iterator it);  //删除向量中迭代器指向元素</span><br><span class="line">// vec.erase(vec.begin()+2);  删除第3个元素</span><br><span class="line">b.erase(b.begin()) ;                     //将起始位置的元素删除</span><br><span class="line">b.erase(b.begin(), b.begin()+3) ;        //将(b.begin(),b.begin()+3)之间的元素删除</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">iterator begin();    //返回向量头指针，指向第一个元素</span><br><span class="line">iterator end();      //返回向量尾指针，指向向量最后一个元素的下一个位置</span><br><span class="line"></span><br><span class="line">int size() const;    //返回向量中元素的个数</span><br><span class="line">void clear();        //清空向量中所有元素</span><br><span class="line">bool empty() const;  //判断向量是否为空，若为空，则向量中无元素</span><br></pre></td></tr></table></figure><p><strong>迭代</strong><br>使用迭代器将容器中数据输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it; </span><br><span class="line">auto it  //上面的简写</span><br><span class="line">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span><br><span class="line">for(it=v.begin(); it!=v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>v.end()</strong> 指向容器器的最后一个元素的后⼀个位置。</p><p><strong>排序</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(),vec.end());    <span class="comment">//默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想 sort 来降序，可重写 sort </span></span><br><span class="line">sort(a,a+n,compare);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a&lt; b;</span><br><span class="line">    <span class="comment">//升序排列，如果改为 return a &gt; b，则为降序 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">reverse(obj.begin(),obj.end()); <span class="comment">//从大到小</span></span><br></pre></td></tr></table></figure></p><p><strong>二维数组</strong></p><ul><li>声明了一个动态二维数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br></pre></td></tr></table></figure><ul><li>先定义好二维数组结构，再直接赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//得到一个 5 行 3 列的数组</span></span><br><span class="line"><span class="comment">//由 vector 实现的二维数组，可以通过 resize() 的形式改变行、列值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">    <span class="built_in">array</span>[i].resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>固定一维的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br></pre></td></tr></table></figure><p>上式类似声明了一个二维数组，第一维的大小是固定的（不超过maxn），但第二维的大小不固定。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用 vector 需要注意以下几点：</p><ul><li>如果要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低。</li><li>vector 作为函数的参数或者返回值时，需要注意它的写法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"> <span class="comment">// “&amp;”绝不可少。</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://blog.csdn.net/duan19920101/article/details/50617190" target="_blank" rel="noopener">C++ 中vector的使用方法</a></li><li><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" rel="noopener">学习C++ -&gt; 向量(vector)</a></li><li><a href="https://blog.csdn.net/w_linux/article/details/71600574" target="_blank" rel="noopener">C++（笔记）浅析vector容器的实例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vector-介绍&quot;&gt;&lt;a href=&quot;#vector-介绍&quot; class=&quot;headerlink&quot; title=&quot;vector 介绍&quot;&gt;&lt;/a&gt;vector 介绍&lt;/h4&gt;&lt;p&gt;vector 是表示可以改变大小的数组的序列容器。&lt;/p&gt;
&lt;p&gt;vector 能够容纳许多其他类型相同的元素,因此又被称为&lt;strong&gt;容器&lt;/strong&gt;。  与 string 相同, vector 同属于 STL 中的一种自定义的数据类型,可以广义上认为是一个能够&lt;strong&gt;存放任意类型的动态数组&lt;/strong&gt;，能够增加和压缩数据。&lt;/p&gt;
&lt;p&gt;与数组相比，vector 消耗更多内存以换取管理存储和以有效方式动态增长的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.顺序序列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.动态数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.能够感知内存分配器的（Allocator-aware）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容器使用一个内存分配器对象来动态地处理它的存储需求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="vector" scheme="https://hongbosherlock.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>malloc 和 memset 用法总结</title>
    <link href="https://hongbosherlock.github.io/2019/06/08/malloc/"/>
    <id>https://hongbosherlock.github.io/2019/06/08/malloc/</id>
    <published>2019-06-08T12:57:28.000Z</published>
    <updated>2021-08-24T08:18:55.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc()函数"></a>malloc()函数</h3><h4 id="1、函数原型及说明："><a href="#1、函数原型及说明：" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：<code>#include &lt;stdlib.h&gt;</code></p><p>malloc() 函数用来动态地分配内存空间其原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明:</strong></p><ul><li>size 为需要分配的内存空间的大小，以字节（Byte）计。</li><li>size -t 是无符号整数类型。</li></ul><p><strong>函数说明:</strong><br>malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。<br>这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。<br>如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。</p><a id="more"></a><p><strong>返回值:</strong><br>分配成功返回指向该内存的地址，失败则返回NULL。<br>关于分配失败的原因，应该有多种，比如说空间不足就是一种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *FirstByte)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。</p><h4 id="2、函数的用法："><a href="#2、函数的用法：" class="headerlink" title="2、函数的用法："></a>2、函数的用法：</h4><p>向malloc申请的空间的大小是以字节为单位的。</p><ul><li><strong>返回的结果是<code>void*</code>，需要类型转换为自己需要的类型 。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* num;</span><br><span class="line">num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>程序示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc example: random string generator*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      /* printf, scanf, NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     /* malloc, free, rand */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,n;</span><br><span class="line">  <span class="keyword">char</span> * buffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"How long do you want the string? "</span>);</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">  buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span> (i+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer==<span class="literal">NULL</span>) <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;i; n++)</span><br><span class="line">    buffer[n]=rand()%<span class="number">26</span>+<span class="string">'a'</span>;</span><br><span class="line">  buffer[i]=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"Random string: %s\n"</span>,buffer);</span><br><span class="line">  <span class="built_in">free</span> (buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该程序生成一个由用户指定的长度的字符串，由字母字符组成。此字符串的可能长度仅受malloc可用内存量的限制。</p><h4 id="3、注意事项："><a href="#3、注意事项：" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>malloc的返回值是一个指针，指向一段可用内存的起始地址。</li><li>申请了内存空间后，必须检查是否分配成功。</li><li>当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。</li><li>malloc() 和 free() 这两个函数应该配对。如果申请后不释放会出现内存泄露。</li><li>虽然malloc()函数的类型是(void<em>),任何类型的指针都可以转换成(void </em>),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。</li></ul><h3 id="memset-函数"><a href="#memset-函数" class="headerlink" title="memset()函数"></a>memset()函数</h3><h4 id="1、函数原型及说明：-1"><a href="#1、函数原型及说明：-1" class="headerlink" title="1、函数原型及说明："></a>1、函数原型及说明：</h4><p>头文件：<code>#include &lt;string.h&gt;</code></p><p>memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span><span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>参数说明：</strong></p><ul><li>ptr 为要操作的内存的指针。</li><li>value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。（最终解释为 unsigned char)</li><li>num 为 ptr 的前 num 个字节。</li><li>size_t 就是unsigned int。</li></ul><p><strong>函数说明:</strong>  memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。</p><p><strong>返回值:</strong>   返回指向 ptr 的指针。</p><h4 id="2、函数用法："><a href="#2、函数用法：" class="headerlink" title="2、函数用法："></a>2、函数用法：</h4><p>memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(str)<span class="number">-1</span>); <span class="comment">// 0或者'\0'是等价的</span></span><br></pre></td></tr></table></figure></p><p>对整型数组初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* num;</span><br><span class="line">num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure></p><h4 id="3、注意事项：-1"><a href="#3、注意事项：-1" class="headerlink" title="3、注意事项："></a>3、注意事项：</h4><ul><li>memset() 中的第三个参数一定要使用 sizeof 操作符，因为每个系统下对类型长度的定义可能不一样。</li><li>memset() 中的第一个参数一定要是一个已知的、已经被分配内存的地址，否则会出错。</li></ul><ul><li><strong>最重要的一点：</strong> 对于单字节数据类型（char）可以初始化为任意支持的值，多字节数据类型只能初始化为 0。</li></ul><p><strong>原因：</strong></p><p>memset是按照字节对待初始化空间进行初始化的，也就是说，函数里面的第二个参数的那个初值（一般为0）是按照一个个字节往第一个参数所指区域赋值的，所以，对于单字节数据类型（char）可以初始化为任意支持的值，都没有问题。</p><p>但是对于多字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。如果将 int 类型数组初始化为1，那么因为int一般是4个字节，那么相当于将一个int元素初始化成了 <strong>0000 0001 0000 0001 0000 0001 0000 0001</strong>，<br>这样对于一个int元素肯定不是1，而是一个很大的数，结果出乎意料。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" target="_blank" rel="noopener">malloc和free函数详解</a></li><li><a href="https://blog.csdn.net/dan15188387481/article/details/49621447" target="_blank" rel="noopener">透彻分析C/C++中memset函数</a></li><li><a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc -C++ Reference</a></li><li><a href="http://www.cplusplus.com/reference/cstring/memset/" target="_blank" rel="noopener">memset -C++ Reference</a></li></ul><p><div align="center"><img src="https://gitee.com/HongboSherlock/blog-image/raw/master/img/IMG_0468.png" style="zoom: 33%;"></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;malloc-函数&quot;&gt;&lt;a href=&quot;#malloc-函数&quot; class=&quot;headerlink&quot; title=&quot;malloc()函数&quot;&gt;&lt;/a&gt;malloc()函数&lt;/h3&gt;&lt;h4 id=&quot;1、函数原型及说明：&quot;&gt;&lt;a href=&quot;#1、函数原型及说明：&quot; class=&quot;headerlink&quot; title=&quot;1、函数原型及说明：&quot;&gt;&lt;/a&gt;1、函数原型及说明：&lt;/h4&gt;&lt;p&gt;头文件：&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;malloc() 函数用来动态地分配内存空间其原型为：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;malloc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size 为需要分配的内存空间的大小，以字节（Byte）计。&lt;/li&gt;
&lt;li&gt;size -t 是无符号整数类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;函数说明:&lt;/strong&gt;&lt;br&gt;malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。&lt;br&gt;这块内存空间在函数执行完成后不会被初始化，它们的值是不确定的。&lt;br&gt;如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="malloc" scheme="https://hongbosherlock.github.io/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>STL 简介</title>
    <link href="https://hongbosherlock.github.io/2019/05/26/stl/"/>
    <id>https://hongbosherlock.github.io/2019/05/26/stl/</id>
    <published>2019-05-26T11:40:15.000Z</published>
    <updated>2021-01-18T10:31:59.529Z</updated>
    
    <content type="html"><![CDATA[<p>STL (Standard Template Library) 标准模板库</p><p>需要引入头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="排序算法sort"><a href="#排序算法sort" class="headerlink" title="排序算法sort"></a>排序算法sort</h3><h4 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h4><p>对基本类型的数组从小到大排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2);</span><br></pre></td></tr></table></figure></p><p>n1 和 n2 都是 int 类型的表达式，可以包含变量。<br>将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。</p><a id="more"></a><h4 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h4><p>对元素类型为 T的基本类型数组从大到小排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, greater&lt;T&gt;());</span><br></pre></td></tr></table></figure></p><h4 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h4><p>用自定义的排序规则，对任何类型 T 的数组排序，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(数组名+n1, 数组名+n2, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>排序规则结构的定义方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  T &amp;a1, <span class="keyword">const</span> T &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若 a1 应该在 a2 前面，则返回 true。</span></span><br><span class="line">        <span class="comment">//否则返回 false。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>排序规则返回 true ，意味着 a1 必须在 a2 前面。<br>返回 false ，意味着 a1 并非必须在 a2 前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//从大到小排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1 &gt; a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按个位数从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a1%<span class="number">10</span> &lt; a2%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对结构体数组进行排列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">double</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按姓名从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stricmp(s1.name&lt;s2.name)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">//按 id 从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span>  Student &amp;s1, <span class="keyword">const</span> Student &amp;s2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><p>STL 提供在排好序的数组上进行二分查找的算法。</p><h4 id="用法一-1"><a href="#用法一-1" class="headerlink" title="用法一"></a>用法一</h4><p>在从小到大排好序的基本类型数组上进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值);</span><br></pre></td></tr></table></figure></p><p>查找区间为下标范围为 [n1,n2) 的元素，下标为 n2 的元素不在排列区间内。</p><p>在该区间内查找 “等于值”的元素，返回为true(找到）或 false（没找到）。</p><h4 id="用法二-1"><a href="#用法二-1" class="headerlink" title="用法二"></a>用法二</h4><p>在用自定义排序规则排好序的、元素为任意的 T 类型的数组中进行二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(数组名+n1, 数组名+n2, 值, 排序规则结构名());</span><br></pre></td></tr></table></figure></p><p>查找时的排序规则，必须和<strong>排序时</strong>(sort函数)的规则一致。</p><p>二分查找实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在包含 size 个元素的 、从小到大排序的 int 数组 a里查找元素 p, 如果找到，则返回元素下标，如果找不到，则返回-1。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>; <span class="comment">//左端点 </span></span><br><span class="line"><span class="keyword">int</span> R=size<span class="number">-1</span>; <span class="comment">//右端点</span></span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=L+(R-L)/<span class="number">2</span>; <span class="comment">//防止 L+R 过大溢出</span></span><br><span class="line"><span class="keyword">if</span>(a[mid]==p)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p&gt;a[mid])</span><br><span class="line">L=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">R=mid<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p>求下面方程的 一个 根： $f(x) =x^3-5x^2+10x-80 = 0$<br>若求出的根是 a，则要求 $|f(a)| &lt;= 10^-6$</p><ul><li>解法：对 f(x) 求导，得 $f’(x)=3x^2-10x+10$ 。由一元二次方程 求根公式知f’(x)= 0 无解，因此 f’(x) 恒大于 0。故f(x) 是单调递增的 。易知 f(0) &lt; 0 且 f(100)&gt;0,,所以 区间 [0,100]内必然有且只一个根 。由于 f(x) 在[0,100]内是单调的，所以可用二分办法在区间  [0,100]中寻找根。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ESP = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x*x<span class="number">-5</span>*x*x+<span class="number">10</span>*x<span class="number">-80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> root,y;</span><br><span class="line"><span class="keyword">double</span> x1=<span class="number">0</span>,x2=<span class="number">100</span>;</span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fabs</span>(y)&gt;ESP)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">x2=root;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x1=root;</span><br><span class="line"></span><br><span class="line">root = x1+(x2-x1)/<span class="number">2</span>;</span><br><span class="line">y=f(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>,root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>寻找指定和的整数对<br>输入 n ( n&lt;= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯定有解 )。题中所有整数都能用int 表示。</p><ul><li>解法一<br>1)将数组排序，复杂度是O(n x log(n))<br>2)对数组中的每个元素a[i],在数组中二分查找m-a[i]，看能否找到。复杂度log(n)，最坏要查找n-2次，所以查找这部分的复杂度也是 O(n ×log(n))</li><li>解法二<br>1)将数组排序，复杂度是O(n x log(n))<br>2)查找的时候，设置两个变量 i 和 j，i 初值是 0，j 初值是 n-1。看 a[i]+a[j],如果大于 m，则j-1，如果小于m就让 i+1。直到 a[i]+a[j] = m。</li></ul><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><p><strong>Aggressive cows</strong><br>总时间限制: 1000ms   内存限制: 65536kB</p><p><strong>描述</strong><br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p><p><strong>输入</strong></p><ul><li>Line 1: Two space-separated integers: N and C</li><li>Lines 2..N+1: Line i+1 contains an integer stall location, xi</li></ul><p><strong>输出</strong></p><ul><li>Line 1: One integer: the largest minimum distance</li></ul><p><strong>样例输入</strong></p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>3</p></blockquote><p><strong>提示</strong><br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p><strong>思路</strong></p><ul><li>先得到排序后的隔间坐标 x1,…,xN</li><li>在 [L,R] 内用二分法尝试“最大最近距离”，D=(L+R)/2,(L,R初值为[1,1000000000/C])</li><li>若 D 可行，则记录该 D，然后在新的 [L,R] 中继续尝试。(L = D+1)。          若 D 不行，则在新 [L,R] 中继续尝试。( R = D-1)</li></ul><p>尝试方法：</p><ul><li>第一头牛放在x1</li><li>若第 k 头牛放在 xi，则找到x（i+1）到 xN 中第一个位于[xi+D,1000000000]中的xj，第 k+1 头牛放在 xj。找不到这样的 xj，则说明不可行。</li></ul><p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> N,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t,s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sort(a,a+N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R=MAX/C;</span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">D = L+(R-L)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]-a[pre]&gt;=D)</span><br><span class="line">        &#123;</span><br><span class="line">            pre=i;</span><br><span class="line">             t++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t&gt;=C)&#123;</span><br><span class="line"></span><br><span class="line">s=D;</span><br><span class="line">L=D+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">R=D<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL (Standard Template Library) 标准模板库&lt;/p&gt;
&lt;p&gt;需要引入头文件：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序算法sort&quot;&gt;&lt;a href=&quot;#排序算法sort&quot; class=&quot;headerlink&quot; title=&quot;排序算法sort&quot;&gt;&lt;/a&gt;排序算法sort&lt;/h3&gt;&lt;h4 id=&quot;用法一&quot;&gt;&lt;a href=&quot;#用法一&quot; class=&quot;headerlink&quot; title=&quot;用法一&quot;&gt;&lt;/a&gt;用法一&lt;/h4&gt;&lt;p&gt;对基本类型的数组从小到大排序：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sort(数组名+n1, 数组名+n2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;n1 和 n2 都是 int 类型的表达式，可以包含变量。&lt;br&gt;将数组下标范围为 [n1,n2) 的元素从小到大排列，下标为 n2 的元素不在排列区间内。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="STL" scheme="https://hongbosherlock.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="https://hongbosherlock.github.io/2019/05/15/struct/"/>
    <id>https://hongbosherlock.github.io/2019/05/15/struct/</id>
    <published>2019-05-15T13:28:41.000Z</published>
    <updated>2021-01-17T15:04:40.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>声明结构的形式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span>       <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                   <span class="comment">// p1,p2 都是 point，里面有 x,y 的值。</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;                  <span class="comment">//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>对于第⼀和第二种形式，都声明了结构point。但是第三种形式没有声明point，只是定义了两个变量。</p><p>一般来说，一个结构变量所占的内存空间的大小就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。</p><ul><li><p>访问变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br><span class="line">p1.y</span><br></pre></td></tr></table></figure></li><li><p>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• p1 = (struct point)&#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 相当于p1.x = 5;p1.y = 10;</span></span><br><span class="line">• p1 = p2;</span><br><span class="line"><span class="comment">// 相当于p1.x = p2.x; p1.y = p2.y;</span></span><br></pre></td></tr></table></figure></li><li><p>结构体指针</p></li></ul><p>和数组不同，结构变量的名字并不是结构变量的地址，必须使⽤用&amp;运算符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">p</span> = &amp;<span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure></p><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>（1）结构体作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(struct point p)</span></span></span><br></pre></td></tr></table></figure><p>• 整个结构可以作为参数的值传⼊入函数</p><p>• 这时候是在函数内新建⼀一个结构变量，并复制调⽤用者的结构的值</p><p>• 也可以返回⼀一个结构</p><p><strong>注意</strong>：传⼊入结构和传⼊数组是不同的：</p><ul><li>函数参数传入的是数组的引用。</li><li>传入结构时，传入的是结构体的拷贝。</li></ul><p>（2）结构指针作为参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct point *p = &amp;p1;</span><br><span class="line">(*p).x = 2;</span><br><span class="line">p-&gt;x = 2;</span><br></pre></td></tr></table></figure></p><p>⽤用<strong>-&gt;</strong>表⽰示指针所指的结构变量中的成员</p><p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct point* <span class="title">inputPoint</span><span class="params">(struct point* p)</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(p-&gt;x),&amp;(p-&gt;y));        </span><br><span class="line"><span class="comment">// 同 (*p).x 和 (*p).y</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(struct point p)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span>=&#123;</span><span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">inputPoint(&amp;y);</span><br><span class="line">output(y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• 好处是传⼊传出只是一个指针的大小。</p><p>• 如果需要保护传入的结构不被函数修改。</p><ul><li>const struct point *p</li></ul><p>• 返回传⼊的指针是一种套路。</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[100];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>[]=&#123;</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明结构的形式：&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;p1&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;p2&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;point&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                   &lt;span class=&quot;comment&quot;&gt;// p1,p2 都是 point，里面有 x,y 的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;p1,p2;                  &lt;span class=&quot;comment&quot;&gt;//p1 和 p2都是一种⽆无名结构，⾥里⾯面有x和y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程基础" scheme="https://hongbosherlock.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="结构体" scheme="https://hongbosherlock.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>函数和字符串</title>
    <link href="https://hongbosherlock.github.io/2019/05/10/string/"/>
    <id>https://hongbosherlock.github.io/2019/05/10/string/</id>
    <published>2019-05-10T10:28:32.000Z</published>
    <updated>2021-01-17T15:05:09.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一维数组作为形参时的写法如下：</p><ul><li>类型名 数组名 []</li></ul><p>数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。</p><p>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。</p><p>二维数组作为函数形参时，必须写明函数有多少列</p><ul><li>类型名 数组名 [][N]   N为列数</li></ul><a id="more"></a><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>&#125;          <span class="comment">//字符数组</span></span><br><span class="line"><span class="keyword">char</span> word[] = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'\0'</span>&#125;     <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure><p>0标志字符串的结束，是字符数组的一部分，但它不是字符串的⼀部分。</p><ul><li>计算字符串⻓长度的时候不包含这个0</li></ul><p>常见的字符串声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• <span class="keyword">char</span> *str = “Hello”;             <span class="comment">//字符串常量，不可修改</span></span><br><span class="line">• <span class="keyword">char</span> word[] = “Hello”;           <span class="comment">//可修改</span></span><br><span class="line">• <span class="keyword">char</span> line[<span class="number">10</span>] = “Hello”;         <span class="comment">//数组大小为6</span></span><br></pre></td></tr></table></figure></p><p>C语⾔言的字符串是以字符数组的形态存在的，″Hello″会被编译器变成⼀个字符数组放在某处，这个数组的长度是6，结尾还有表⽰示结束的0。</p><ul><li>如果要构造⼀一个字符串—&gt;数组</li><li>如果要处理⼀一个字符串—&gt;指针</li></ul><p><strong>声明一个空字符串</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str;          <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"\0"</span>;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">""</span>;    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p>str 是一个空字符串，str[0] == ‘\0’.</p><p>数组 str 的长度为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%<span class="number">7</span>s”, str);</span><br></pre></td></tr></table></figure></p><ul><li>在%和s之间的数字表⽰示最多允许读⼊入的字符的数量，这个数字应该⽐比数组的大小⼀</li><li>scanf 会自动添加结尾的’\0’</li><li><p>scanf 和 cin 读入到空格为止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型 ：gets(char buf[] )</span></span><br><span class="line"><span class="keyword">while</span>( gets(str) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure></li><li><p>读入一行，自动添加 ‘\0’.</p></li><li>回车换行符不会写入 buf，但是会从输入流中去掉。</li></ul><p><strong>字符串数组</strong></p><ul><li>char **a</li></ul><p> a是⼀一个指针，指向另⼀一个指针，那个指针指向⼀一个字符（串）</p><ul><li>char a[][]</li></ul><p>a是⼀一个⼆二维数组，第⼆二个维度的⼤大⼩小不知道，不能编译</p><ul><li>char a[][10]</li></ul><p>a是⼀一个⼆二维数组，a[x]是⼀一个char[10]</p><ul><li>char *a[]</li></ul><p>a是⼀一个⼀一维数组，a[x]是⼀一个char*</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>getchar()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getchar(void);</span><br></pre></td></tr></table></figure></p><ul><li>从标准输⼊入读⼊一个字符</li><li>返回类型是int是为了返回EOF（-1）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=EOF)&#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="库函数-string-h"><a href="#库函数-string-h" class="headerlink" title="库函数 string.h"></a>库函数 string.h</h4><p><strong>strcmp</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure></p><p>比较两个字符串，返回：</p><ul><li><strong>0 : s1==s2</strong></li><li><strong>&gt;0 : s1&gt;s2</strong></li><li><strong>&lt;0 : s1&lt;s2</strong></li></ul><p><strong>strcnmp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strncmp(const char *s1, const char *s2, int  n);</span><br></pre></td></tr></table></figure></p><p>比较 s1 前 n 个字符组成的子串和 s2 前 n 个字符组成的子串的大小。</p><ul><li>若长度不足 n，则取整个串作为子串。返回值和 strcmp 类似。</li></ul><p><strong>strcpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char *restrict dst, const char *restrict src);</span><br></pre></td></tr></table></figure></p><ul><li>把 src 的字符串拷⻉贝到 dst</li><li>restrict 表明 src 和 dst 不重叠（C99）</li></ul><p><strong>strncpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strncpy(char *restrict dst, const char *restrict src, int n);</span><br></pre></td></tr></table></figure></p><p>拷贝 src 的前 n 个字符到 dest。</p><ul><li>如果 src 长度大于或等于 n，该函数不会自动往 dest 中写入’\0’；若</li><li>若 src 长度不足 n，则拷贝 src 的全部内容以及结尾的’\0’到 dest。</li></ul><p><strong>strcat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strcat(char *restrict s1, const char *restrict s2);</span><br></pre></td></tr></table></figure></p><ul><li>把s2拷⻉贝到s1的后⾯面，接成⼀一个⻓长的字符串</li><li>返回s1</li><li>s1必须具有⾜足够的空间</li></ul><h5 id="字符串中找字符："><a href="#字符串中找字符：" class="headerlink" title="字符串中找字符："></a>字符串中找字符：</h5><p><strong>strchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strchr(const char *str, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>第一次</strong>出现的位置。</p><ul><li>如果找到，就返回指向该位置的 char* 指针</li><li>若没找到，返回 NULL</li></ul><p><strong>strrchr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strrchr(const char *s, int c);</span><br></pre></td></tr></table></figure></p><p>寻找字符 c 在字符串 str 中<strong>最后一次</strong>出现的位置。</p><h5 id="字符串中找字符串："><a href="#字符串中找字符串：" class="headerlink" title="字符串中找字符串："></a>字符串中找字符串：</h5><p><strong>strstr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strstr(const char *s1, const char *s2);</span><br></pre></td></tr></table></figure></p><p>寻找子串 s2 在 s1 中第一次出现的位置。</p><ul><li>如果找到，就返回指向该位置的指针。</li><li>若没找到，返回 NULL<br><strong>源码</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len2;</span><br><span class="line">　　<span class="keyword">if</span> ( !(len2 = <span class="built_in">strlen</span>(s2)) )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;   <span class="comment">//字符串为空</span></span><br><span class="line">　　<span class="keyword">for</span> ( ; *s1; ++s1 )</span><br><span class="line">　&#123;</span><br><span class="line">　　<span class="keyword">if</span> ( *s1 == *s2 &amp;&amp; <span class="built_in">strncmp</span>( s1, s2, len2 )==<span class="number">0</span> )</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">char</span> *)s1;</span><br><span class="line">　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h5><p><strong>strtok</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * strtok( char *str, const char *delim);</span><br></pre></td></tr></table></figure></p><p>连续调用该函数若干次，可以做到：从 str 中逐个抽取被字符串 delim 中的字符分隔开的若干字符串。</p><hr><h4 id="判断子串的函数"><a href="#判断子串的函数" class="headerlink" title="判断子串的函数"></a>判断子串的函数</h4><p> <strong>描述:</strong></p><p> 编写一个函数：</p><blockquote><p>int Strstr( char s1[], char s2[]);</p></blockquote><p>如果 s2 不是 s1 的子串，返回 -1,如果 s2 是 s1 的子串，返回在 s1 中第一次出现的位置。空串是任何串的子串，且出现位置为 0.</p><p> <strong>代码:</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;bits/stdc++.h&gt; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Strstr(const char* s1, const char* s2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(s2[0]==0)</span><br><span class="line">return 0;</span><br><span class="line">for(int i=0;s1[i];i++)&#123;</span><br><span class="line">int k=i;</span><br><span class="line">int j=0;</span><br><span class="line">for(;s2[j];j++,k++)&#123;</span><br><span class="line">if(s1[k]!=s2[j])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(s2[j]==0)</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">char s1[50];</span><br><span class="line">gets(s1);</span><br><span class="line"></span><br><span class="line">char s2[20];</span><br><span class="line">gets(s2);</span><br><span class="line"></span><br><span class="line">int f;</span><br><span class="line">f = Strstr(s1,s2);</span><br><span class="line">cout&lt;&lt;f;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;一维数组作为形参时的写法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 []&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组作为函数参数时，是传引用的，即形参数组改变了，实参数组也会改变。&lt;/p&gt;
&lt;p&gt;数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。&lt;/p&gt;
&lt;p&gt;二维数组作为函数形参时，必须写明函数有多少列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型名 数组名 [][N]   N为列数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="https://hongbosherlock.github.io/categories/C/"/>
    
    
      <category term="字符串" scheme="https://hongbosherlock.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
